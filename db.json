{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/varaint/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/module.js","path":"js/module.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/din.otf","path":"css/fonts/din.otf","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-aea.js","path":"js/google-code-prettify/lang-aea.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-Splus.js","path":"js/google-code-prettify/lang-Splus.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-agc.js","path":"js/google-code-prettify/lang-agc.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-apollo.js","path":"js/google-code-prettify/lang-apollo.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-basic.js","path":"js/google-code-prettify/lang-basic.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-cbm.js","path":"js/google-code-prettify/lang-cbm.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-cl.js","path":"js/google-code-prettify/lang-cl.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-clj.js","path":"js/google-code-prettify/lang-clj.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-css.js","path":"js/google-code-prettify/lang-css.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-dart.js","path":"js/google-code-prettify/lang-dart.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-el.js","path":"js/google-code-prettify/lang-el.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-erlang.js","path":"js/google-code-prettify/lang-erlang.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-erl.js","path":"js/google-code-prettify/lang-erl.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-fs.js","path":"js/google-code-prettify/lang-fs.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-go.js","path":"js/google-code-prettify/lang-go.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-hs.js","path":"js/google-code-prettify/lang-hs.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lasso.js","path":"js/google-code-prettify/lang-lasso.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lgt.js","path":"js/google-code-prettify/lang-lgt.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lassoscript.js","path":"js/google-code-prettify/lang-lassoscript.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-latex.js","path":"js/google-code-prettify/lang-latex.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lisp.js","path":"js/google-code-prettify/lang-lisp.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ll.js","path":"js/google-code-prettify/lang-ll.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-llvm.js","path":"js/google-code-prettify/lang-llvm.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-logtalk.js","path":"js/google-code-prettify/lang-logtalk.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ls.js","path":"js/google-code-prettify/lang-ls.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lsp.js","path":"js/google-code-prettify/lang-lsp.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lua.js","path":"js/google-code-prettify/lang-lua.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ml.js","path":"js/google-code-prettify/lang-ml.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-matlab.js","path":"js/google-code-prettify/lang-matlab.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-mumps.js","path":"js/google-code-prettify/lang-mumps.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-nemerle.js","path":"js/google-code-prettify/lang-nemerle.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-n.js","path":"js/google-code-prettify/lang-n.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-pascal.js","path":"js/google-code-prettify/lang-pascal.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-proto.js","path":"js/google-code-prettify/lang-proto.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-r.js","path":"js/google-code-prettify/lang-r.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rd.js","path":"js/google-code-prettify/lang-rd.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rkt.js","path":"js/google-code-prettify/lang-rkt.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rust.js","path":"js/google-code-prettify/lang-rust.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-s.js","path":"js/google-code-prettify/lang-s.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-scala.js","path":"js/google-code-prettify/lang-scala.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-scm.js","path":"js/google-code-prettify/lang-scm.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-sql.js","path":"js/google-code-prettify/lang-sql.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ss.js","path":"js/google-code-prettify/lang-ss.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-swift.js","path":"js/google-code-prettify/lang-swift.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-tcl.js","path":"js/google-code-prettify/lang-tcl.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-tex.js","path":"js/google-code-prettify/lang-tex.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vb.js","path":"js/google-code-prettify/lang-vb.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vbs.js","path":"js/google-code-prettify/lang-vbs.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vhd.js","path":"js/google-code-prettify/lang-vhd.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vhdl.js","path":"js/google-code-prettify/lang-vhdl.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-wiki.js","path":"js/google-code-prettify/lang-wiki.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-xq.js","path":"js/google-code-prettify/lang-xq.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-xquery.js","path":"js/google-code-prettify/lang-xquery.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-yaml.js","path":"js/google-code-prettify/lang-yaml.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-yml.js","path":"js/google-code-prettify/lang-yml.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/prettify.css","path":"js/google-code-prettify/prettify.css","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/prettify.js","path":"js/google-code-prettify/prettify.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/2.jpg","path":"banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/run_prettify.js","path":"js/google-code-prettify/run_prettify.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/tomorrow-night-eighties.min.css","path":"js/google-code-prettify/tomorrow-night-eighties.min.css","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.eot","path":"css/fonts/iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.ttf","path":"css/fonts/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.svg","path":"css/fonts/iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.woff","path":"css/fonts/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/1.jpg","path":"banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/lib.js","path":"js/lib.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/3.jpg","path":"banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/4.jpg","path":"banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/6.jpg","path":"banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/5.jpg","path":"banner/5.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/varaint/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1479196373000},{"_id":"themes/varaint/README.md","hash":"868ebf590d2e6d36a7a88f11c48dd128cc5805b4","modified":1479181084000},{"_id":"source/_posts/gulp-入门教程.md","hash":"f7e44856488a4d0f5240ed82d1bfd4e2116f0de5","modified":1479302587000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1479211977000},{"_id":"themes/varaint/_config.yml","hash":"62ba61cc937f0c863fd3f4f24319772f8b248395","modified":1479217800000},{"_id":"source/_posts/hello-world.md","hash":"63e35031253b1e1f8813689b9e681d9bf32c7731","modified":1479289059000},{"_id":"source/_posts/hanshu.md","hash":"bf56c558f561fd427d3676f5f19442db21db9b8d","modified":1479289221000},{"_id":"source/_posts/纯CSS3实现轮播图.md","hash":"f128de636338f7c02b0608399226950b1159634c","modified":1479288446000},{"_id":"source/_posts/面试题.md","hash":"3049a642865f429a3194258a5cf3f031a3c45b46","modified":1479371128000},{"_id":"themes/varaint/scripts/paging.js","hash":"81d67ff0e9e78f44b84ff042a7c0ab365ebfa7dd","modified":1479181084000},{"_id":"themes/varaint/layout/index.ejs","hash":"9f5f9e9a9eeb297782e34dfd10d608ee0ebd9a0b","modified":1479181084000},{"_id":"source/_posts/基于 Vue 的直播播放器实战.md","hash":"c54bfcafe0014a6cc907c492e8c376c252e0ff44","modified":1479300609000},{"_id":"source/_posts/实现图片拖放.md","hash":"b1ec52aa30c1f4890ef04de1aefb8e15e50d3019","modified":1479289212000},{"_id":"themes/varaint/layout/layout.ejs","hash":"d700ac5cc73361d54616525ab30ba9cd3939d299","modified":1479181084000},{"_id":"themes/varaint/layout/post.ejs","hash":"596a512dde277b33ec091e101f35c0acb08544fe","modified":1479181084000},{"_id":"themes/varaint/source/favicon.png","hash":"e9fc8fabc76fa6aaf3c2fb71535b04400f0e06a8","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/archive.ejs","hash":"5943b5bce733e6fc38b5e9d21492315dec167cbe","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/article.ejs","hash":"c5b0b632f3999ddf7e2a51b134caffd76943b8fd","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/author.ejs","hash":"ef624addd7914c0ceae7d394ad64fe04a1010693","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/banner.ejs","hash":"49ced60b9d231aed216cd77da7013a7357e74152","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/footer.ejs","hash":"f6a6b5a7a7f6045d5a84a171e1f475a8016c4371","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/head.ejs","hash":"305d1fea666305941c8470daf8df14681707588e","modified":1479181084000},{"_id":"source/_posts/函数详解.md","hash":"9c9540151480a3ea9253dddc43065ad23d7db53d","modified":1479301296000},{"_id":"themes/varaint/layout/_partial/header.ejs","hash":"0190f18687c44e63a08349a2a7a17bcca6a542ec","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/search.ejs","hash":"a8b8b5057fedf31a907c0147edef2a2511b8754b","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/sidebar.ejs","hash":"92d052fe1076f7fd425639fc4c251fc34323c7c1","modified":1479181084000},{"_id":"themes/varaint/layout/_widget/date.ejs","hash":"9d012a767db8ef232d30bc54db58df6f54b828af","modified":1479181084000},{"_id":"themes/varaint/layout/_widget/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1479181084000},{"_id":"themes/varaint/source/css/_font.styl","hash":"66e0478c8cc77efb061e587a1b84d4e3ea8902df","modified":1479181084000},{"_id":"themes/varaint/source/css/_var.styl","hash":"930cd91ab1b020a59303312536238bc040260f66","modified":1479181084000},{"_id":"themes/varaint/source/css/style.styl","hash":"f867044b8e05c81e4594e0c1aaa70a539c579071","modified":1479181084000},{"_id":"themes/varaint/source/js/module.js","hash":"cee61899e919ebe29fd9c18f6880a335cee8bdfc","modified":1479181084000},{"_id":"themes/varaint/source/js/script.js","hash":"560e755826fe2ba1151342cca757e4ab7cb4a59d","modified":1479197722000},{"_id":"themes/varaint/layout/_partial/post/duoshuo-comment.ejs","hash":"60d5db26bb7feae7872fed11076a6ccd8fda0ef1","modified":1479200983000},{"_id":"themes/varaint/source/css/fonts/din.otf","hash":"db6c925f4906e671f86d43fe5cb750dea99adddb","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/post/disqus-comment.ejs","hash":"2eff8228047dfd6b00345fee455c9f3de6a741e9","modified":1479181084000},{"_id":"themes/varaint/layout/_partial/post/share.ejs","hash":"e56cc398a4652ba28439f2ed496834886a0442fa","modified":1479181084000},{"_id":"themes/varaint/source/css/_partial/archive.styl","hash":"310c2b49bff77404c1bffbe5a1567af795816596","modified":1479181084000},{"_id":"themes/varaint/source/css/_partial/article.styl","hash":"fe43cba93a726049da8637f486620214d7797822","modified":1479181084000},{"_id":"themes/varaint/source/css/_partial/author.styl","hash":"cab911a74ea31000b37f5c11d02473412a5aaec7","modified":1479181084000},{"_id":"themes/varaint/source/css/_partial/banner.styl","hash":"8f9ce6107c966972c4ec7ceb99fd7a391a8b7260","modified":1479181084000},{"_id":"themes/varaint/source/css/_partial/header.styl","hash":"a3fad4f045270f5a2f9fff5feb44ae0c1caef51e","modified":1479181084000},{"_id":"themes/varaint/source/css/_partial/search.styl","hash":"5b0dae4961ba27f48cd7eec7183673efe6a69a4b","modified":1479181084000},{"_id":"themes/varaint/source/css/_partial/footer.styl","hash":"45a2ea849690abb158cdf59ad1f82eda1af2f5eb","modified":1479181084000},{"_id":"themes/varaint/source/css/_partial/sidebar.styl","hash":"ce695db24414b36bbbb27828db5fdadacce9b77d","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-aea.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-Splus.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-agc.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-apollo.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-basic.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-cbm.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-cl.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-clj.js","hash":"a2c893fc1b79d9c3aed59e22bcf3769bb5563b5c","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-css.js","hash":"22160ffbcd219c018c3dbef745da29cc334c6e8c","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-dart.js","hash":"be57991fbb09bd187be3cb0218bd5e9c997eea5b","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-el.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-erlang.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-erl.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-fs.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-go.js","hash":"640ffa4b3f9c5aee9414962645b9a7f0f49dd555","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-hs.js","hash":"3158902af4476578fc61eb9e47c679e663a77342","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lasso.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lgt.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lassoscript.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-latex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lisp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ll.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-llvm.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-logtalk.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ls.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lsp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lua.js","hash":"60a3dccac2fe79b0e1c38dec6be79a6ae51883fa","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ml.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-matlab.js","hash":"94c8fd7c44194dd3b1a444a3fc7c2b7fd09d9d6a","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-mumps.js","hash":"a6002126b8dfc84a167040a024aad9b6b4e406ee","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-nemerle.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-n.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-pascal.js","hash":"6630a2845b3a0951cbd4b2b8f69d538e0845a53e","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-proto.js","hash":"76ab0965b0e47de76cb5293ceafc7e5ca1588380","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-r.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rd.js","hash":"f2c5bbaca8b6a00737dbdd30d26ea84a0c9db9bc","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rkt.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rust.js","hash":"4e91bf396678821d7124e45478f77662912f68a6","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-s.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-scala.js","hash":"cf07e43b333938964236f455826c335fc806aaa5","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-scm.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-sql.js","hash":"483cc0f4bd0773f6e7377f48b7a028d83790dd1b","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ss.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-swift.js","hash":"96ecf47954b110d6f46afde474dca4a8a36de641","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-tcl.js","hash":"38c918e9a43c8975074302305b8b8e5f30d513dc","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-tex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vb.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vbs.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vhd.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vhdl.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-wiki.js","hash":"c4090580e86c5040709e6b8fd63b661f978149a6","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-xq.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-xquery.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-yaml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-yml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/prettify.css","hash":"8e1c89c9a44e0e837551bdfe250a672d6c21f2b7","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/prettify.js","hash":"8f3a565f0a190aa9df6c9e6e0cb2c3c2445bfa55","modified":1479181084000},{"_id":"themes/varaint/source/banner/2.jpg","hash":"3893f17888bf5fdd21d7d132431a6a255ffa3903","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/run_prettify.js","hash":"face8177a6804506c67c5644c00f3c6e0e50f02b","modified":1479181084000},{"_id":"themes/varaint/source/js/google-code-prettify/tomorrow-night-eighties.min.css","hash":"f654ece8ef13e740f844ce593912e040e3f21e5f","modified":1479181084000},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.eot","hash":"1f90b84b9d3afe27303ce73196f9786efc42953b","modified":1479181084000},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.ttf","hash":"cc36ce4748a2294a915a467a6b4feb046b1aaeb1","modified":1479181084000},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.svg","hash":"73321f0798240e541a0f3f468bb6828feeb64fa0","modified":1479181084000},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.woff","hash":"130d610313a6bcdb1d3dd1451b53087a2c2a56e9","modified":1479181084000},{"_id":"themes/varaint/source/css/_partial/post/share.styl","hash":"7e7ce553e746b788fe723eb33028e9f3b5a5fb3c","modified":1479181084000},{"_id":"themes/varaint/source/banner/1.jpg","hash":"0a5c0d41ca9382b7fa14b16a6650d101961ba84b","modified":1479181084000},{"_id":"themes/varaint/source/js/lib.js","hash":"d1f3a62d0d91c3000e9b351e41ad441f0632f8b9","modified":1479181084000},{"_id":"themes/varaint/source/banner/3.jpg","hash":"d81a28a4fe24270c2410de9165d58da11fb42382","modified":1479197722000},{"_id":"themes/varaint/source/banner/4.jpg","hash":"ced2b163d0ed542c494a45d5ccd072e57a5f4211","modified":1479181084000},{"_id":"themes/varaint/source/banner/6.jpg","hash":"6117e2b3132fde432d403f5d28c329b35d92341e","modified":1479197722000},{"_id":"themes/varaint/source/banner/5.jpg","hash":"aae13a6a71e4c89e7ecd66f060cf3cfff3b79862","modified":1479197722000},{"_id":"public/2016/07/15/实现图片拖放/index.html","hash":"4d313facb264785e0a40e064ce8587274eb6e967","modified":1479370393070},{"_id":"public/2016/06/15/纯CSS3实现轮播图/index.html","hash":"244277dff76456adbc0c7c81d6117221534916b8","modified":1479370393097},{"_id":"public/2016/03/16/hello-world/index.html","hash":"1fb21137a9b68448f5faadd5973d07e0eaa4422b","modified":1479370393099},{"_id":"public/archives/index.html","hash":"9121b13d2ac35bb3477bd991dddccfcc87d8f554","modified":1479370393100},{"_id":"public/archives/2016/07/index.html","hash":"01a0626f4e6d89470237c0f471670b8a40faccd7","modified":1479370393100},{"_id":"public/archives/2016/06/index.html","hash":"43b5c03f45fea0811f522d19ecc9fe39286ea2b2","modified":1479370393100},{"_id":"public/archives/2016/index.html","hash":"935b5378232ab6b0c59fbe90df9b1683312a14fa","modified":1479370393100},{"_id":"public/archives/2016/10/index.html","hash":"2ddf981ec1a524d626e4c9ee20d66499dc6a2723","modified":1479370393100},{"_id":"public/archives/2016/08/index.html","hash":"e128b77cf7c0b892040af10978ffe146be3b126b","modified":1479370393100},{"_id":"public/index.html","hash":"b73a3c44bebdd99743637f706f3499edf0ee8023","modified":1479370393100},{"_id":"public/tags/gulp/index.html","hash":"3c340202124d8611362ccb6be70439d21cc277fa","modified":1479370393100},{"_id":"public/tags/gulp入门教程详解/index.html","hash":"f437678fc020f4858827f8e3e42d655eff1d0233","modified":1479370393100},{"_id":"public/tags/javascript/index.html","hash":"c62a8636d490f189c44f37b3148e7e830e5c474b","modified":1479370393100},{"_id":"public/tags/7种创建对象的方法/index.html","hash":"25a3a8649bcd4edc920d16faddebbc68b731ed95","modified":1479370393100},{"_id":"public/tags/实现简单的轮播图/index.html","hash":"a6c51a86bb6340ef23d16cf9e67594ea8ba53a8e","modified":1479370393100},{"_id":"public/tags/CSS/index.html","hash":"6208bb2304d4131eaec12019e1ec5ae80472181d","modified":1479370393100},{"_id":"public/tags/vue/index.html","hash":"493ebd3b988dd7c33550d8e76eb28056b531e6eb","modified":1479370393101},{"_id":"public/tags/基于vue直播播放器实战/index.html","hash":"403473dabe30980421465ea27469bf2ae9a615ef","modified":1479370393101},{"_id":"public/tags/函数详解/index.html","hash":"2c6b6b6c0a86fe91811e56ed6c61c32f1dffea5d","modified":1479370393101},{"_id":"public/archives/2016/03/index.html","hash":"663a25c2dc176de41fd617770c90eb482158f32d","modified":1479370393101},{"_id":"public/2016/08/10/函数详解/index.html","hash":"e4219deb47d5c4504670daa4e33fa5c42844846a","modified":1479370393101},{"_id":"public/2016/10/16/gulp-入门教程/index.html","hash":"d2935a9165896d6ebdb425722bdeb11251d19a79","modified":1479370393101},{"_id":"public/2016/07/25/hanshu/index.html","hash":"15bd4e293b9b5032c6d7b7c20654ebfb71182e17","modified":1479370393101},{"_id":"public/2016/07/20/基于 Vue 的直播播放器实战/index.html","hash":"9d677c434d69a4cf3b4c0b0f2f3c4b25edd9e11c","modified":1479370393101},{"_id":"public/archives/2016/11/index.html","hash":"9f86a2e5b7f71fcc84eb1af8a8299974a165ecb2","modified":1479370393107},{"_id":"public/tags/js/index.html","hash":"8fdd4215bc913201339d1d452d2c9be87d99951c","modified":1479370393107},{"_id":"public/tags/canvas/index.html","hash":"81bf011e0317cfaa78304dd0d9076a2890798e04","modified":1479370393107},{"_id":"public/tags/面试题/index.html","hash":"d0ca175e7c0a603533fa121027387f8c61b63cf5","modified":1479370393107},{"_id":"public/2016/11/17/面试题/index.html","hash":"0e2661f94a2dd7922eec9ae984f7325793ea594f","modified":1479371136380},{"_id":"public/favicon.png","hash":"e9fc8fabc76fa6aaf3c2fb71535b04400f0e06a8","modified":1479370393107},{"_id":"public/css/fonts/din.otf","hash":"db6c925f4906e671f86d43fe5cb750dea99adddb","modified":1479370393107},{"_id":"public/css/fonts/iconfont/iconfont.eot","hash":"1f90b84b9d3afe27303ce73196f9786efc42953b","modified":1479370393967},{"_id":"public/css/fonts/iconfont/iconfont.woff","hash":"130d610313a6bcdb1d3dd1451b53087a2c2a56e9","modified":1479370393970},{"_id":"public/css/fonts/iconfont/iconfont.svg","hash":"73321f0798240e541a0f3f468bb6828feeb64fa0","modified":1479370393982},{"_id":"public/css/fonts/iconfont/iconfont.ttf","hash":"cc36ce4748a2294a915a467a6b4feb046b1aaeb1","modified":1479370393982},{"_id":"public/js/script.js","hash":"560e755826fe2ba1151342cca757e4ab7cb4a59d","modified":1479370393991},{"_id":"public/js/module.js","hash":"cee61899e919ebe29fd9c18f6880a335cee8bdfc","modified":1479370393991},{"_id":"public/js/google-code-prettify/lang-aea.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1479370393997},{"_id":"public/js/google-code-prettify/lang-Splus.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1479370393997},{"_id":"public/js/google-code-prettify/lang-apollo.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1479370393997},{"_id":"public/js/google-code-prettify/lang-basic.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1479370393998},{"_id":"public/js/google-code-prettify/lang-cbm.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1479370393998},{"_id":"public/js/google-code-prettify/lang-clj.js","hash":"a2c893fc1b79d9c3aed59e22bcf3769bb5563b5c","modified":1479370393998},{"_id":"public/js/google-code-prettify/lang-css.js","hash":"22160ffbcd219c018c3dbef745da29cc334c6e8c","modified":1479370393998},{"_id":"public/js/google-code-prettify/lang-cl.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479370393999},{"_id":"public/js/google-code-prettify/lang-dart.js","hash":"be57991fbb09bd187be3cb0218bd5e9c997eea5b","modified":1479370393999},{"_id":"public/js/google-code-prettify/lang-el.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-erlang.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-fs.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-erl.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-go.js","hash":"640ffa4b3f9c5aee9414962645b9a7f0f49dd555","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-hs.js","hash":"3158902af4476578fc61eb9e47c679e663a77342","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-lasso.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-lassoscript.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-lgt.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-latex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-lisp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-llvm.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-ll.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-logtalk.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1479370394000},{"_id":"public/js/google-code-prettify/lang-ls.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-lsp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-lua.js","hash":"60a3dccac2fe79b0e1c38dec6be79a6ae51883fa","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-ml.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-mumps.js","hash":"a6002126b8dfc84a167040a024aad9b6b4e406ee","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-n.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-nemerle.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-pascal.js","hash":"6630a2845b3a0951cbd4b2b8f69d538e0845a53e","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-proto.js","hash":"76ab0965b0e47de76cb5293ceafc7e5ca1588380","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-r.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1479370394001},{"_id":"public/js/google-code-prettify/lang-rust.js","hash":"4e91bf396678821d7124e45478f77662912f68a6","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-rd.js","hash":"f2c5bbaca8b6a00737dbdd30d26ea84a0c9db9bc","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-rkt.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-agc.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-s.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-scala.js","hash":"cf07e43b333938964236f455826c335fc806aaa5","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-scm.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-sql.js","hash":"483cc0f4bd0773f6e7377f48b7a028d83790dd1b","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-ss.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-swift.js","hash":"96ecf47954b110d6f46afde474dca4a8a36de641","modified":1479370394002},{"_id":"public/js/google-code-prettify/lang-tcl.js","hash":"38c918e9a43c8975074302305b8b8e5f30d513dc","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-tex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-vb.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-vbs.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-vhd.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-vhdl.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-wiki.js","hash":"c4090580e86c5040709e6b8fd63b661f978149a6","modified":1479370394003},{"_id":"public/css/style.css","hash":"2d80e51e74203f7b4616e9d2c9cb675f800df399","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-matlab.js","hash":"94c8fd7c44194dd3b1a444a3fc7c2b7fd09d9d6a","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-xquery.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-xq.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1479370394003},{"_id":"public/js/google-code-prettify/lang-yaml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1479370394008},{"_id":"public/js/google-code-prettify/prettify.js","hash":"8f3a565f0a190aa9df6c9e6e0cb2c3c2445bfa55","modified":1479370394008},{"_id":"public/js/google-code-prettify/tomorrow-night-eighties.min.css","hash":"f654ece8ef13e740f844ce593912e040e3f21e5f","modified":1479370394008},{"_id":"public/js/google-code-prettify/prettify.css","hash":"8e1c89c9a44e0e837551bdfe250a672d6c21f2b7","modified":1479370394008},{"_id":"public/js/google-code-prettify/lang-yml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1479370394009},{"_id":"public/js/google-code-prettify/run_prettify.js","hash":"face8177a6804506c67c5644c00f3c6e0e50f02b","modified":1479370394009},{"_id":"public/js/lib.js","hash":"d1f3a62d0d91c3000e9b351e41ad441f0632f8b9","modified":1479370394009},{"_id":"public/banner/2.jpg","hash":"3893f17888bf5fdd21d7d132431a6a255ffa3903","modified":1479370394009},{"_id":"public/banner/1.jpg","hash":"0a5c0d41ca9382b7fa14b16a6650d101961ba84b","modified":1479370394018},{"_id":"public/banner/3.jpg","hash":"d81a28a4fe24270c2410de9165d58da11fb42382","modified":1479370394025},{"_id":"public/banner/4.jpg","hash":"ced2b163d0ed542c494a45d5ccd072e57a5f4211","modified":1479370394026},{"_id":"public/banner/6.jpg","hash":"6117e2b3132fde432d403f5d28c329b35d92341e","modified":1479370394030},{"_id":"public/banner/5.jpg","hash":"aae13a6a71e4c89e7ecd66f060cf3cfff3b79862","modified":1479370394032}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"gulp-入门教程","date":"2016-10-16T13:02:24.000Z","_content":"\n# gulp入门教程详解\n最近使用gulp自动化构建工具来开发网站，在此给大家分享一下使用gulp的一些使用教程。\n\n## 一、 gulp安装\n#### 1、安装nodejs\n       1.1、说明：gulp是基于nodejs，理所当然需要安装nodejs\n\n       1.2、安装：打开[<font style=\"blue\">nodejs官网</font>](https://nodejs.org/en/)，点击硕大的绿色Download按钮，它会根据系统信息选择对应版本（.msi文件）。\n\n#### 2、全局安装gulp\n        2.1、说明：全局安装gulp目的是为了通过她执行gulp任务；\n\n        2.2、安装：命令提示符执行npm install gulp -g；\n\n        2.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。\n\n#### 3、新建package.json文件\n       3.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；\n\n       3.2、执行命令提示符执行npm init进行手动安装\n\n       3.3、安装完成后会在当前文件夹下看到如下package.json文件\n       \n![Mou icon](http://upload-images.jianshu.io/upload_images/3164024-76d2e9fa62a00632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)       \n\n\n#### package.json文件\n\n       文件说明：\n\n      \"name\":\"test\",//项目名称（必须）\n\n      \"version\":\"1.0.0\",//项目版本（必须）\n\n      \"description\":\"This is for study gulp project !\",//项目描述（必须）\n\n      \"devDependencies\":{//项目依赖的插件\n\n       3.4、查看package.json帮助文档，命令提示符执行npm help package.json\n\n#### 4、安装本地gulp及其常用插件\n      4.1、执行命令行npm install gulp 安装本地gulp\n\n     4.2、安装gulp插件：以gulp—sass为例\n\n     执行命令npm install gulp-sass即可安装gulp-sass插件，安装完成后即可在node_modules文件夹下查看到新安装的插件\n\n#### 5、新建gulpfile.js文件（重要）\n     5.1、说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）\n\n     5.2、gulpfile.js文件用法（以gulp-sass为例）\n\n    \t 5.2.1 导入工具包 require('node_modules里对应模块')\n\n             var gulp=require('gulp')\n\n             var less=require('gulp-less');\n\n     \t5.2.2 定义一个testLess任务（自定义任务名称）\n\n\tgulp.task('testLess',function(){\n\n\t\tgulp.src('src/less/index.less')     //该任务针对的文件\n\n\t\t.pipe(less())      //该任务调用的模块\n\n\t\t.pipe(gulp.dest('src/css'));     //将会在src/css下生成index.css\n\n\t});\n\n\tgulp.task(\"default\",[\"watch\"],function(){ //定义默认任务 并让gulp监视文件变化自动执行\n\n\tgulp.watch(\"sass/*.scss\",[\"sass\"]);       \n\n\t})\n## 二、gulp常用插件\n\n#### 1、gulp-uglify(JS压缩)\n\n##### 安装：npm install --save-dev gulp-uglify\n\n#### gulpfile.js代码如下：\n\n\tvar gulp = require('gulp'),\n\n\tvar rename= require('gulp-rename')\n\n\tvar uglify= require(\"gulp-uglify\");\n\n\tgulp.task('rename',function() {\n\t\n\t\tgulp.src('src/**/*.js')\n\t\t\n\t\t.pipe(uglify())//压缩\n\t\t\n\t\t.pipe(rename('index.min.js'))    \n\t\t\n\t\t.pipe(gulp.dest('build/js'));\n\n\t});\n\n\tgulp.task('default',['rename']);\n\n\tuglify= require(\"gulp-uglify\");\n\t\n#### 2、gulp-minify-html（html压缩）\n\n#### 安装：npm install --save-dev gulp-minify-html\n\n#### 代码如下：\n\n\n\tvar gulp = require('gulp'),\n\n\tvar minifyHtml= require(\"gulp-minify-html\");\n\n\tgulp.task('minify-html',function() {\n\t\n\t\tgulp.src('src/**/*.html')//要压缩的html文件\n\t\t\n\t\t.pipe(minifyHtml())//压缩\n\t\t\n\t\t.pipe(gulp.dest('build'));\n\n\t});\n\n\tgulp.task('default',['minify-html']);\n\n#### 3、 gulp-concat (js文件合并)\n#### 安装：npm install --save-dev gulp-concat\n\n#### 代码如下：\n\n\n\tvar gulp = require('gulp'),\n\n\tconcat= require(\"gulp-concat\");\n\n\tgulp.task('concat',function() {\n\t\n\t gulp.src('src/**/*.js')  //要合并的文件\n\t \n\t .pipe(concat('index.js'))  //合并匹配到的js文件并命名为 \"index.js\"\n\t \n\t .pipe(gulp.dest('build/js'));\n\n\t});\n\n\tgulp.task('default',['concat']);\n\n#### 4、gulp-jada\n#### 安装：npm install –save-dev  gulp-jada\n\n#### Gulpfile.js代码如下：\n\n\tvar gulp= require('gulp');\n\n\tvar jade= require('gulp-jade');\n\n\tgulp.task(\"jade\",function(){\n\n\tgulp.src(\"./jade/*.jade\")\n\t\n\t\t.pipe(jade({\n\t\n\t\tpretty:true\n\n\t}))\n\t\n\t\t.pipe(gulp.dest(\"html/\"))\n\n\t})\n\t\n\t\tgulp.task(\"default\",[\"watch\"],function(){\n\t\t\n\t\tgulp.watch(\"jade/*.jade\",[\"jade\"]);\n\n\t})\n#### 4、gulp-less\n#### 安装：npm install –save-dev  gulp-less\n\n#### Gulpfile.js代码如下：\n\n\n\tvar gulp = require('gulp'),\n\n\tvar less= require(\"gulp-less\");\n\n\tgulp.task('compile-less',function() {\n\t\n\t  gulp.src('src/less/*.less')\n\t \n\t  .pipe(less())\n\t  \n\t  .pipe(gulp.dest('build/css'));\n\n\t});\n\n\tgulp.task('default',['compile-less']);\n\n#### 5、gulp-sass\n#### 安装：npm install –save-dev  gulp-sass\n\n#### 代码如下：\n\n\tvar gulp = require('gulp'),\n\n\tvar sass= require(\"gulp-sass\");\n\n\tgulp.task('compile-sass',function() {\n\t\t gulp.src('src/sass/*.sass')\n\t\t \n\t\t .pipe(sass())\n\t\t \n\t\t .pipe(gulp.dest('build/css'));\n\n\t});\n\n\tgulp.task('default',['compile-sass']);\n\n#### 6、gulp-imagemin（图片压缩）\n#### 安装：npm install –save-dev  gulp-imagemin\n\n#### 代码如下：\n\n\n\tvar gulp = require('gulp');\n\n\tvar imagemin = require('gulp-imagemin');\n\t\n\tgulp.task('uglify-imagemin',function() {returngulp.src('src/images/*')\n\t\n\t\t.pipe(imagemin())\n\t\n\t\t.pipe(gulp.dest('build/images'));\n\n\t});\n\n\tgulp.task('default',['uglify-imagemin']);\n\n#### 7、理解Browserify\n\nbrowserify是一个使用node支持的CommonJS模块标准 来为浏览器编译模块的，可以解决模块及依赖管理；\n\n#### 先来看看使用gulp常见的问题：\n\n使用 gulp 过程中，偶尔会遇到 Streaming not supported 这样的错误。这通常是因为常规流与 vinyl 文件对象流有差异、\n\ngulp 插件默认使用了只支持 buffer （不支持 stream）的库。比如，不能把 Node 常规流直接传递给 gulp 及其插件。\n\n比如如下代码：会抛出异常的；\n\n\n\tvargulp = require('gulp');\n\n\tvaruglify = require('gulp-uglify');\n\n\tvarconcat = require('gulp-concat');\n\n\tvarrename = require('gulp-rename');varfs = require('fs');\n\n\tgulp.task('bundle',function() {returnfs.createReadStream('./test.txt')\n\t\n\t\t.pipe(uglify())\n\t\t\n\t\t.pipe(rename('bundle.min.js'))\n\t\t\n\t\t.pipe(gulp.dest('dist/'));\n\n\t});\n\n\tgulp.task('default',['bundle']);\n\n文／原创/Dimple（github作者）\n原文链接：https://cuidapao.github.io/\n著作权归作者所有，转载请联系作者获得授权，并标注“github作者”。\n","source":"_posts/gulp-入门教程.md","raw":"---\ntitle: gulp-入门教程\ndate: 2016-10-16 21:02:24\ntags: [gulp,gulp入门教程详解]\n---\n\n# gulp入门教程详解\n最近使用gulp自动化构建工具来开发网站，在此给大家分享一下使用gulp的一些使用教程。\n\n## 一、 gulp安装\n#### 1、安装nodejs\n       1.1、说明：gulp是基于nodejs，理所当然需要安装nodejs\n\n       1.2、安装：打开[<font style=\"blue\">nodejs官网</font>](https://nodejs.org/en/)，点击硕大的绿色Download按钮，它会根据系统信息选择对应版本（.msi文件）。\n\n#### 2、全局安装gulp\n        2.1、说明：全局安装gulp目的是为了通过她执行gulp任务；\n\n        2.2、安装：命令提示符执行npm install gulp -g；\n\n        2.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。\n\n#### 3、新建package.json文件\n       3.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；\n\n       3.2、执行命令提示符执行npm init进行手动安装\n\n       3.3、安装完成后会在当前文件夹下看到如下package.json文件\n       \n![Mou icon](http://upload-images.jianshu.io/upload_images/3164024-76d2e9fa62a00632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)       \n\n\n#### package.json文件\n\n       文件说明：\n\n      \"name\":\"test\",//项目名称（必须）\n\n      \"version\":\"1.0.0\",//项目版本（必须）\n\n      \"description\":\"This is for study gulp project !\",//项目描述（必须）\n\n      \"devDependencies\":{//项目依赖的插件\n\n       3.4、查看package.json帮助文档，命令提示符执行npm help package.json\n\n#### 4、安装本地gulp及其常用插件\n      4.1、执行命令行npm install gulp 安装本地gulp\n\n     4.2、安装gulp插件：以gulp—sass为例\n\n     执行命令npm install gulp-sass即可安装gulp-sass插件，安装完成后即可在node_modules文件夹下查看到新安装的插件\n\n#### 5、新建gulpfile.js文件（重要）\n     5.1、说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）\n\n     5.2、gulpfile.js文件用法（以gulp-sass为例）\n\n    \t 5.2.1 导入工具包 require('node_modules里对应模块')\n\n             var gulp=require('gulp')\n\n             var less=require('gulp-less');\n\n     \t5.2.2 定义一个testLess任务（自定义任务名称）\n\n\tgulp.task('testLess',function(){\n\n\t\tgulp.src('src/less/index.less')     //该任务针对的文件\n\n\t\t.pipe(less())      //该任务调用的模块\n\n\t\t.pipe(gulp.dest('src/css'));     //将会在src/css下生成index.css\n\n\t});\n\n\tgulp.task(\"default\",[\"watch\"],function(){ //定义默认任务 并让gulp监视文件变化自动执行\n\n\tgulp.watch(\"sass/*.scss\",[\"sass\"]);       \n\n\t})\n## 二、gulp常用插件\n\n#### 1、gulp-uglify(JS压缩)\n\n##### 安装：npm install --save-dev gulp-uglify\n\n#### gulpfile.js代码如下：\n\n\tvar gulp = require('gulp'),\n\n\tvar rename= require('gulp-rename')\n\n\tvar uglify= require(\"gulp-uglify\");\n\n\tgulp.task('rename',function() {\n\t\n\t\tgulp.src('src/**/*.js')\n\t\t\n\t\t.pipe(uglify())//压缩\n\t\t\n\t\t.pipe(rename('index.min.js'))    \n\t\t\n\t\t.pipe(gulp.dest('build/js'));\n\n\t});\n\n\tgulp.task('default',['rename']);\n\n\tuglify= require(\"gulp-uglify\");\n\t\n#### 2、gulp-minify-html（html压缩）\n\n#### 安装：npm install --save-dev gulp-minify-html\n\n#### 代码如下：\n\n\n\tvar gulp = require('gulp'),\n\n\tvar minifyHtml= require(\"gulp-minify-html\");\n\n\tgulp.task('minify-html',function() {\n\t\n\t\tgulp.src('src/**/*.html')//要压缩的html文件\n\t\t\n\t\t.pipe(minifyHtml())//压缩\n\t\t\n\t\t.pipe(gulp.dest('build'));\n\n\t});\n\n\tgulp.task('default',['minify-html']);\n\n#### 3、 gulp-concat (js文件合并)\n#### 安装：npm install --save-dev gulp-concat\n\n#### 代码如下：\n\n\n\tvar gulp = require('gulp'),\n\n\tconcat= require(\"gulp-concat\");\n\n\tgulp.task('concat',function() {\n\t\n\t gulp.src('src/**/*.js')  //要合并的文件\n\t \n\t .pipe(concat('index.js'))  //合并匹配到的js文件并命名为 \"index.js\"\n\t \n\t .pipe(gulp.dest('build/js'));\n\n\t});\n\n\tgulp.task('default',['concat']);\n\n#### 4、gulp-jada\n#### 安装：npm install –save-dev  gulp-jada\n\n#### Gulpfile.js代码如下：\n\n\tvar gulp= require('gulp');\n\n\tvar jade= require('gulp-jade');\n\n\tgulp.task(\"jade\",function(){\n\n\tgulp.src(\"./jade/*.jade\")\n\t\n\t\t.pipe(jade({\n\t\n\t\tpretty:true\n\n\t}))\n\t\n\t\t.pipe(gulp.dest(\"html/\"))\n\n\t})\n\t\n\t\tgulp.task(\"default\",[\"watch\"],function(){\n\t\t\n\t\tgulp.watch(\"jade/*.jade\",[\"jade\"]);\n\n\t})\n#### 4、gulp-less\n#### 安装：npm install –save-dev  gulp-less\n\n#### Gulpfile.js代码如下：\n\n\n\tvar gulp = require('gulp'),\n\n\tvar less= require(\"gulp-less\");\n\n\tgulp.task('compile-less',function() {\n\t\n\t  gulp.src('src/less/*.less')\n\t \n\t  .pipe(less())\n\t  \n\t  .pipe(gulp.dest('build/css'));\n\n\t});\n\n\tgulp.task('default',['compile-less']);\n\n#### 5、gulp-sass\n#### 安装：npm install –save-dev  gulp-sass\n\n#### 代码如下：\n\n\tvar gulp = require('gulp'),\n\n\tvar sass= require(\"gulp-sass\");\n\n\tgulp.task('compile-sass',function() {\n\t\t gulp.src('src/sass/*.sass')\n\t\t \n\t\t .pipe(sass())\n\t\t \n\t\t .pipe(gulp.dest('build/css'));\n\n\t});\n\n\tgulp.task('default',['compile-sass']);\n\n#### 6、gulp-imagemin（图片压缩）\n#### 安装：npm install –save-dev  gulp-imagemin\n\n#### 代码如下：\n\n\n\tvar gulp = require('gulp');\n\n\tvar imagemin = require('gulp-imagemin');\n\t\n\tgulp.task('uglify-imagemin',function() {returngulp.src('src/images/*')\n\t\n\t\t.pipe(imagemin())\n\t\n\t\t.pipe(gulp.dest('build/images'));\n\n\t});\n\n\tgulp.task('default',['uglify-imagemin']);\n\n#### 7、理解Browserify\n\nbrowserify是一个使用node支持的CommonJS模块标准 来为浏览器编译模块的，可以解决模块及依赖管理；\n\n#### 先来看看使用gulp常见的问题：\n\n使用 gulp 过程中，偶尔会遇到 Streaming not supported 这样的错误。这通常是因为常规流与 vinyl 文件对象流有差异、\n\ngulp 插件默认使用了只支持 buffer （不支持 stream）的库。比如，不能把 Node 常规流直接传递给 gulp 及其插件。\n\n比如如下代码：会抛出异常的；\n\n\n\tvargulp = require('gulp');\n\n\tvaruglify = require('gulp-uglify');\n\n\tvarconcat = require('gulp-concat');\n\n\tvarrename = require('gulp-rename');varfs = require('fs');\n\n\tgulp.task('bundle',function() {returnfs.createReadStream('./test.txt')\n\t\n\t\t.pipe(uglify())\n\t\t\n\t\t.pipe(rename('bundle.min.js'))\n\t\t\n\t\t.pipe(gulp.dest('dist/'));\n\n\t});\n\n\tgulp.task('default',['bundle']);\n\n文／原创/Dimple（github作者）\n原文链接：https://cuidapao.github.io/\n著作权归作者所有，转载请联系作者获得授权，并标注“github作者”。\n","slug":"gulp-入门教程","published":1,"updated":"2016-11-16T13:23:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civm2xnvu00001rsm9f6su45f","content":"<h1 id=\"gulp入门教程详解\"><a href=\"#gulp入门教程详解\" class=\"headerlink\" title=\"gulp入门教程详解\"></a>gulp入门教程详解</h1><p>最近使用gulp自动化构建工具来开发网站，在此给大家分享一下使用gulp的一些使用教程。</p>\n<h2 id=\"一、-gulp安装\"><a href=\"#一、-gulp安装\" class=\"headerlink\" title=\"一、 gulp安装\"></a>一、 gulp安装</h2><h4 id=\"1、安装nodejs\"><a href=\"#1、安装nodejs\" class=\"headerlink\" title=\"1、安装nodejs\"></a>1、安装nodejs</h4><pre><code>1.1、说明：gulp是基于nodejs，理所当然需要安装nodejs\n\n1.2、安装：打开[&lt;font style=&quot;blue&quot;&gt;nodejs官网&lt;/font&gt;](https://nodejs.org/en/)，点击硕大的绿色Download按钮，它会根据系统信息选择对应版本（.msi文件）。\n</code></pre><h4 id=\"2、全局安装gulp\"><a href=\"#2、全局安装gulp\" class=\"headerlink\" title=\"2、全局安装gulp\"></a>2、全局安装gulp</h4><pre><code>2.1、说明：全局安装gulp目的是为了通过她执行gulp任务；\n\n2.2、安装：命令提示符执行npm install gulp -g；\n\n2.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。\n</code></pre><h4 id=\"3、新建package-json文件\"><a href=\"#3、新建package-json文件\" class=\"headerlink\" title=\"3、新建package.json文件\"></a>3、新建package.json文件</h4><pre><code>3.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；\n\n3.2、执行命令提示符执行npm init进行手动安装\n\n3.3、安装完成后会在当前文件夹下看到如下package.json文件\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/3164024-76d2e9fa62a00632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Mou icon\">       </p>\n<h4 id=\"package-json文件\"><a href=\"#package-json文件\" class=\"headerlink\" title=\"package.json文件\"></a>package.json文件</h4><pre><code> 文件说明：\n\n&quot;name&quot;:&quot;test&quot;,//项目名称（必须）\n\n&quot;version&quot;:&quot;1.0.0&quot;,//项目版本（必须）\n\n&quot;description&quot;:&quot;This is for study gulp project !&quot;,//项目描述（必须）\n\n&quot;devDependencies&quot;:{//项目依赖的插件\n\n 3.4、查看package.json帮助文档，命令提示符执行npm help package.json\n</code></pre><h4 id=\"4、安装本地gulp及其常用插件\"><a href=\"#4、安装本地gulp及其常用插件\" class=\"headerlink\" title=\"4、安装本地gulp及其常用插件\"></a>4、安装本地gulp及其常用插件</h4><pre><code> 4.1、执行命令行npm install gulp 安装本地gulp\n\n4.2、安装gulp插件：以gulp—sass为例\n\n执行命令npm install gulp-sass即可安装gulp-sass插件，安装完成后即可在node_modules文件夹下查看到新安装的插件\n</code></pre><h4 id=\"5、新建gulpfile-js文件（重要）\"><a href=\"#5、新建gulpfile-js文件（重要）\" class=\"headerlink\" title=\"5、新建gulpfile.js文件（重要）\"></a>5、新建gulpfile.js文件（重要）</h4><pre><code> 5.1、说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）\n\n 5.2、gulpfile.js文件用法（以gulp-sass为例）\n\n     5.2.1 导入工具包 require(&apos;node_modules里对应模块&apos;)\n\n         var gulp=require(&apos;gulp&apos;)\n\n         var less=require(&apos;gulp-less&apos;);\n\n     5.2.2 定义一个testLess任务（自定义任务名称）\n\ngulp.task(&apos;testLess&apos;,function(){\n\n    gulp.src(&apos;src/less/index.less&apos;)     //该任务针对的文件\n\n    .pipe(less())      //该任务调用的模块\n\n    .pipe(gulp.dest(&apos;src/css&apos;));     //将会在src/css下生成index.css\n\n});\n\ngulp.task(&quot;default&quot;,[&quot;watch&quot;],function(){ //定义默认任务 并让gulp监视文件变化自动执行\n\ngulp.watch(&quot;sass/*.scss&quot;,[&quot;sass&quot;]);       \n\n})\n</code></pre><h2 id=\"二、gulp常用插件\"><a href=\"#二、gulp常用插件\" class=\"headerlink\" title=\"二、gulp常用插件\"></a>二、gulp常用插件</h2><h4 id=\"1、gulp-uglify-JS压缩\"><a href=\"#1、gulp-uglify-JS压缩\" class=\"headerlink\" title=\"1、gulp-uglify(JS压缩)\"></a>1、gulp-uglify(JS压缩)</h4><h5 id=\"安装：npm-install-–save-dev-gulp-uglify\"><a href=\"#安装：npm-install-–save-dev-gulp-uglify\" class=\"headerlink\" title=\"安装：npm install –save-dev gulp-uglify\"></a>安装：npm install –save-dev gulp-uglify</h5><h4 id=\"gulpfile-js代码如下：\"><a href=\"#gulpfile-js代码如下：\" class=\"headerlink\" title=\"gulpfile.js代码如下：\"></a>gulpfile.js代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nvar rename= require(&apos;gulp-rename&apos;)\n\nvar uglify= require(&quot;gulp-uglify&quot;);\n\ngulp.task(&apos;rename&apos;,function() {\n\n    gulp.src(&apos;src/**/*.js&apos;)\n\n    .pipe(uglify())//压缩\n\n    .pipe(rename(&apos;index.min.js&apos;))    \n\n    .pipe(gulp.dest(&apos;build/js&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;rename&apos;]);\n\nuglify= require(&quot;gulp-uglify&quot;);\n</code></pre><h4 id=\"2、gulp-minify-html（html压缩）\"><a href=\"#2、gulp-minify-html（html压缩）\" class=\"headerlink\" title=\"2、gulp-minify-html（html压缩）\"></a>2、gulp-minify-html（html压缩）</h4><h4 id=\"安装：npm-install-–save-dev-gulp-minify-html\"><a href=\"#安装：npm-install-–save-dev-gulp-minify-html\" class=\"headerlink\" title=\"安装：npm install –save-dev gulp-minify-html\"></a>安装：npm install –save-dev gulp-minify-html</h4><h4 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nvar minifyHtml= require(&quot;gulp-minify-html&quot;);\n\ngulp.task(&apos;minify-html&apos;,function() {\n\n    gulp.src(&apos;src/**/*.html&apos;)//要压缩的html文件\n\n    .pipe(minifyHtml())//压缩\n\n    .pipe(gulp.dest(&apos;build&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;minify-html&apos;]);\n</code></pre><h4 id=\"3、-gulp-concat-js文件合并\"><a href=\"#3、-gulp-concat-js文件合并\" class=\"headerlink\" title=\"3、 gulp-concat (js文件合并)\"></a>3、 gulp-concat (js文件合并)</h4><h4 id=\"安装：npm-install-–save-dev-gulp-concat\"><a href=\"#安装：npm-install-–save-dev-gulp-concat\" class=\"headerlink\" title=\"安装：npm install –save-dev gulp-concat\"></a>安装：npm install –save-dev gulp-concat</h4><h4 id=\"代码如下：-1\"><a href=\"#代码如下：-1\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nconcat= require(&quot;gulp-concat&quot;);\n\ngulp.task(&apos;concat&apos;,function() {\n\n gulp.src(&apos;src/**/*.js&apos;)  //要合并的文件\n\n .pipe(concat(&apos;index.js&apos;))  //合并匹配到的js文件并命名为 &quot;index.js&quot;\n\n .pipe(gulp.dest(&apos;build/js&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;concat&apos;]);\n</code></pre><h4 id=\"4、gulp-jada\"><a href=\"#4、gulp-jada\" class=\"headerlink\" title=\"4、gulp-jada\"></a>4、gulp-jada</h4><h4 id=\"安装：npm-install-–save-dev-gulp-jada\"><a href=\"#安装：npm-install-–save-dev-gulp-jada\" class=\"headerlink\" title=\"安装：npm install –save-dev  gulp-jada\"></a>安装：npm install –save-dev  gulp-jada</h4><h4 id=\"Gulpfile-js代码如下：\"><a href=\"#Gulpfile-js代码如下：\" class=\"headerlink\" title=\"Gulpfile.js代码如下：\"></a>Gulpfile.js代码如下：</h4><pre><code>var gulp= require(&apos;gulp&apos;);\n\nvar jade= require(&apos;gulp-jade&apos;);\n\ngulp.task(&quot;jade&quot;,function(){\n\ngulp.src(&quot;./jade/*.jade&quot;)\n\n    .pipe(jade({\n\n    pretty:true\n\n}))\n\n    .pipe(gulp.dest(&quot;html/&quot;))\n\n})\n\n    gulp.task(&quot;default&quot;,[&quot;watch&quot;],function(){\n\n    gulp.watch(&quot;jade/*.jade&quot;,[&quot;jade&quot;]);\n\n})\n</code></pre><h4 id=\"4、gulp-less\"><a href=\"#4、gulp-less\" class=\"headerlink\" title=\"4、gulp-less\"></a>4、gulp-less</h4><h4 id=\"安装：npm-install-–save-dev-gulp-less\"><a href=\"#安装：npm-install-–save-dev-gulp-less\" class=\"headerlink\" title=\"安装：npm install –save-dev  gulp-less\"></a>安装：npm install –save-dev  gulp-less</h4><h4 id=\"Gulpfile-js代码如下：-1\"><a href=\"#Gulpfile-js代码如下：-1\" class=\"headerlink\" title=\"Gulpfile.js代码如下：\"></a>Gulpfile.js代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nvar less= require(&quot;gulp-less&quot;);\n\ngulp.task(&apos;compile-less&apos;,function() {\n\n  gulp.src(&apos;src/less/*.less&apos;)\n\n  .pipe(less())\n\n  .pipe(gulp.dest(&apos;build/css&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;compile-less&apos;]);\n</code></pre><h4 id=\"5、gulp-sass\"><a href=\"#5、gulp-sass\" class=\"headerlink\" title=\"5、gulp-sass\"></a>5、gulp-sass</h4><h4 id=\"安装：npm-install-–save-dev-gulp-sass\"><a href=\"#安装：npm-install-–save-dev-gulp-sass\" class=\"headerlink\" title=\"安装：npm install –save-dev  gulp-sass\"></a>安装：npm install –save-dev  gulp-sass</h4><h4 id=\"代码如下：-2\"><a href=\"#代码如下：-2\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nvar sass= require(&quot;gulp-sass&quot;);\n\ngulp.task(&apos;compile-sass&apos;,function() {\n     gulp.src(&apos;src/sass/*.sass&apos;)\n\n     .pipe(sass())\n\n     .pipe(gulp.dest(&apos;build/css&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;compile-sass&apos;]);\n</code></pre><h4 id=\"6、gulp-imagemin（图片压缩）\"><a href=\"#6、gulp-imagemin（图片压缩）\" class=\"headerlink\" title=\"6、gulp-imagemin（图片压缩）\"></a>6、gulp-imagemin（图片压缩）</h4><h4 id=\"安装：npm-install-–save-dev-gulp-imagemin\"><a href=\"#安装：npm-install-–save-dev-gulp-imagemin\" class=\"headerlink\" title=\"安装：npm install –save-dev  gulp-imagemin\"></a>安装：npm install –save-dev  gulp-imagemin</h4><h4 id=\"代码如下：-3\"><a href=\"#代码如下：-3\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;);\n\nvar imagemin = require(&apos;gulp-imagemin&apos;);\n\ngulp.task(&apos;uglify-imagemin&apos;,function() {returngulp.src(&apos;src/images/*&apos;)\n\n    .pipe(imagemin())\n\n    .pipe(gulp.dest(&apos;build/images&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;uglify-imagemin&apos;]);\n</code></pre><h4 id=\"7、理解Browserify\"><a href=\"#7、理解Browserify\" class=\"headerlink\" title=\"7、理解Browserify\"></a>7、理解Browserify</h4><p>browserify是一个使用node支持的CommonJS模块标准 来为浏览器编译模块的，可以解决模块及依赖管理；</p>\n<h4 id=\"先来看看使用gulp常见的问题：\"><a href=\"#先来看看使用gulp常见的问题：\" class=\"headerlink\" title=\"先来看看使用gulp常见的问题：\"></a>先来看看使用gulp常见的问题：</h4><p>使用 gulp 过程中，偶尔会遇到 Streaming not supported 这样的错误。这通常是因为常规流与 vinyl 文件对象流有差异、</p>\n<p>gulp 插件默认使用了只支持 buffer （不支持 stream）的库。比如，不能把 Node 常规流直接传递给 gulp 及其插件。</p>\n<p>比如如下代码：会抛出异常的；</p>\n<pre><code>vargulp = require(&apos;gulp&apos;);\n\nvaruglify = require(&apos;gulp-uglify&apos;);\n\nvarconcat = require(&apos;gulp-concat&apos;);\n\nvarrename = require(&apos;gulp-rename&apos;);varfs = require(&apos;fs&apos;);\n\ngulp.task(&apos;bundle&apos;,function() {returnfs.createReadStream(&apos;./test.txt&apos;)\n\n    .pipe(uglify())\n\n    .pipe(rename(&apos;bundle.min.js&apos;))\n\n    .pipe(gulp.dest(&apos;dist/&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;bundle&apos;]);\n</code></pre><p>文／原创/Dimple（github作者）<br>原文链接：<a href=\"https://cuidapao.github.io/\" target=\"_blank\" rel=\"external\">https://cuidapao.github.io/</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“github作者”。</p>\n","excerpt":"","more":"<h1 id=\"gulp入门教程详解\"><a href=\"#gulp入门教程详解\" class=\"headerlink\" title=\"gulp入门教程详解\"></a>gulp入门教程详解</h1><p>最近使用gulp自动化构建工具来开发网站，在此给大家分享一下使用gulp的一些使用教程。</p>\n<h2 id=\"一、-gulp安装\"><a href=\"#一、-gulp安装\" class=\"headerlink\" title=\"一、 gulp安装\"></a>一、 gulp安装</h2><h4 id=\"1、安装nodejs\"><a href=\"#1、安装nodejs\" class=\"headerlink\" title=\"1、安装nodejs\"></a>1、安装nodejs</h4><pre><code>1.1、说明：gulp是基于nodejs，理所当然需要安装nodejs\n\n1.2、安装：打开[&lt;font style=&quot;blue&quot;&gt;nodejs官网&lt;/font&gt;](https://nodejs.org/en/)，点击硕大的绿色Download按钮，它会根据系统信息选择对应版本（.msi文件）。\n</code></pre><h4 id=\"2、全局安装gulp\"><a href=\"#2、全局安装gulp\" class=\"headerlink\" title=\"2、全局安装gulp\"></a>2、全局安装gulp</h4><pre><code>2.1、说明：全局安装gulp目的是为了通过她执行gulp任务；\n\n2.2、安装：命令提示符执行npm install gulp -g；\n\n2.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。\n</code></pre><h4 id=\"3、新建package-json文件\"><a href=\"#3、新建package-json文件\" class=\"headerlink\" title=\"3、新建package.json文件\"></a>3、新建package.json文件</h4><pre><code>3.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；\n\n3.2、执行命令提示符执行npm init进行手动安装\n\n3.3、安装完成后会在当前文件夹下看到如下package.json文件\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/3164024-76d2e9fa62a00632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Mou icon\">       </p>\n<h4 id=\"package-json文件\"><a href=\"#package-json文件\" class=\"headerlink\" title=\"package.json文件\"></a>package.json文件</h4><pre><code> 文件说明：\n\n&quot;name&quot;:&quot;test&quot;,//项目名称（必须）\n\n&quot;version&quot;:&quot;1.0.0&quot;,//项目版本（必须）\n\n&quot;description&quot;:&quot;This is for study gulp project !&quot;,//项目描述（必须）\n\n&quot;devDependencies&quot;:{//项目依赖的插件\n\n 3.4、查看package.json帮助文档，命令提示符执行npm help package.json\n</code></pre><h4 id=\"4、安装本地gulp及其常用插件\"><a href=\"#4、安装本地gulp及其常用插件\" class=\"headerlink\" title=\"4、安装本地gulp及其常用插件\"></a>4、安装本地gulp及其常用插件</h4><pre><code> 4.1、执行命令行npm install gulp 安装本地gulp\n\n4.2、安装gulp插件：以gulp—sass为例\n\n执行命令npm install gulp-sass即可安装gulp-sass插件，安装完成后即可在node_modules文件夹下查看到新安装的插件\n</code></pre><h4 id=\"5、新建gulpfile-js文件（重要）\"><a href=\"#5、新建gulpfile-js文件（重要）\" class=\"headerlink\" title=\"5、新建gulpfile.js文件（重要）\"></a>5、新建gulpfile.js文件（重要）</h4><pre><code> 5.1、说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）\n\n 5.2、gulpfile.js文件用法（以gulp-sass为例）\n\n     5.2.1 导入工具包 require(&apos;node_modules里对应模块&apos;)\n\n         var gulp=require(&apos;gulp&apos;)\n\n         var less=require(&apos;gulp-less&apos;);\n\n     5.2.2 定义一个testLess任务（自定义任务名称）\n\ngulp.task(&apos;testLess&apos;,function(){\n\n    gulp.src(&apos;src/less/index.less&apos;)     //该任务针对的文件\n\n    .pipe(less())      //该任务调用的模块\n\n    .pipe(gulp.dest(&apos;src/css&apos;));     //将会在src/css下生成index.css\n\n});\n\ngulp.task(&quot;default&quot;,[&quot;watch&quot;],function(){ //定义默认任务 并让gulp监视文件变化自动执行\n\ngulp.watch(&quot;sass/*.scss&quot;,[&quot;sass&quot;]);       \n\n})\n</code></pre><h2 id=\"二、gulp常用插件\"><a href=\"#二、gulp常用插件\" class=\"headerlink\" title=\"二、gulp常用插件\"></a>二、gulp常用插件</h2><h4 id=\"1、gulp-uglify-JS压缩\"><a href=\"#1、gulp-uglify-JS压缩\" class=\"headerlink\" title=\"1、gulp-uglify(JS压缩)\"></a>1、gulp-uglify(JS压缩)</h4><h5 id=\"安装：npm-install-–save-dev-gulp-uglify\"><a href=\"#安装：npm-install-–save-dev-gulp-uglify\" class=\"headerlink\" title=\"安装：npm install –save-dev gulp-uglify\"></a>安装：npm install –save-dev gulp-uglify</h5><h4 id=\"gulpfile-js代码如下：\"><a href=\"#gulpfile-js代码如下：\" class=\"headerlink\" title=\"gulpfile.js代码如下：\"></a>gulpfile.js代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nvar rename= require(&apos;gulp-rename&apos;)\n\nvar uglify= require(&quot;gulp-uglify&quot;);\n\ngulp.task(&apos;rename&apos;,function() {\n\n    gulp.src(&apos;src/**/*.js&apos;)\n\n    .pipe(uglify())//压缩\n\n    .pipe(rename(&apos;index.min.js&apos;))    \n\n    .pipe(gulp.dest(&apos;build/js&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;rename&apos;]);\n\nuglify= require(&quot;gulp-uglify&quot;);\n</code></pre><h4 id=\"2、gulp-minify-html（html压缩）\"><a href=\"#2、gulp-minify-html（html压缩）\" class=\"headerlink\" title=\"2、gulp-minify-html（html压缩）\"></a>2、gulp-minify-html（html压缩）</h4><h4 id=\"安装：npm-install-–save-dev-gulp-minify-html\"><a href=\"#安装：npm-install-–save-dev-gulp-minify-html\" class=\"headerlink\" title=\"安装：npm install –save-dev gulp-minify-html\"></a>安装：npm install –save-dev gulp-minify-html</h4><h4 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nvar minifyHtml= require(&quot;gulp-minify-html&quot;);\n\ngulp.task(&apos;minify-html&apos;,function() {\n\n    gulp.src(&apos;src/**/*.html&apos;)//要压缩的html文件\n\n    .pipe(minifyHtml())//压缩\n\n    .pipe(gulp.dest(&apos;build&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;minify-html&apos;]);\n</code></pre><h4 id=\"3、-gulp-concat-js文件合并\"><a href=\"#3、-gulp-concat-js文件合并\" class=\"headerlink\" title=\"3、 gulp-concat (js文件合并)\"></a>3、 gulp-concat (js文件合并)</h4><h4 id=\"安装：npm-install-–save-dev-gulp-concat\"><a href=\"#安装：npm-install-–save-dev-gulp-concat\" class=\"headerlink\" title=\"安装：npm install –save-dev gulp-concat\"></a>安装：npm install –save-dev gulp-concat</h4><h4 id=\"代码如下：-1\"><a href=\"#代码如下：-1\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nconcat= require(&quot;gulp-concat&quot;);\n\ngulp.task(&apos;concat&apos;,function() {\n\n gulp.src(&apos;src/**/*.js&apos;)  //要合并的文件\n\n .pipe(concat(&apos;index.js&apos;))  //合并匹配到的js文件并命名为 &quot;index.js&quot;\n\n .pipe(gulp.dest(&apos;build/js&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;concat&apos;]);\n</code></pre><h4 id=\"4、gulp-jada\"><a href=\"#4、gulp-jada\" class=\"headerlink\" title=\"4、gulp-jada\"></a>4、gulp-jada</h4><h4 id=\"安装：npm-install-–save-dev-gulp-jada\"><a href=\"#安装：npm-install-–save-dev-gulp-jada\" class=\"headerlink\" title=\"安装：npm install –save-dev  gulp-jada\"></a>安装：npm install –save-dev  gulp-jada</h4><h4 id=\"Gulpfile-js代码如下：\"><a href=\"#Gulpfile-js代码如下：\" class=\"headerlink\" title=\"Gulpfile.js代码如下：\"></a>Gulpfile.js代码如下：</h4><pre><code>var gulp= require(&apos;gulp&apos;);\n\nvar jade= require(&apos;gulp-jade&apos;);\n\ngulp.task(&quot;jade&quot;,function(){\n\ngulp.src(&quot;./jade/*.jade&quot;)\n\n    .pipe(jade({\n\n    pretty:true\n\n}))\n\n    .pipe(gulp.dest(&quot;html/&quot;))\n\n})\n\n    gulp.task(&quot;default&quot;,[&quot;watch&quot;],function(){\n\n    gulp.watch(&quot;jade/*.jade&quot;,[&quot;jade&quot;]);\n\n})\n</code></pre><h4 id=\"4、gulp-less\"><a href=\"#4、gulp-less\" class=\"headerlink\" title=\"4、gulp-less\"></a>4、gulp-less</h4><h4 id=\"安装：npm-install-–save-dev-gulp-less\"><a href=\"#安装：npm-install-–save-dev-gulp-less\" class=\"headerlink\" title=\"安装：npm install –save-dev  gulp-less\"></a>安装：npm install –save-dev  gulp-less</h4><h4 id=\"Gulpfile-js代码如下：-1\"><a href=\"#Gulpfile-js代码如下：-1\" class=\"headerlink\" title=\"Gulpfile.js代码如下：\"></a>Gulpfile.js代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nvar less= require(&quot;gulp-less&quot;);\n\ngulp.task(&apos;compile-less&apos;,function() {\n\n  gulp.src(&apos;src/less/*.less&apos;)\n\n  .pipe(less())\n\n  .pipe(gulp.dest(&apos;build/css&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;compile-less&apos;]);\n</code></pre><h4 id=\"5、gulp-sass\"><a href=\"#5、gulp-sass\" class=\"headerlink\" title=\"5、gulp-sass\"></a>5、gulp-sass</h4><h4 id=\"安装：npm-install-–save-dev-gulp-sass\"><a href=\"#安装：npm-install-–save-dev-gulp-sass\" class=\"headerlink\" title=\"安装：npm install –save-dev  gulp-sass\"></a>安装：npm install –save-dev  gulp-sass</h4><h4 id=\"代码如下：-2\"><a href=\"#代码如下：-2\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;),\n\nvar sass= require(&quot;gulp-sass&quot;);\n\ngulp.task(&apos;compile-sass&apos;,function() {\n     gulp.src(&apos;src/sass/*.sass&apos;)\n\n     .pipe(sass())\n\n     .pipe(gulp.dest(&apos;build/css&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;compile-sass&apos;]);\n</code></pre><h4 id=\"6、gulp-imagemin（图片压缩）\"><a href=\"#6、gulp-imagemin（图片压缩）\" class=\"headerlink\" title=\"6、gulp-imagemin（图片压缩）\"></a>6、gulp-imagemin（图片压缩）</h4><h4 id=\"安装：npm-install-–save-dev-gulp-imagemin\"><a href=\"#安装：npm-install-–save-dev-gulp-imagemin\" class=\"headerlink\" title=\"安装：npm install –save-dev  gulp-imagemin\"></a>安装：npm install –save-dev  gulp-imagemin</h4><h4 id=\"代码如下：-3\"><a href=\"#代码如下：-3\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h4><pre><code>var gulp = require(&apos;gulp&apos;);\n\nvar imagemin = require(&apos;gulp-imagemin&apos;);\n\ngulp.task(&apos;uglify-imagemin&apos;,function() {returngulp.src(&apos;src/images/*&apos;)\n\n    .pipe(imagemin())\n\n    .pipe(gulp.dest(&apos;build/images&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;uglify-imagemin&apos;]);\n</code></pre><h4 id=\"7、理解Browserify\"><a href=\"#7、理解Browserify\" class=\"headerlink\" title=\"7、理解Browserify\"></a>7、理解Browserify</h4><p>browserify是一个使用node支持的CommonJS模块标准 来为浏览器编译模块的，可以解决模块及依赖管理；</p>\n<h4 id=\"先来看看使用gulp常见的问题：\"><a href=\"#先来看看使用gulp常见的问题：\" class=\"headerlink\" title=\"先来看看使用gulp常见的问题：\"></a>先来看看使用gulp常见的问题：</h4><p>使用 gulp 过程中，偶尔会遇到 Streaming not supported 这样的错误。这通常是因为常规流与 vinyl 文件对象流有差异、</p>\n<p>gulp 插件默认使用了只支持 buffer （不支持 stream）的库。比如，不能把 Node 常规流直接传递给 gulp 及其插件。</p>\n<p>比如如下代码：会抛出异常的；</p>\n<pre><code>vargulp = require(&apos;gulp&apos;);\n\nvaruglify = require(&apos;gulp-uglify&apos;);\n\nvarconcat = require(&apos;gulp-concat&apos;);\n\nvarrename = require(&apos;gulp-rename&apos;);varfs = require(&apos;fs&apos;);\n\ngulp.task(&apos;bundle&apos;,function() {returnfs.createReadStream(&apos;./test.txt&apos;)\n\n    .pipe(uglify())\n\n    .pipe(rename(&apos;bundle.min.js&apos;))\n\n    .pipe(gulp.dest(&apos;dist/&apos;));\n\n});\n\ngulp.task(&apos;default&apos;,[&apos;bundle&apos;]);\n</code></pre><p>文／原创/Dimple（github作者）<br>原文链接：<a href=\"https://cuidapao.github.io/\">https://cuidapao.github.io/</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“github作者”。</p>\n"},{"title":"hexo","date":"2016-03-16T06:09:54.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: hexo\ndate: 2016-3-16 14:09:54\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2016-11-16T09:37:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civm2xnvz00011rsmr60md5jq","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"7种创建对象方法","date":"2016-07-25T06:09:54.000Z","_content":"\n\n# 7种对象的创建方法\n\n\n#### 最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：\n\n* 工厂模式\n* 构造函数模式\n* 原型模式\n* 构造函数和原型组合模式\n* 动态原型模式\n* 寄生构造模式\n* 稳妥构造模式\n\n#### 首先先解释几个概念\n\n1、 对象下面例子中所有的Person函数\n\n2、 实例/对象实例 通过 `new Person()` or \t`Person()`返回的对象，如`var person1 = new Person()`中的person1\n\n3、 原型对象`Person.prototype` \n\n\n\n### <font style=\"color:orange\">工厂模式</font>\n\n\tfunction Person() {\n \t  var o = new Object();\n  \t  o.name = 'hanmeimei';\n  \t  o.say = function() {\n    \talert(this.name);\n     }\n  \t  return o;\n\t }\n\t var person1 = Person();\n\t \n\n\n#### <font style=\"color:red\">优点：</font>\n1. 完成了返回一个对象的要求。\n\n\n#### <font style=\"color:red\">缺点：</font>\n\n1. 无法通过constructor识别对象，以为都是来自Object，无法得知来自Person\n\n2. 每次通过Person创建对象的时候，所有的say方法都是一样的，但是却存储了多次，浪费资源。\n\n\n### <font style=\"color:orange\">构造函数模式</font>\n\n\tfunction Person() {\n  \t\tthis.name = 'hanmeimei';\n  \t\tthis.say = function() {\n    \t\talert(this.name)\n  \t\t}\n\t  }\n\tvar person1 = new Person();\n\t \n\n#### <font style=\"color:red\">优点：</font>\n1. 通过constructor或者instanceof可以识别对象实例的类别\n2. 可以通过new 关键字来创建对象实例，更像OO语言中创建对象实例\n\n#### <font style=\"color:red\">缺点：</font>\n\n1. 多个实例的say方法都是实现一样的效果，但是却存储了很多次（两个对象实例的say方法是不同的，因为存放的地址不同）\n\n\n### <font style=\"color:red\">注意：</font>\n\n\n1. 构造函数模式隐试的在最后返回`return this` 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象。\n2. 也可以根据`return this` 的特性调用call或者apply指定this。这一点在后面的继承有很大帮助。\n\n### <font style=\"color:orange\">原型模式</font>\n\n\tfunction Person() {}\n\tPerson.prototype.name = 'hanmeimei';\n\tPerson.prototype.say = function() {\n \t\talert(this.name);\n\t}\n\tPerson.prototype.friends = ['lilei'];\n\tvar person1 = new Person();\n\t\n#### <font style=\"color:red\">优点：</font>\n\n1. say方法是共享的了，所有的实例的say方法都指向同一个。\n\n2. 可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。\n\n---\n\n\n\tvar person1 = new Person()\n\tPerson.prototype.showFriends = function() {\n  \t\tconsole.log(this.friends)\n\t}\n\tperson1.showFriends()  //['lilei']\n\n#### <font style=\"color:red\">缺点：</font>\t\n\n##### 出现引用的情况下会出现问题具体见下面代码：\n\n\tvar person1 = new Person();\n\tvar person2 = new Person();\n\tperson1.friends.push('xiaoming');\n\tconsole.log(person2.friends)  //['lilei', 'xiaoming']\n\t\n##### 因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。\n\n\n2. 第一次调用say方法或者name属性的时候会搜索两次，第一次是在实例上寻找say方法，没有找到就去原型对象(Person.prototype)上找say方法，找到后就会在实力上添加这些方法or属性。\t\n\n\n3. 所有的方法都是共享的，没有办法创建实例自己的属性和方法，也没有办法像构造函数那样传递参数。\n\n\n### <font style=\"color:red\">注意：</font>\n\n优点②中存在一个问题就是直接通过对象字面量给`Person.prototype`进行赋值的时候会导致`constructor`改变，所以需要手动设置，其次就是通过对象字面量给`Person.prototype`进行赋值，会无法作用在之前创建的对象实例上\n\n\tvar person1 = new Person()\n\tPerson.prototype = {\n\t\t\tname: 'hanmeimei2',\n  \t\t\tsetName: function(name){\n      \t\tthis.name = name\n  \t\t}\n\t}\n\tperson1.setName()   //Uncaught TypeError: person1.set \tis not a \tfunction(…)\n\t\n\n\n这是因为对象实例和对象原型直接是通过一个指针链接的，这个指针是一个内部属性[[Prototype]]，可以通过`__proto__`访问。我们通过对象字面量修改了Person.prototype指向的地址，然而对象实例的`__proto__`，并没有跟着一起更新，所以这就导致，实例还访问着原来的`Person.prototype`，所以建议不要通过这种方式去改变`Person.prototype`属性\n\n\n### <font style=\"color:orange\">构造函数和原型组合模式</font>\n\n\n\tfunction Person(name) {\n  \t\tthis.name = name\n  \t\tthis.friends = ['lilei']\n\t}\n\tPerson.prototype.say = function() {\n  \t\tconsole.log(this.name)\n\t}\n\tvar person1 = new Person('hanmeimei')\n\tperson1.say() //hanmeimei\n\n#### <font style=\"color:red\">优点：</font>\n\n1. 解决了原型模式对于引用对象的缺点\n2. 解决了原型模式没有办法传递参数的缺点\n3. 解决了构造函数模式不能共享方法的缺点\n\n\n#### <font style=\"color:red\">缺点：</font>\n\n\n1. 和原型模式中注意①一样 （可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。针对这个问题中存在一个问题就是直接通过对象字面量给Person.prototype进行赋值的时候会导致constructor改变，所以需要手动设置，其次就是通过对象字面量给Person.prototype进行赋值，会无法作用在之前创建的对象实例上）\n\n### <font style=\"color:orange\">动态原型模式</font>\n\n\tfunction Person(name) {\n \t\t this.name = name\n  \t\t if(typeof this.say != 'function') {\n    \t\tPerson.prototype.say = function(\n    \t\talert(this.name)\n  \t\t}\n\t}\n\n#### <font style=\"color:red\">优点：</font>\t\n\n1. 可以在初次调用构造函数的时候就完成原型对象的修改\n2. 修改能体现在所有的实例中\n\n\n#### <font style=\"color:red\">缺点：</font>\n\n##### 红宝书都说这个方案完美了。。。。\n\n### <font style=\"color:orange\">寄生构造函数模式</font>\n\n\tfunction Person(name) {\n  \t\tvar o = new Object()\n \t\to.name = name\n \t\to.say = function() {\n    \t\talert(this.name)\n \t\t }\n  \t\t\treturn o\n\t\t}\n\tvar peron1 = new Person('hanmeimei')\n\t\n#### <font style=\"color:red\">优点：</font>\t\n\n##### 和工厂模式基本一样，除了多了个new操作符\n\n#### <font style=\"color:red\">缺点：</font>\n\n##### 和工厂模式一样，不能区分实例的类别\n\n\n### <font style=\"color:orange\">稳妥构造模式</font>\n\t\n\tfunction Person(name) {\n \t\tvar o = new Object()\n  \t\to.say = function() {\n    \talert(name)\n  \t }\n\t}\n\tvar person1 = new Person('hanmeimei');\n\tperson1.name  // undefined\n\tperson1.say() //hanmeimei\n\t\n#### <font style=\"color:red\">优点：</font>\n\n安全，name好像成为了私有变量，只能通过say方法去访问\n\n\n#### <font style=\"color:red\">缺点：</font>\n\n##### 不能区分实例的类别\n\t\n🔗原文链接: [http://alvinyuxt.github.io/2016/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/) by @alvinyuxt","source":"_posts/hanshu.md","raw":"---\ntitle: 7种创建对象方法\ndate: 2016-7-25 14:09:54\ntags: [javascript,7种创建对象的方法]\n---\n\n\n# 7种对象的创建方法\n\n\n#### 最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：\n\n* 工厂模式\n* 构造函数模式\n* 原型模式\n* 构造函数和原型组合模式\n* 动态原型模式\n* 寄生构造模式\n* 稳妥构造模式\n\n#### 首先先解释几个概念\n\n1、 对象下面例子中所有的Person函数\n\n2、 实例/对象实例 通过 `new Person()` or \t`Person()`返回的对象，如`var person1 = new Person()`中的person1\n\n3、 原型对象`Person.prototype` \n\n\n\n### <font style=\"color:orange\">工厂模式</font>\n\n\tfunction Person() {\n \t  var o = new Object();\n  \t  o.name = 'hanmeimei';\n  \t  o.say = function() {\n    \talert(this.name);\n     }\n  \t  return o;\n\t }\n\t var person1 = Person();\n\t \n\n\n#### <font style=\"color:red\">优点：</font>\n1. 完成了返回一个对象的要求。\n\n\n#### <font style=\"color:red\">缺点：</font>\n\n1. 无法通过constructor识别对象，以为都是来自Object，无法得知来自Person\n\n2. 每次通过Person创建对象的时候，所有的say方法都是一样的，但是却存储了多次，浪费资源。\n\n\n### <font style=\"color:orange\">构造函数模式</font>\n\n\tfunction Person() {\n  \t\tthis.name = 'hanmeimei';\n  \t\tthis.say = function() {\n    \t\talert(this.name)\n  \t\t}\n\t  }\n\tvar person1 = new Person();\n\t \n\n#### <font style=\"color:red\">优点：</font>\n1. 通过constructor或者instanceof可以识别对象实例的类别\n2. 可以通过new 关键字来创建对象实例，更像OO语言中创建对象实例\n\n#### <font style=\"color:red\">缺点：</font>\n\n1. 多个实例的say方法都是实现一样的效果，但是却存储了很多次（两个对象实例的say方法是不同的，因为存放的地址不同）\n\n\n### <font style=\"color:red\">注意：</font>\n\n\n1. 构造函数模式隐试的在最后返回`return this` 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象。\n2. 也可以根据`return this` 的特性调用call或者apply指定this。这一点在后面的继承有很大帮助。\n\n### <font style=\"color:orange\">原型模式</font>\n\n\tfunction Person() {}\n\tPerson.prototype.name = 'hanmeimei';\n\tPerson.prototype.say = function() {\n \t\talert(this.name);\n\t}\n\tPerson.prototype.friends = ['lilei'];\n\tvar person1 = new Person();\n\t\n#### <font style=\"color:red\">优点：</font>\n\n1. say方法是共享的了，所有的实例的say方法都指向同一个。\n\n2. 可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。\n\n---\n\n\n\tvar person1 = new Person()\n\tPerson.prototype.showFriends = function() {\n  \t\tconsole.log(this.friends)\n\t}\n\tperson1.showFriends()  //['lilei']\n\n#### <font style=\"color:red\">缺点：</font>\t\n\n##### 出现引用的情况下会出现问题具体见下面代码：\n\n\tvar person1 = new Person();\n\tvar person2 = new Person();\n\tperson1.friends.push('xiaoming');\n\tconsole.log(person2.friends)  //['lilei', 'xiaoming']\n\t\n##### 因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。\n\n\n2. 第一次调用say方法或者name属性的时候会搜索两次，第一次是在实例上寻找say方法，没有找到就去原型对象(Person.prototype)上找say方法，找到后就会在实力上添加这些方法or属性。\t\n\n\n3. 所有的方法都是共享的，没有办法创建实例自己的属性和方法，也没有办法像构造函数那样传递参数。\n\n\n### <font style=\"color:red\">注意：</font>\n\n优点②中存在一个问题就是直接通过对象字面量给`Person.prototype`进行赋值的时候会导致`constructor`改变，所以需要手动设置，其次就是通过对象字面量给`Person.prototype`进行赋值，会无法作用在之前创建的对象实例上\n\n\tvar person1 = new Person()\n\tPerson.prototype = {\n\t\t\tname: 'hanmeimei2',\n  \t\t\tsetName: function(name){\n      \t\tthis.name = name\n  \t\t}\n\t}\n\tperson1.setName()   //Uncaught TypeError: person1.set \tis not a \tfunction(…)\n\t\n\n\n这是因为对象实例和对象原型直接是通过一个指针链接的，这个指针是一个内部属性[[Prototype]]，可以通过`__proto__`访问。我们通过对象字面量修改了Person.prototype指向的地址，然而对象实例的`__proto__`，并没有跟着一起更新，所以这就导致，实例还访问着原来的`Person.prototype`，所以建议不要通过这种方式去改变`Person.prototype`属性\n\n\n### <font style=\"color:orange\">构造函数和原型组合模式</font>\n\n\n\tfunction Person(name) {\n  \t\tthis.name = name\n  \t\tthis.friends = ['lilei']\n\t}\n\tPerson.prototype.say = function() {\n  \t\tconsole.log(this.name)\n\t}\n\tvar person1 = new Person('hanmeimei')\n\tperson1.say() //hanmeimei\n\n#### <font style=\"color:red\">优点：</font>\n\n1. 解决了原型模式对于引用对象的缺点\n2. 解决了原型模式没有办法传递参数的缺点\n3. 解决了构造函数模式不能共享方法的缺点\n\n\n#### <font style=\"color:red\">缺点：</font>\n\n\n1. 和原型模式中注意①一样 （可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。针对这个问题中存在一个问题就是直接通过对象字面量给Person.prototype进行赋值的时候会导致constructor改变，所以需要手动设置，其次就是通过对象字面量给Person.prototype进行赋值，会无法作用在之前创建的对象实例上）\n\n### <font style=\"color:orange\">动态原型模式</font>\n\n\tfunction Person(name) {\n \t\t this.name = name\n  \t\t if(typeof this.say != 'function') {\n    \t\tPerson.prototype.say = function(\n    \t\talert(this.name)\n  \t\t}\n\t}\n\n#### <font style=\"color:red\">优点：</font>\t\n\n1. 可以在初次调用构造函数的时候就完成原型对象的修改\n2. 修改能体现在所有的实例中\n\n\n#### <font style=\"color:red\">缺点：</font>\n\n##### 红宝书都说这个方案完美了。。。。\n\n### <font style=\"color:orange\">寄生构造函数模式</font>\n\n\tfunction Person(name) {\n  \t\tvar o = new Object()\n \t\to.name = name\n \t\to.say = function() {\n    \t\talert(this.name)\n \t\t }\n  \t\t\treturn o\n\t\t}\n\tvar peron1 = new Person('hanmeimei')\n\t\n#### <font style=\"color:red\">优点：</font>\t\n\n##### 和工厂模式基本一样，除了多了个new操作符\n\n#### <font style=\"color:red\">缺点：</font>\n\n##### 和工厂模式一样，不能区分实例的类别\n\n\n### <font style=\"color:orange\">稳妥构造模式</font>\n\t\n\tfunction Person(name) {\n \t\tvar o = new Object()\n  \t\to.say = function() {\n    \talert(name)\n  \t }\n\t}\n\tvar person1 = new Person('hanmeimei');\n\tperson1.name  // undefined\n\tperson1.say() //hanmeimei\n\t\n#### <font style=\"color:red\">优点：</font>\n\n安全，name好像成为了私有变量，只能通过say方法去访问\n\n\n#### <font style=\"color:red\">缺点：</font>\n\n##### 不能区分实例的类别\n\t\n🔗原文链接: [http://alvinyuxt.github.io/2016/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/) by @alvinyuxt","slug":"hanshu","published":1,"updated":"2016-11-16T09:40:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civm2xnw500031rsme4zaydi6","content":"<h1 id=\"7种对象的创建方法\"><a href=\"#7种对象的创建方法\" class=\"headerlink\" title=\"7种对象的创建方法\"></a>7种对象的创建方法</h1><h4 id=\"最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：\"><a href=\"#最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：\" class=\"headerlink\" title=\"最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：\"></a>最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：</h4><ul>\n<li>工厂模式</li>\n<li>构造函数模式</li>\n<li>原型模式</li>\n<li>构造函数和原型组合模式</li>\n<li>动态原型模式</li>\n<li>寄生构造模式</li>\n<li>稳妥构造模式</li>\n</ul>\n<h4 id=\"首先先解释几个概念\"><a href=\"#首先先解释几个概念\" class=\"headerlink\" title=\"首先先解释几个概念\"></a>首先先解释几个概念</h4><p>1、 对象下面例子中所有的Person函数</p>\n<p>2、 实例/对象实例 通过 <code>new Person()</code> or     <code>Person()</code>返回的对象，如<code>var person1 = new Person()</code>中的person1</p>\n<p>3、 原型对象<code>Person.prototype</code> </p>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a><font style=\"color:orange\">工厂模式</font></h3><pre><code>function Person() {\n   var o = new Object();\n    o.name = &apos;hanmeimei&apos;;\n    o.say = function() {\n    alert(this.name);\n }\n    return o;\n }\n var person1 = Person();\n</code></pre><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li>完成了返回一个对象的要求。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><ol>\n<li><p>无法通过constructor识别对象，以为都是来自Object，无法得知来自Person</p>\n</li>\n<li><p>每次通过Person创建对象的时候，所有的say方法都是一样的，但是却存储了多次，浪费资源。</p>\n</li>\n</ol>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a><font style=\"color:orange\">构造函数模式</font></h3><pre><code>function Person() {\n      this.name = &apos;hanmeimei&apos;;\n      this.say = function() {\n        alert(this.name)\n      }\n  }\nvar person1 = new Person();\n</code></pre><h4 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li>通过constructor或者instanceof可以识别对象实例的类别</li>\n<li>可以通过new 关键字来创建对象实例，更像OO语言中创建对象实例</li>\n</ol>\n<h4 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><ol>\n<li>多个实例的say方法都是实现一样的效果，但是却存储了很多次（两个对象实例的say方法是不同的，因为存放的地址不同）</li>\n</ol>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a><font style=\"color:red\">注意：</font></h3><ol>\n<li>构造函数模式隐试的在最后返回<code>return this</code> 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象。</li>\n<li>也可以根据<code>return this</code> 的特性调用call或者apply指定this。这一点在后面的继承有很大帮助。</li>\n</ol>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a><font style=\"color:orange\">原型模式</font></h3><pre><code>function Person() {}\nPerson.prototype.name = &apos;hanmeimei&apos;;\nPerson.prototype.say = function() {\n     alert(this.name);\n}\nPerson.prototype.friends = [&apos;lilei&apos;];\nvar person1 = new Person();\n</code></pre><h4 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li><p>say方法是共享的了，所有的实例的say方法都指向同一个。</p>\n</li>\n<li><p>可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。</p>\n</li>\n</ol>\n<hr>\n<pre><code>var person1 = new Person()\nPerson.prototype.showFriends = function() {\n      console.log(this.friends)\n}\nperson1.showFriends()  //[&apos;lilei&apos;]\n</code></pre><h4 id=\"缺点：-2\"><a href=\"#缺点：-2\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><h5 id=\"出现引用的情况下会出现问题具体见下面代码：\"><a href=\"#出现引用的情况下会出现问题具体见下面代码：\" class=\"headerlink\" title=\"出现引用的情况下会出现问题具体见下面代码：\"></a>出现引用的情况下会出现问题具体见下面代码：</h5><pre><code>var person1 = new Person();\nvar person2 = new Person();\nperson1.friends.push(&apos;xiaoming&apos;);\nconsole.log(person2.friends)  //[&apos;lilei&apos;, &apos;xiaoming&apos;]\n</code></pre><h5 id=\"因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。\"><a href=\"#因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。\" class=\"headerlink\" title=\"因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。\"></a>因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。</h5><ol>\n<li>第一次调用say方法或者name属性的时候会搜索两次，第一次是在实例上寻找say方法，没有找到就去原型对象(Person.prototype)上找say方法，找到后就会在实力上添加这些方法or属性。    </li>\n</ol>\n<ol>\n<li>所有的方法都是共享的，没有办法创建实例自己的属性和方法，也没有办法像构造函数那样传递参数。</li>\n</ol>\n<h3 id=\"注意：-1\"><a href=\"#注意：-1\" class=\"headerlink\" title=\"注意：\"></a><font style=\"color:red\">注意：</font></h3><p>优点②中存在一个问题就是直接通过对象字面量给<code>Person.prototype</code>进行赋值的时候会导致<code>constructor</code>改变，所以需要手动设置，其次就是通过对象字面量给<code>Person.prototype</code>进行赋值，会无法作用在之前创建的对象实例上</p>\n<pre><code>var person1 = new Person()\nPerson.prototype = {\n        name: &apos;hanmeimei2&apos;,\n          setName: function(name){\n          this.name = name\n      }\n}\nperson1.setName()   //Uncaught TypeError: person1.set     is not a     function(…)\n</code></pre><p>这是因为对象实例和对象原型直接是通过一个指针链接的，这个指针是一个内部属性[[Prototype]]，可以通过<code>__proto__</code>访问。我们通过对象字面量修改了Person.prototype指向的地址，然而对象实例的<code>__proto__</code>，并没有跟着一起更新，所以这就导致，实例还访问着原来的<code>Person.prototype</code>，所以建议不要通过这种方式去改变<code>Person.prototype</code>属性</p>\n<h3 id=\"构造函数和原型组合模式\"><a href=\"#构造函数和原型组合模式\" class=\"headerlink\" title=\"构造函数和原型组合模式\"></a><font style=\"color:orange\">构造函数和原型组合模式</font></h3><pre><code>function Person(name) {\n      this.name = name\n      this.friends = [&apos;lilei&apos;]\n}\nPerson.prototype.say = function() {\n      console.log(this.name)\n}\nvar person1 = new Person(&apos;hanmeimei&apos;)\nperson1.say() //hanmeimei\n</code></pre><h4 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li>解决了原型模式对于引用对象的缺点</li>\n<li>解决了原型模式没有办法传递参数的缺点</li>\n<li>解决了构造函数模式不能共享方法的缺点</li>\n</ol>\n<h4 id=\"缺点：-3\"><a href=\"#缺点：-3\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><ol>\n<li>和原型模式中注意①一样 （可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。针对这个问题中存在一个问题就是直接通过对象字面量给Person.prototype进行赋值的时候会导致constructor改变，所以需要手动设置，其次就是通过对象字面量给Person.prototype进行赋值，会无法作用在之前创建的对象实例上）</li>\n</ol>\n<h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a><font style=\"color:orange\">动态原型模式</font></h3><pre><code>function Person(name) {\n      this.name = name\n       if(typeof this.say != &apos;function&apos;) {\n        Person.prototype.say = function(\n        alert(this.name)\n      }\n}\n</code></pre><h4 id=\"优点：-4\"><a href=\"#优点：-4\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li>可以在初次调用构造函数的时候就完成原型对象的修改</li>\n<li>修改能体现在所有的实例中</li>\n</ol>\n<h4 id=\"缺点：-4\"><a href=\"#缺点：-4\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><h5 id=\"红宝书都说这个方案完美了。。。。\"><a href=\"#红宝书都说这个方案完美了。。。。\" class=\"headerlink\" title=\"红宝书都说这个方案完美了。。。。\"></a>红宝书都说这个方案完美了。。。。</h5><h3 id=\"寄生构造函数模式\"><a href=\"#寄生构造函数模式\" class=\"headerlink\" title=\"寄生构造函数模式\"></a><font style=\"color:orange\">寄生构造函数模式</font></h3><pre><code>function Person(name) {\n      var o = new Object()\n     o.name = name\n     o.say = function() {\n        alert(this.name)\n      }\n          return o\n    }\nvar peron1 = new Person(&apos;hanmeimei&apos;)\n</code></pre><h4 id=\"优点：-5\"><a href=\"#优点：-5\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><h5 id=\"和工厂模式基本一样，除了多了个new操作符\"><a href=\"#和工厂模式基本一样，除了多了个new操作符\" class=\"headerlink\" title=\"和工厂模式基本一样，除了多了个new操作符\"></a>和工厂模式基本一样，除了多了个new操作符</h5><h4 id=\"缺点：-5\"><a href=\"#缺点：-5\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><h5 id=\"和工厂模式一样，不能区分实例的类别\"><a href=\"#和工厂模式一样，不能区分实例的类别\" class=\"headerlink\" title=\"和工厂模式一样，不能区分实例的类别\"></a>和工厂模式一样，不能区分实例的类别</h5><h3 id=\"稳妥构造模式\"><a href=\"#稳妥构造模式\" class=\"headerlink\" title=\"稳妥构造模式\"></a><font style=\"color:orange\">稳妥构造模式</font></h3><pre><code>function Person(name) {\n     var o = new Object()\n      o.say = function() {\n    alert(name)\n   }\n}\nvar person1 = new Person(&apos;hanmeimei&apos;);\nperson1.name  // undefined\nperson1.say() //hanmeimei\n</code></pre><h4 id=\"优点：-6\"><a href=\"#优点：-6\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><p>安全，name好像成为了私有变量，只能通过say方法去访问</p>\n<h4 id=\"缺点：-6\"><a href=\"#缺点：-6\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><h5 id=\"不能区分实例的类别\"><a href=\"#不能区分实例的类别\" class=\"headerlink\" title=\"不能区分实例的类别\"></a>不能区分实例的类别</h5><p>🔗原文链接: [<a href=\"http://alvinyuxt.github.io/2016/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"external\">http://alvinyuxt.github.io/2016/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</a>) by @alvinyuxt</p>\n","excerpt":"","more":"<h1 id=\"7种对象的创建方法\"><a href=\"#7种对象的创建方法\" class=\"headerlink\" title=\"7种对象的创建方法\"></a>7种对象的创建方法</h1><h4 id=\"最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：\"><a href=\"#最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：\" class=\"headerlink\" title=\"最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：\"></a>最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：</h4><ul>\n<li>工厂模式</li>\n<li>构造函数模式</li>\n<li>原型模式</li>\n<li>构造函数和原型组合模式</li>\n<li>动态原型模式</li>\n<li>寄生构造模式</li>\n<li>稳妥构造模式</li>\n</ul>\n<h4 id=\"首先先解释几个概念\"><a href=\"#首先先解释几个概念\" class=\"headerlink\" title=\"首先先解释几个概念\"></a>首先先解释几个概念</h4><p>1、 对象下面例子中所有的Person函数</p>\n<p>2、 实例/对象实例 通过 <code>new Person()</code> or     <code>Person()</code>返回的对象，如<code>var person1 = new Person()</code>中的person1</p>\n<p>3、 原型对象<code>Person.prototype</code> </p>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a><font style=\"color:orange\">工厂模式</font></h3><pre><code>function Person() {\n   var o = new Object();\n    o.name = &apos;hanmeimei&apos;;\n    o.say = function() {\n    alert(this.name);\n }\n    return o;\n }\n var person1 = Person();\n</code></pre><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li>完成了返回一个对象的要求。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><ol>\n<li><p>无法通过constructor识别对象，以为都是来自Object，无法得知来自Person</p>\n</li>\n<li><p>每次通过Person创建对象的时候，所有的say方法都是一样的，但是却存储了多次，浪费资源。</p>\n</li>\n</ol>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a><font style=\"color:orange\">构造函数模式</font></h3><pre><code>function Person() {\n      this.name = &apos;hanmeimei&apos;;\n      this.say = function() {\n        alert(this.name)\n      }\n  }\nvar person1 = new Person();\n</code></pre><h4 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li>通过constructor或者instanceof可以识别对象实例的类别</li>\n<li>可以通过new 关键字来创建对象实例，更像OO语言中创建对象实例</li>\n</ol>\n<h4 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><ol>\n<li>多个实例的say方法都是实现一样的效果，但是却存储了很多次（两个对象实例的say方法是不同的，因为存放的地址不同）</li>\n</ol>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a><font style=\"color:red\">注意：</font></h3><ol>\n<li>构造函数模式隐试的在最后返回<code>return this</code> 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象。</li>\n<li>也可以根据<code>return this</code> 的特性调用call或者apply指定this。这一点在后面的继承有很大帮助。</li>\n</ol>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a><font style=\"color:orange\">原型模式</font></h3><pre><code>function Person() {}\nPerson.prototype.name = &apos;hanmeimei&apos;;\nPerson.prototype.say = function() {\n     alert(this.name);\n}\nPerson.prototype.friends = [&apos;lilei&apos;];\nvar person1 = new Person();\n</code></pre><h4 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li><p>say方法是共享的了，所有的实例的say方法都指向同一个。</p>\n</li>\n<li><p>可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。</p>\n</li>\n</ol>\n<hr>\n<pre><code>var person1 = new Person()\nPerson.prototype.showFriends = function() {\n      console.log(this.friends)\n}\nperson1.showFriends()  //[&apos;lilei&apos;]\n</code></pre><h4 id=\"缺点：-2\"><a href=\"#缺点：-2\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><h5 id=\"出现引用的情况下会出现问题具体见下面代码：\"><a href=\"#出现引用的情况下会出现问题具体见下面代码：\" class=\"headerlink\" title=\"出现引用的情况下会出现问题具体见下面代码：\"></a>出现引用的情况下会出现问题具体见下面代码：</h5><pre><code>var person1 = new Person();\nvar person2 = new Person();\nperson1.friends.push(&apos;xiaoming&apos;);\nconsole.log(person2.friends)  //[&apos;lilei&apos;, &apos;xiaoming&apos;]\n</code></pre><h5 id=\"因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。\"><a href=\"#因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。\" class=\"headerlink\" title=\"因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。\"></a>因为js对引用类型的赋值都是将地址存储在变量中，所以person1和person2的friends属性指向的是同一块存储区域。</h5><ol>\n<li>第一次调用say方法或者name属性的时候会搜索两次，第一次是在实例上寻找say方法，没有找到就去原型对象(Person.prototype)上找say方法，找到后就会在实力上添加这些方法or属性。    </li>\n</ol>\n<ol>\n<li>所有的方法都是共享的，没有办法创建实例自己的属性和方法，也没有办法像构造函数那样传递参数。</li>\n</ol>\n<h3 id=\"注意：-1\"><a href=\"#注意：-1\" class=\"headerlink\" title=\"注意：\"></a><font style=\"color:red\">注意：</font></h3><p>优点②中存在一个问题就是直接通过对象字面量给<code>Person.prototype</code>进行赋值的时候会导致<code>constructor</code>改变，所以需要手动设置，其次就是通过对象字面量给<code>Person.prototype</code>进行赋值，会无法作用在之前创建的对象实例上</p>\n<pre><code>var person1 = new Person()\nPerson.prototype = {\n        name: &apos;hanmeimei2&apos;,\n          setName: function(name){\n          this.name = name\n      }\n}\nperson1.setName()   //Uncaught TypeError: person1.set     is not a     function(…)\n</code></pre><p>这是因为对象实例和对象原型直接是通过一个指针链接的，这个指针是一个内部属性[[Prototype]]，可以通过<code>__proto__</code>访问。我们通过对象字面量修改了Person.prototype指向的地址，然而对象实例的<code>__proto__</code>，并没有跟着一起更新，所以这就导致，实例还访问着原来的<code>Person.prototype</code>，所以建议不要通过这种方式去改变<code>Person.prototype</code>属性</p>\n<h3 id=\"构造函数和原型组合模式\"><a href=\"#构造函数和原型组合模式\" class=\"headerlink\" title=\"构造函数和原型组合模式\"></a><font style=\"color:orange\">构造函数和原型组合模式</font></h3><pre><code>function Person(name) {\n      this.name = name\n      this.friends = [&apos;lilei&apos;]\n}\nPerson.prototype.say = function() {\n      console.log(this.name)\n}\nvar person1 = new Person(&apos;hanmeimei&apos;)\nperson1.say() //hanmeimei\n</code></pre><h4 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li>解决了原型模式对于引用对象的缺点</li>\n<li>解决了原型模式没有办法传递参数的缺点</li>\n<li>解决了构造函数模式不能共享方法的缺点</li>\n</ol>\n<h4 id=\"缺点：-3\"><a href=\"#缺点：-3\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><ol>\n<li>和原型模式中注意①一样 （可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。针对这个问题中存在一个问题就是直接通过对象字面量给Person.prototype进行赋值的时候会导致constructor改变，所以需要手动设置，其次就是通过对象字面量给Person.prototype进行赋值，会无法作用在之前创建的对象实例上）</li>\n</ol>\n<h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a><font style=\"color:orange\">动态原型模式</font></h3><pre><code>function Person(name) {\n      this.name = name\n       if(typeof this.say != &apos;function&apos;) {\n        Person.prototype.say = function(\n        alert(this.name)\n      }\n}\n</code></pre><h4 id=\"优点：-4\"><a href=\"#优点：-4\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><ol>\n<li>可以在初次调用构造函数的时候就完成原型对象的修改</li>\n<li>修改能体现在所有的实例中</li>\n</ol>\n<h4 id=\"缺点：-4\"><a href=\"#缺点：-4\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><h5 id=\"红宝书都说这个方案完美了。。。。\"><a href=\"#红宝书都说这个方案完美了。。。。\" class=\"headerlink\" title=\"红宝书都说这个方案完美了。。。。\"></a>红宝书都说这个方案完美了。。。。</h5><h3 id=\"寄生构造函数模式\"><a href=\"#寄生构造函数模式\" class=\"headerlink\" title=\"寄生构造函数模式\"></a><font style=\"color:orange\">寄生构造函数模式</font></h3><pre><code>function Person(name) {\n      var o = new Object()\n     o.name = name\n     o.say = function() {\n        alert(this.name)\n      }\n          return o\n    }\nvar peron1 = new Person(&apos;hanmeimei&apos;)\n</code></pre><h4 id=\"优点：-5\"><a href=\"#优点：-5\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><h5 id=\"和工厂模式基本一样，除了多了个new操作符\"><a href=\"#和工厂模式基本一样，除了多了个new操作符\" class=\"headerlink\" title=\"和工厂模式基本一样，除了多了个new操作符\"></a>和工厂模式基本一样，除了多了个new操作符</h5><h4 id=\"缺点：-5\"><a href=\"#缺点：-5\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><h5 id=\"和工厂模式一样，不能区分实例的类别\"><a href=\"#和工厂模式一样，不能区分实例的类别\" class=\"headerlink\" title=\"和工厂模式一样，不能区分实例的类别\"></a>和工厂模式一样，不能区分实例的类别</h5><h3 id=\"稳妥构造模式\"><a href=\"#稳妥构造模式\" class=\"headerlink\" title=\"稳妥构造模式\"></a><font style=\"color:orange\">稳妥构造模式</font></h3><pre><code>function Person(name) {\n     var o = new Object()\n      o.say = function() {\n    alert(name)\n   }\n}\nvar person1 = new Person(&apos;hanmeimei&apos;);\nperson1.name  // undefined\nperson1.say() //hanmeimei\n</code></pre><h4 id=\"优点：-6\"><a href=\"#优点：-6\" class=\"headerlink\" title=\"优点：\"></a><font style=\"color:red\">优点：</font></h4><p>安全，name好像成为了私有变量，只能通过say方法去访问</p>\n<h4 id=\"缺点：-6\"><a href=\"#缺点：-6\" class=\"headerlink\" title=\"缺点：\"></a><font style=\"color:red\">缺点：</font></h4><h5 id=\"不能区分实例的类别\"><a href=\"#不能区分实例的类别\" class=\"headerlink\" title=\"不能区分实例的类别\"></a>不能区分实例的类别</h5><p>🔗原文链接: [<a href=\"http://alvinyuxt.github.io/2016/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/\">http://alvinyuxt.github.io/2016/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</a>) by @alvinyuxt</p>\n"},{"title":"CSS3,实现简单的轮播图","date":"2016-06-15T09:06:23.000Z","_content":"###    用css3实现一个简单的轮播图\n\n大家如果不用插件，如果js还学得不好，实现一个轮播图，那么就试试我这个cs3实现的轮播图把！哈哈哈\n\n\n\n#### 用css3实现一个简单的slider轮播图\n\n\t<!DOCTYPE html>\n\t<html>\n\t<head>\n\t\t<meta charset=\"utf-8\"/>\n\t\t<title></title>\n\t\t<style type=\"text/css\">\n\t\t\t.box{\n\t\t\t\twidth: 456px;\n\t\t\t\theight: 256px;\n\t\t\t\tmargin: auto;\n\t\t\t\toverflow: hidden;\n\t\t\t}\n\t\t\t.bigdiv{\n\t\t\t\twidth: 2400px;\n\t\t\t\tanimation:run 20s linear infinite;\n\n\t\t\t}\n\t\t\timg{\n\t\t\t\twidth: 19%;\n\t\t\t}\n\t\t\t@keyframes run{\n        \t   0%{\n          \t\tmargin-left: 0px;\n            \t}\n               5%{\n            \t margin-left: 0px;\n          \t   }\n          \t   20%{\n            \t margin-left: -456px;\n         \t    }\n           \t  25%{\n             \tmargin-left: -456px;\n           \t  }\n              40%{\n             \tmargin-left: -912px;\n            \t }\n              45%{\n             \tmargin-left: -912px;\n              }\n             60%{\n             \tmargin-left: -1368px;\n             }\n             65%{\n             \tmargin-left: -1368px;\n             }\n             80%{\n             \tmargin-left: -1834px;\n             }\n             85%{\n             \tmargin-left: -1834px;\n             }\n             100%{\n             \tmargin-left: -2280px;-\n             }\n\n\t\t}\n\n\t</style>\n\t</head>\n\t<body>\n   \t \t<div class=\"box\">\n    \t \t  <div class=\"bigdiv\">\n    \t   \t \t      <img src=\"放置图片路径\" \talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t   \t     \t  <img src=\"放置图片路径\" \talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t   \t      \t  <img src=\"放置图片路径\"\t\talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t   \t      \t  <img src=\"放置图片路径\" \talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t   \t    \t  <img src=\"放置图片路径\" \talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t  \t </div>\n   \t\t </div>\n\n\t</body>\n\t</html>\n\t\n这样一个轮播图就出来了   大家看完如果觉得不错  就收藏一下⭐️⭐️⭐️⭐️⭐️\n\n","source":"_posts/纯CSS3实现轮播图.md","raw":"---\ntitle: CSS3,实现简单的轮播图\ndate: 2016-6-15 17:06:23\ntags: [CSS,实现简单的轮播图]\n---\n###    用css3实现一个简单的轮播图\n\n大家如果不用插件，如果js还学得不好，实现一个轮播图，那么就试试我这个cs3实现的轮播图把！哈哈哈\n\n\n\n#### 用css3实现一个简单的slider轮播图\n\n\t<!DOCTYPE html>\n\t<html>\n\t<head>\n\t\t<meta charset=\"utf-8\"/>\n\t\t<title></title>\n\t\t<style type=\"text/css\">\n\t\t\t.box{\n\t\t\t\twidth: 456px;\n\t\t\t\theight: 256px;\n\t\t\t\tmargin: auto;\n\t\t\t\toverflow: hidden;\n\t\t\t}\n\t\t\t.bigdiv{\n\t\t\t\twidth: 2400px;\n\t\t\t\tanimation:run 20s linear infinite;\n\n\t\t\t}\n\t\t\timg{\n\t\t\t\twidth: 19%;\n\t\t\t}\n\t\t\t@keyframes run{\n        \t   0%{\n          \t\tmargin-left: 0px;\n            \t}\n               5%{\n            \t margin-left: 0px;\n          \t   }\n          \t   20%{\n            \t margin-left: -456px;\n         \t    }\n           \t  25%{\n             \tmargin-left: -456px;\n           \t  }\n              40%{\n             \tmargin-left: -912px;\n            \t }\n              45%{\n             \tmargin-left: -912px;\n              }\n             60%{\n             \tmargin-left: -1368px;\n             }\n             65%{\n             \tmargin-left: -1368px;\n             }\n             80%{\n             \tmargin-left: -1834px;\n             }\n             85%{\n             \tmargin-left: -1834px;\n             }\n             100%{\n             \tmargin-left: -2280px;-\n             }\n\n\t\t}\n\n\t</style>\n\t</head>\n\t<body>\n   \t \t<div class=\"box\">\n    \t \t  <div class=\"bigdiv\">\n    \t   \t \t      <img src=\"放置图片路径\" \talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t   \t     \t  <img src=\"放置图片路径\" \talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t   \t      \t  <img src=\"放置图片路径\"\t\talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t   \t      \t  <img src=\"放置图片路径\" \talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t   \t    \t  <img src=\"放置图片路径\" \talt=\"\">   // 这里没有放置图片  大家可以自己添加\n    \t  \t </div>\n   \t\t </div>\n\n\t</body>\n\t</html>\n\t\n这样一个轮播图就出来了   大家看完如果觉得不错  就收藏一下⭐️⭐️⭐️⭐️⭐️\n\n","slug":"纯CSS3实现轮播图","published":1,"updated":"2016-11-16T09:27:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civm2xnwy000b1rsmjpz13pqx","content":"<h3 id=\"用css3实现一个简单的轮播图\"><a href=\"#用css3实现一个简单的轮播图\" class=\"headerlink\" title=\"用css3实现一个简单的轮播图\"></a>用css3实现一个简单的轮播图</h3><p>大家如果不用插件，如果js还学得不好，实现一个轮播图，那么就试试我这个cs3实现的轮播图把！哈哈哈</p>\n<h4 id=\"用css3实现一个简单的slider轮播图\"><a href=\"#用css3实现一个简单的slider轮播图\" class=\"headerlink\" title=\"用css3实现一个简单的slider轮播图\"></a>用css3实现一个简单的slider轮播图</h4><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;/&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n        .box{\n            width: 456px;\n            height: 256px;\n            margin: auto;\n            overflow: hidden;\n        }\n        .bigdiv{\n            width: 2400px;\n            animation:run 20s linear infinite;\n\n        }\n        img{\n            width: 19%;\n        }\n        @keyframes run{\n           0%{\n              margin-left: 0px;\n            }\n           5%{\n             margin-left: 0px;\n             }\n             20%{\n             margin-left: -456px;\n             }\n             25%{\n             margin-left: -456px;\n             }\n          40%{\n             margin-left: -912px;\n             }\n          45%{\n             margin-left: -912px;\n          }\n         60%{\n             margin-left: -1368px;\n         }\n         65%{\n             margin-left: -1368px;\n         }\n         80%{\n             margin-left: -1834px;\n         }\n         85%{\n             margin-left: -1834px;\n         }\n         100%{\n             margin-left: -2280px;-\n         }\n\n    }\n\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;box&quot;&gt;\n           &lt;div class=&quot;bigdiv&quot;&gt;\n                      &lt;img src=&quot;放置图片路径&quot;     alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n                      &lt;img src=&quot;放置图片路径&quot;     alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n                       &lt;img src=&quot;放置图片路径&quot;        alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n                       &lt;img src=&quot;放置图片路径&quot;     alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n                     &lt;img src=&quot;放置图片路径&quot;     alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n           &lt;/div&gt;\n        &lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>这样一个轮播图就出来了   大家看完如果觉得不错  就收藏一下⭐️⭐️⭐️⭐️⭐️</p>\n","excerpt":"","more":"<h3 id=\"用css3实现一个简单的轮播图\"><a href=\"#用css3实现一个简单的轮播图\" class=\"headerlink\" title=\"用css3实现一个简单的轮播图\"></a>用css3实现一个简单的轮播图</h3><p>大家如果不用插件，如果js还学得不好，实现一个轮播图，那么就试试我这个cs3实现的轮播图把！哈哈哈</p>\n<h4 id=\"用css3实现一个简单的slider轮播图\"><a href=\"#用css3实现一个简单的slider轮播图\" class=\"headerlink\" title=\"用css3实现一个简单的slider轮播图\"></a>用css3实现一个简单的slider轮播图</h4><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;/&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n        .box{\n            width: 456px;\n            height: 256px;\n            margin: auto;\n            overflow: hidden;\n        }\n        .bigdiv{\n            width: 2400px;\n            animation:run 20s linear infinite;\n\n        }\n        img{\n            width: 19%;\n        }\n        @keyframes run{\n           0%{\n              margin-left: 0px;\n            }\n           5%{\n             margin-left: 0px;\n             }\n             20%{\n             margin-left: -456px;\n             }\n             25%{\n             margin-left: -456px;\n             }\n          40%{\n             margin-left: -912px;\n             }\n          45%{\n             margin-left: -912px;\n          }\n         60%{\n             margin-left: -1368px;\n         }\n         65%{\n             margin-left: -1368px;\n         }\n         80%{\n             margin-left: -1834px;\n         }\n         85%{\n             margin-left: -1834px;\n         }\n         100%{\n             margin-left: -2280px;-\n         }\n\n    }\n\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;box&quot;&gt;\n           &lt;div class=&quot;bigdiv&quot;&gt;\n                      &lt;img src=&quot;放置图片路径&quot;     alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n                      &lt;img src=&quot;放置图片路径&quot;     alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n                       &lt;img src=&quot;放置图片路径&quot;        alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n                       &lt;img src=&quot;放置图片路径&quot;     alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n                     &lt;img src=&quot;放置图片路径&quot;     alt=&quot;&quot;&gt;   // 这里没有放置图片  大家可以自己添加\n           &lt;/div&gt;\n        &lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>这样一个轮播图就出来了   大家看完如果觉得不错  就收藏一下⭐️⭐️⭐️⭐️⭐️</p>\n"},{"title":"给大家罗列这段时间的面试题","date":"2016-11-17T02:55:47.000Z","_content":"#### 1. 下面的值中那个不属于JS的基本类型\n\n\t\tA: 'abcd'\n \n\t\tB: 1234 \n\n\t\tC: ['1234']\n\n\t\tD: null\n\t\n#### 2. 下面对数组的描述中，说法不正确的是：\n\t\n\t\tA： 素组是一组属性名和属性的有序集合\n\t\n\t\tB: 素组的length属性既可以获取，也可以被修改\n\t\n\t\tC: 使用push()方法给数组添加值 ，会直接修改原数组\n\t\n\t\tD: shift()的返回值是数组的长度\n\t\n#### 3. 下面的等式不成立的是：\n\t\n\t\tA: 1 == true\n\t\n\t\tB: null == undefined\n\t\n\t\tC: '0' == false\n\t\n\t\tD: isNaN(true) == false\n\t\n#### 4. 任何类型的值与字符串相加，都是在做字符串拼接。\n\n\t\tA: 正确 \n\t\n\t\tB: 错误\n\t\n#### 5. 下面哪个值为真值：\n\n\t\tA: 0\n\t\n\t\tB: undefined\n\t\n\t\tC: []\n\t\n\t\tD: false\n\n#### 6. 下面代码的执行结果是：\n\t\n\t\tfor(var i = 0; i<=5){\n\t\n\t\t++i;\n\t\t\n\t\t}\n\t\talert(i);\n\t\t\n#### 7. 下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：____\n\t\n\t\t<ul>\n\t\t\t<li>1</Li>\t\n\t\t\t<li>2</Li>\t\n\t\t\t<li>3</Li>\t\n\t\t\t<li>4</Li>\t\n\t\t\t<li>5</Li>\t\n\t\t</ul>\n\t\t\n\t\t<script>\n\t\t\tvar aLi = document.getElementsByTagName(\"li\");\n\t\t\tfor(var i = 0;i < aLi.lenght;i++){\n\t\t\t\taLi[i].onclick = function(){\n\t\t\t\t\talert(i);\n\t\t\t\t}\n\t\t\t}\n\t\t</script>\n\t\t\n\t\tA: 正确\n\t\n\t\tB: 错误\n\t\t\n\t\t\n#### 8. 执行下面的代码片段，会弹出div的内容\"这是一个div\"，____\n\n\t\t<div id=\"div\">这是一个div</div>\n\t\n\t\t<script>\n\t\t\n\t\t\tvar oDiv = document.getElementsByTagName(\"div\");\n\t\t\t\n\t\t\t\talert(oDiv.innerHTML);\n\t\t\t\t\n\t\t</script> \n\t\t\t\n\t\tA: 正确\n\t \n\t\tB: 错误\n\t\n#### 9. 通过arr[1]可以获取到下面数组中的1.____\n\t\n\t\tvar arr = [1,2,3,4];\n\t\n\t\tA: 正确\n\t\n\t\tB: 错误\n\t\n#### 10. 下面的代码中编写中，正确的是：____\n\t\n\t\tA: var aLi = document.getElementsByTagName(\"li\");\n\t\t\n\t\t\taLi.innerHTML = '今天天气真好啊';\n\t\t\t\n\t\tB: var oDiv1 = document.getElementById(\"div1\");\n\t\t\n\t\t\tvar oDiv2 = document.getElementById(\"div2\");\n\t\t\t\n\t\tC: var oImg = document.getElementById('pic');\n\t\t\n\t\t\tif(oImg.src == \"1.jpg\"){\n\t\t\t\n\t\t\t\toImg.src = \"2.jpg\";\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\tD: var oUl = document.getElementById(\"ul1\");\n\t\t\t\n\t\t\toUl.className = \"active\";\n\t\t\t\t\n#### 11. 下面代码的运行结果是：_____\n\n\t\tvar a = 20;\n\t\t\n\t\t\talert(!a);\n\t\t\n\t\tA: -20\n\t\t\n\t\tB: undefined\n\t\t\n\t\tC: true\n\t\t\n\t\tD: false\n\t\t\n#### 12.\t下面代码的运行结果是：___\n\t\n\t\t\tfunction fn1(){\n\t\t\n\t\t\t\talert(1);\n\t\t\t\n\t\t\t\t}\t\n\t\t\t\n\t\t\t\talert(fn1);\n\t\t\n\t\t\t\t A: 1\n\t\t\n\t\t\t\tB: undefined\n\t\t\n\t\t\t\tC: function fn1(){\n\t\t\t\n\t\t\t\t\t\talert(1);\n\t\t\t\n\t\t\t\t\t}\n\t\t\n\t\t\t\tD: alert(1)\n\t\t\n#### 13. 以下代码的运行结果是：____\n\n\t\tvar i = 0;\n\t\t\n\t\t\talert( ++i == i++ );\n\t\t\t\t\n\t\t\n\t\tA: true\n\t\t\n\t\tB: false\n\t\t\n\t\tC: undefined\n\t\t\n\t\tD: NaN\n\n#### 14. 下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行:____\n\n\t\tvar timer = null;\n\t\t\n\t\tvar i = 0;\n\t\t\n\t\ttimer = setInertvar(function(){\n\t\t\n\t\t\ti++;\n\t\t\t\n\t\t\talert(i);\n\t\t\t\n\t\t\tif(i == 10){\n\t\t\t\n\t\t\t alert(\"定时器被关闭了。\");\n\t\t\t \n\t\t\t clearInterval(timer);\t\t\t \n\t\t\t\n\t\t\t}\t\t\t\n\t\t\n\t\t},1000)\t\n\t\t\n\t\t(function(){\n\t\t\t\n\t\t\talert(\"我是一个函数。\")\n\t\t\t\n\t\t})\t\n\t\t\n\t\t（）;\n\t\t\n\t\tA: 正确\n\t \n\t\tB: 错误\t\n\t\n#### 15. 下面的等式成立的是：_____\n\n\t\tA: parseInt(12.5) == paeseFloat(12.5)\n\t\n\t\tB: Number(\"\") == parseFloat(\"\");\n\t\n\t\tC: isNaN(\"abc\") == NaN\n\t\n\t\tD: typeof NaN === \"number\"\t\n\t\t\n#### 16. 下面描述中正确的是：___\n\n\t\tA: '=='在比较过程中，不但会比较两边的值，韩慧比较两边的数据类型\n\t\t\n\t\tB: '==='在比较过程中，如果有必要，会进行数据类型转换\n\t\t\n\t\tC: 任何类型的值，使用！进行转换后，结果一定是一个布尔值\n\t\t\n\t\tD: NaN == NaN 的结果是true;\t\t\n\t\n#### 17. 下面的描述中不正确的是:____\n\n\t\tA: arguments 中保存了世纪传入函数内的所有参数\n\t\t\n\t\tB: return 只能在函数内部使用\n\t\t\n\t\tC: setInterval(fn1,1000)只会调用一次 fn1\n\t\t\n\t\tD: Date 对象的getMonth()获取到的值比实际月份小1；\n\t\t\n#### 18. 以下代码中，会出现什么结果___\n\n\t\tvar i = 0;\n\t\t\n\t\twhite(i < 6){\n\t\t\n\t\t\tif(i == 4){\n\t\t\t\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\ti++;\n\t\t\n\t\t}\n\t\t\n\t\talert(i);\n\n\t\n\t\tA: 6\n\t\t\n\t\tB: 4\n\t\t\n\t\tC: 5\n\t\t\n\t\tD: 死循环\t\t\n\t\t\n#### 19. 以下代码中，会出现什么结果：____\n\n\t\tfunction fn1(){\n\t\t\n\t\t\tvar a = 0;\n\t\t\t\n\t\t\tfunction fn2(){\n\t\t\t\n\t\t\t\ta++;\n\t\t\t\t\n\t\t\t\talert(a);\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn fn2;\n\t\t\t\n\t\t}\n\t\t\n\t\tfn1()();\n\t\tfn1()();\t\n\t\t\n\t\tA: 第一次弹1,第二次弹2\n\t\t\n\t\tB: 第一次弹1,第二次弹1\t\t\n\t\t\n#### 20. 以下代码中，会出现什么结果：___\n\n\t\tfn1(10);\n\t\n\t\tfunction fn1(a){\n\t\t\n\t\t\talert(a === arguments[0]);\n\t\t\n\t\t}\n\t\t\n\t\tA: true\n\t\t\n\t\tB: false\n\n#### 21. alert(\"12\">\"9\")的运行结果正确的是：____\n\n\t\tA: true\n\t\t\n\t\tB: false\n\n#### 22. [1,2,3,4].join(\"0\").split(\"\")的执行结果是:____\n\n\t\tA: '1,2,3,4'\n\t\t\n\t\tB: [1,2,3,4]\n\t\t\n\t\tC: [1,0,2,0,3,0,4]\n\t\t\n\t\tD: '1,0,2,0,3,0,4'\t\n\t\t\n#### 23. 下面对substring()方法描述不正确的是：___\n\n\t\tA: 一共有两个参数，胜率第一个参数表示从开始位置提取到字符串结束。\n\t\t\n\t\tB: 提取之前会比较两个参数的大小，并根据大小调整位置。\n\t\t\n\t\tC: 可以接受负数参数，负数表示从欧往前数字符位置。\n\t\t\n\t\tD: 如果没有设置参数，直接返回整个字符串。\n\t\t\n#### 24. charCodeAt() 方法可以把一个字符串编码转换成指定的字符___\n\n\t\tA: 正确\n\t\t\n\t\tB: 错误\n\n#### 25. 调用indexOf() 方法会返回指定字符串在字符串中出现的所在位置：___\n\n\t\tA: 正确\n\t\t\n\t\tB: 错误\n\t\t\n#### 26. 下面股阿奴数组的描述正确的是：___\n\n\t\tA: 数组的length既可以获取，也可以修改。\n\t\t\n\t\tB: 调用pop()方法，不会修改原数组中的值。\n\t\t\n\t\tC: shift()方法的返回值是新数组的长度。\t\n\t\t\n\t\tD: 调用concat() 方法，会修改原数组的值。\n\t\t\n#### 27. 下面事件中，不会产生冒泡的是：___\n\n\t\tA: mouseover\n\t\t\n\t\tB: keydown\n\t\t\n\t\tC: focus\n\t\t\n\t\tD: click\n\t\t\n#### 28. 可以通过下面那种方式阻止事件的默认行为：___\t\n\n\t\tA: ev.preventDefault()\n\t\t\n\t\tB: ev.cancelBubble = true\n\t\t\n\t\tC: ev.stopPropagation()\n\t\t\n\t\tD: return true; \t\t\t\n\n#### 29. 下面那个DOM 方法可以用来创建一个新的DOM 元素：___\n\n\t\tA: appendChild()\n\t\t\n\t\tB: insertBefore()\n\t\t\n\t\tC: createElement()\n\t\t\n\t\tD: createTextNode()\n\t\t\n#### 30. 当浏览器窗口发生尺寸变化时，会触发下面那个事件：___\n\n\t\tA: onscroll\n\t\t\n\t\tB: onresize\n\t\t\n\t\tC: onload\n\t\t\n\t\tD: onerror\n\t\t\n#### 31. 如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：___\n\n\t\tA: offsetWidth\n\t\t\n\t\tB: clientWidth\n\t\t\n\t\tC: scrollWidth\n\t\t\n\t\tD: innerWidth\n\n#### 32. 下面JS的两个定时器描述正确的是：___\n\n\t\tA: setInertval() 只会在延迟一段时间之后执行一次指定得代码\n\t\t\n\t\tB: setTimeout() 可以在每间隔一段时间之后就执行一次指定的代码\n\t\t\n\t\tC: 定时器内部的this ，在非严格模式下默认为window对象\n\t\t\n\t\tD: 定时器在执行过程中，会阻塞下面的执行\n\t\t\n#### 33. 通过下面哪一个BOM 对象可以获取浏览器地址栏相关信息:___\n\n\t\tA: location\n\t\t\n\t\tB: history\n\t\t\n\t\tC: window\n\t\t\n\t\tD: navigator\n\t\t\n#### 34. 事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：___\n\n\t\tA: clientX\n\t\t\n\t\tB: pageX\n\t\t\n\t\tC: offsetX\n\t\t\n\t\tD: screenX\n\t\t\n#### 35. cookie的默认什么时候失效：___\n\n\t\tA: 浏览器窗口关闭\n\t\t\n\t\tB: 一个小时之后\n\t\t\n\t\tC: 计算机关机\n\t\t\n\t\tD: 切换到其他浏览器标签页\t\n\t\t\n\t\t\n#### 36. 下面那个不属于正则表达式的元字符:___\n\n\t\tA: \\w\n\t\tB: \\a\n\t\tC: \\D\n\t\tD: \\s\n\t\t\n#### 37. 下面那个方法的参数不支持正则表达式：___\n\n\t\tA: replace()\n\t\t\n\t\tB: split()\n\t\t\n\t\tC: search()\n\t\t\n\t\tD: slice()\t\n\t\t\n#### 38. 关于Date() 对象的参数， 下面那个中写法有兼容问题：___\n\n\t\tA: new Date(2016,4,23)\n\t\t\n\t\tB: new Date(123453543565)\n\t\t\n\t\tC: new Date('jun 23,2016')\n\t\t\n\t\tD: new Date('6 23,2016')\n\t\t\n#### 39. 下面描述中，说法不正确的是：___\n\n\t\tA: 事件对象只有在触发时间的时候才会保存信息 \n\t\t\n\t\tB: 正则的g修饰符表示进行全局匹配\n\t\t\n\t\tC: 对象的实行名称可以为字符串类型的数字\n\t\t\n\t\tD: click 事件没有冒泡行为\n\t\t\n#### 40. 瀑布流没有使用下面的哪一个知识点：___\n\n\t\tA: 图片延迟加载\n\t\t\n\t\tB: Image() 对象\n\t\t\n\t\tC: scrollTop\n\t\t\n\t\tD: ev.clientX\n\n#### 41. 关于正则的量词，下面说法不正确的是：___\n\n\t\tA: *表示匹配到0到多少个值\n\t\t\n\t\tB: +表示匹配0到多少个值\n\t\t\n\t\tC: {m,}表示最少匹配m个，最多不限\n\t\t\n\t\tD: {m,n}表示匹配至少m个，最多n个\n\n#### 42. 下面那个不属于JQuery库中的方法：___\n\n\t\tA: CSS()\n\t\t\n\t\tB: animate()\n\t\t\n\t\tC: getComputedStyle()\n\t\t\n\t\tD: attr()\n\t\t\t\t\n#### 43. JQuery 中如何获取一个div元素的内容：___\n\t\n\t\tA: $('div').innerHTML\n\t\t\n\t\tB: $('div').val()\n\t\t\n\t\tC: $('div').html\n\t\t\n\t\tD: $('div').html()\n\n#### 44. 下面那个不是事件对象中的属性：___\n\n\t\tA: keyCode\n\t\t\n\t\tB: ClientX\n\t\t\n\t\tC: offsetLeft\n\t\t\n\t\tD: detail\n\t\t\n#### 45. 下面哪一个属性可以查看一个实例对象的构造函数：___\n\n\t\tA: prototype\n\t\t\n\t\tB: constructor\n\t\t \n\t\tC: instanceof\n\t\t\n\t\tD: typeof\n\t\t\n#### 46. 下面说法错误的是：___\n\n\t\tA: return 关键字只能放在函数内部使用\n\t\t\n\t\tB: 逻辑运算符返回的结果一定是一个布尔值\n\t\t\n\t\tC: 关系运算符返回的结果一定是一个布尔值\n\t\t\n\t\tD: 字符串使用字符编码来比较大小\n\t\t\n#### 47. 下面那个时间不属于一定设备上的手势事件：___\n\n\t\tA: touchstart\n\t\t\n\t\tB: touchmove\n\t\t\n\t\tC: tap\n\t\t\n\t\tD: touchend\n\t\t\t\t\n#### 48. 通过addEventListener()方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：___\n\n\t\tA: 正确\n\t\t\t\n\t\tB: 错误\n\n#### 49. localstorage 中的数据只要用户不主动清除，将会一直保存在本地：___\n\n\t\tA: 正确\n\t\t\n\t\tB: 错误\n\t\t\n#### 50. 下面描述中，说法正确的是：___\n\n\t\tA: getComputeStyle()发发获取到的时行间的样式\n\t\t\n\t\tB: FireFox浏览器通过 mousewheel 来表示鼠标滚轮事件\n\t\t\n\t\tC: 通过Math.random() 方法可以或得一个0~1之间的随机数字\n\t\t\n\t\tD: split() 是一个数组方法\n\t\t\n## 二、\t简答题\n\n\n1. 要在canvas上绘制内容需要获取什么才能对画布进行操作，并写出基本图形绘制可以能用到的几步(例如一条线的额绘制需要怎么来实现，都需要设置什么？)\t2. \n2. 请写出绘制矩形常用的2种方法，并说说他们的不同点。\n3. 写出绘制圆形的方法，并说明每个参数的意义，我需要顺时针画弧要设置第几个属性，值为什么？\n4. 平移、旋转、缩放他们的共同特点是什么？如果我希望在进行一个旋转操作后画壁回到初始状态该怎么办？用代码阐述，并说说你对此的看法和理解。\n5. 绘制图片的方法有三种形式请分别写出并介绍每个参数(在一个图片正常的操作流程的实现)。\n6. 我们要操作一张图片需要获取这张图片的像素点，使用getlmageData()这个方法得到的对象中哪个属性使我们需要进行操作的，要操作的属性他的数据类型是什么？\n\n\t如果有能帮到大家的地方，希望大家给予点亮收藏并喜欢❤️！！谢谢\n\n文／原创/Dimple（github作者）\n原文链接：https://cuidapao.github.io/\n著作权归作者所有，转载请联系作者获得授权，并标注“github作者”。\n\n\n\n\n\t\n\t\n\t\n\t\t\n\t\t\n\t\t\n\t\n\t\t\n\t\n\t\t\n\t\t\n\t\t\n\t\t\n\n\n\n\t\n\n\n\t\n\n\t\t\t\t\n","source":"_posts/面试题.md","raw":"---\ntitle: 给大家罗列这段时间的面试题\ndate: 2016-11-17 10:55:47\ntags: [js,canvas,面试题]\n---\n#### 1. 下面的值中那个不属于JS的基本类型\n\n\t\tA: 'abcd'\n \n\t\tB: 1234 \n\n\t\tC: ['1234']\n\n\t\tD: null\n\t\n#### 2. 下面对数组的描述中，说法不正确的是：\n\t\n\t\tA： 素组是一组属性名和属性的有序集合\n\t\n\t\tB: 素组的length属性既可以获取，也可以被修改\n\t\n\t\tC: 使用push()方法给数组添加值 ，会直接修改原数组\n\t\n\t\tD: shift()的返回值是数组的长度\n\t\n#### 3. 下面的等式不成立的是：\n\t\n\t\tA: 1 == true\n\t\n\t\tB: null == undefined\n\t\n\t\tC: '0' == false\n\t\n\t\tD: isNaN(true) == false\n\t\n#### 4. 任何类型的值与字符串相加，都是在做字符串拼接。\n\n\t\tA: 正确 \n\t\n\t\tB: 错误\n\t\n#### 5. 下面哪个值为真值：\n\n\t\tA: 0\n\t\n\t\tB: undefined\n\t\n\t\tC: []\n\t\n\t\tD: false\n\n#### 6. 下面代码的执行结果是：\n\t\n\t\tfor(var i = 0; i<=5){\n\t\n\t\t++i;\n\t\t\n\t\t}\n\t\talert(i);\n\t\t\n#### 7. 下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：____\n\t\n\t\t<ul>\n\t\t\t<li>1</Li>\t\n\t\t\t<li>2</Li>\t\n\t\t\t<li>3</Li>\t\n\t\t\t<li>4</Li>\t\n\t\t\t<li>5</Li>\t\n\t\t</ul>\n\t\t\n\t\t<script>\n\t\t\tvar aLi = document.getElementsByTagName(\"li\");\n\t\t\tfor(var i = 0;i < aLi.lenght;i++){\n\t\t\t\taLi[i].onclick = function(){\n\t\t\t\t\talert(i);\n\t\t\t\t}\n\t\t\t}\n\t\t</script>\n\t\t\n\t\tA: 正确\n\t\n\t\tB: 错误\n\t\t\n\t\t\n#### 8. 执行下面的代码片段，会弹出div的内容\"这是一个div\"，____\n\n\t\t<div id=\"div\">这是一个div</div>\n\t\n\t\t<script>\n\t\t\n\t\t\tvar oDiv = document.getElementsByTagName(\"div\");\n\t\t\t\n\t\t\t\talert(oDiv.innerHTML);\n\t\t\t\t\n\t\t</script> \n\t\t\t\n\t\tA: 正确\n\t \n\t\tB: 错误\n\t\n#### 9. 通过arr[1]可以获取到下面数组中的1.____\n\t\n\t\tvar arr = [1,2,3,4];\n\t\n\t\tA: 正确\n\t\n\t\tB: 错误\n\t\n#### 10. 下面的代码中编写中，正确的是：____\n\t\n\t\tA: var aLi = document.getElementsByTagName(\"li\");\n\t\t\n\t\t\taLi.innerHTML = '今天天气真好啊';\n\t\t\t\n\t\tB: var oDiv1 = document.getElementById(\"div1\");\n\t\t\n\t\t\tvar oDiv2 = document.getElementById(\"div2\");\n\t\t\t\n\t\tC: var oImg = document.getElementById('pic');\n\t\t\n\t\t\tif(oImg.src == \"1.jpg\"){\n\t\t\t\n\t\t\t\toImg.src = \"2.jpg\";\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\tD: var oUl = document.getElementById(\"ul1\");\n\t\t\t\n\t\t\toUl.className = \"active\";\n\t\t\t\t\n#### 11. 下面代码的运行结果是：_____\n\n\t\tvar a = 20;\n\t\t\n\t\t\talert(!a);\n\t\t\n\t\tA: -20\n\t\t\n\t\tB: undefined\n\t\t\n\t\tC: true\n\t\t\n\t\tD: false\n\t\t\n#### 12.\t下面代码的运行结果是：___\n\t\n\t\t\tfunction fn1(){\n\t\t\n\t\t\t\talert(1);\n\t\t\t\n\t\t\t\t}\t\n\t\t\t\n\t\t\t\talert(fn1);\n\t\t\n\t\t\t\t A: 1\n\t\t\n\t\t\t\tB: undefined\n\t\t\n\t\t\t\tC: function fn1(){\n\t\t\t\n\t\t\t\t\t\talert(1);\n\t\t\t\n\t\t\t\t\t}\n\t\t\n\t\t\t\tD: alert(1)\n\t\t\n#### 13. 以下代码的运行结果是：____\n\n\t\tvar i = 0;\n\t\t\n\t\t\talert( ++i == i++ );\n\t\t\t\t\n\t\t\n\t\tA: true\n\t\t\n\t\tB: false\n\t\t\n\t\tC: undefined\n\t\t\n\t\tD: NaN\n\n#### 14. 下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行:____\n\n\t\tvar timer = null;\n\t\t\n\t\tvar i = 0;\n\t\t\n\t\ttimer = setInertvar(function(){\n\t\t\n\t\t\ti++;\n\t\t\t\n\t\t\talert(i);\n\t\t\t\n\t\t\tif(i == 10){\n\t\t\t\n\t\t\t alert(\"定时器被关闭了。\");\n\t\t\t \n\t\t\t clearInterval(timer);\t\t\t \n\t\t\t\n\t\t\t}\t\t\t\n\t\t\n\t\t},1000)\t\n\t\t\n\t\t(function(){\n\t\t\t\n\t\t\talert(\"我是一个函数。\")\n\t\t\t\n\t\t})\t\n\t\t\n\t\t（）;\n\t\t\n\t\tA: 正确\n\t \n\t\tB: 错误\t\n\t\n#### 15. 下面的等式成立的是：_____\n\n\t\tA: parseInt(12.5) == paeseFloat(12.5)\n\t\n\t\tB: Number(\"\") == parseFloat(\"\");\n\t\n\t\tC: isNaN(\"abc\") == NaN\n\t\n\t\tD: typeof NaN === \"number\"\t\n\t\t\n#### 16. 下面描述中正确的是：___\n\n\t\tA: '=='在比较过程中，不但会比较两边的值，韩慧比较两边的数据类型\n\t\t\n\t\tB: '==='在比较过程中，如果有必要，会进行数据类型转换\n\t\t\n\t\tC: 任何类型的值，使用！进行转换后，结果一定是一个布尔值\n\t\t\n\t\tD: NaN == NaN 的结果是true;\t\t\n\t\n#### 17. 下面的描述中不正确的是:____\n\n\t\tA: arguments 中保存了世纪传入函数内的所有参数\n\t\t\n\t\tB: return 只能在函数内部使用\n\t\t\n\t\tC: setInterval(fn1,1000)只会调用一次 fn1\n\t\t\n\t\tD: Date 对象的getMonth()获取到的值比实际月份小1；\n\t\t\n#### 18. 以下代码中，会出现什么结果___\n\n\t\tvar i = 0;\n\t\t\n\t\twhite(i < 6){\n\t\t\n\t\t\tif(i == 4){\n\t\t\t\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\ti++;\n\t\t\n\t\t}\n\t\t\n\t\talert(i);\n\n\t\n\t\tA: 6\n\t\t\n\t\tB: 4\n\t\t\n\t\tC: 5\n\t\t\n\t\tD: 死循环\t\t\n\t\t\n#### 19. 以下代码中，会出现什么结果：____\n\n\t\tfunction fn1(){\n\t\t\n\t\t\tvar a = 0;\n\t\t\t\n\t\t\tfunction fn2(){\n\t\t\t\n\t\t\t\ta++;\n\t\t\t\t\n\t\t\t\talert(a);\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn fn2;\n\t\t\t\n\t\t}\n\t\t\n\t\tfn1()();\n\t\tfn1()();\t\n\t\t\n\t\tA: 第一次弹1,第二次弹2\n\t\t\n\t\tB: 第一次弹1,第二次弹1\t\t\n\t\t\n#### 20. 以下代码中，会出现什么结果：___\n\n\t\tfn1(10);\n\t\n\t\tfunction fn1(a){\n\t\t\n\t\t\talert(a === arguments[0]);\n\t\t\n\t\t}\n\t\t\n\t\tA: true\n\t\t\n\t\tB: false\n\n#### 21. alert(\"12\">\"9\")的运行结果正确的是：____\n\n\t\tA: true\n\t\t\n\t\tB: false\n\n#### 22. [1,2,3,4].join(\"0\").split(\"\")的执行结果是:____\n\n\t\tA: '1,2,3,4'\n\t\t\n\t\tB: [1,2,3,4]\n\t\t\n\t\tC: [1,0,2,0,3,0,4]\n\t\t\n\t\tD: '1,0,2,0,3,0,4'\t\n\t\t\n#### 23. 下面对substring()方法描述不正确的是：___\n\n\t\tA: 一共有两个参数，胜率第一个参数表示从开始位置提取到字符串结束。\n\t\t\n\t\tB: 提取之前会比较两个参数的大小，并根据大小调整位置。\n\t\t\n\t\tC: 可以接受负数参数，负数表示从欧往前数字符位置。\n\t\t\n\t\tD: 如果没有设置参数，直接返回整个字符串。\n\t\t\n#### 24. charCodeAt() 方法可以把一个字符串编码转换成指定的字符___\n\n\t\tA: 正确\n\t\t\n\t\tB: 错误\n\n#### 25. 调用indexOf() 方法会返回指定字符串在字符串中出现的所在位置：___\n\n\t\tA: 正确\n\t\t\n\t\tB: 错误\n\t\t\n#### 26. 下面股阿奴数组的描述正确的是：___\n\n\t\tA: 数组的length既可以获取，也可以修改。\n\t\t\n\t\tB: 调用pop()方法，不会修改原数组中的值。\n\t\t\n\t\tC: shift()方法的返回值是新数组的长度。\t\n\t\t\n\t\tD: 调用concat() 方法，会修改原数组的值。\n\t\t\n#### 27. 下面事件中，不会产生冒泡的是：___\n\n\t\tA: mouseover\n\t\t\n\t\tB: keydown\n\t\t\n\t\tC: focus\n\t\t\n\t\tD: click\n\t\t\n#### 28. 可以通过下面那种方式阻止事件的默认行为：___\t\n\n\t\tA: ev.preventDefault()\n\t\t\n\t\tB: ev.cancelBubble = true\n\t\t\n\t\tC: ev.stopPropagation()\n\t\t\n\t\tD: return true; \t\t\t\n\n#### 29. 下面那个DOM 方法可以用来创建一个新的DOM 元素：___\n\n\t\tA: appendChild()\n\t\t\n\t\tB: insertBefore()\n\t\t\n\t\tC: createElement()\n\t\t\n\t\tD: createTextNode()\n\t\t\n#### 30. 当浏览器窗口发生尺寸变化时，会触发下面那个事件：___\n\n\t\tA: onscroll\n\t\t\n\t\tB: onresize\n\t\t\n\t\tC: onload\n\t\t\n\t\tD: onerror\n\t\t\n#### 31. 如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：___\n\n\t\tA: offsetWidth\n\t\t\n\t\tB: clientWidth\n\t\t\n\t\tC: scrollWidth\n\t\t\n\t\tD: innerWidth\n\n#### 32. 下面JS的两个定时器描述正确的是：___\n\n\t\tA: setInertval() 只会在延迟一段时间之后执行一次指定得代码\n\t\t\n\t\tB: setTimeout() 可以在每间隔一段时间之后就执行一次指定的代码\n\t\t\n\t\tC: 定时器内部的this ，在非严格模式下默认为window对象\n\t\t\n\t\tD: 定时器在执行过程中，会阻塞下面的执行\n\t\t\n#### 33. 通过下面哪一个BOM 对象可以获取浏览器地址栏相关信息:___\n\n\t\tA: location\n\t\t\n\t\tB: history\n\t\t\n\t\tC: window\n\t\t\n\t\tD: navigator\n\t\t\n#### 34. 事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：___\n\n\t\tA: clientX\n\t\t\n\t\tB: pageX\n\t\t\n\t\tC: offsetX\n\t\t\n\t\tD: screenX\n\t\t\n#### 35. cookie的默认什么时候失效：___\n\n\t\tA: 浏览器窗口关闭\n\t\t\n\t\tB: 一个小时之后\n\t\t\n\t\tC: 计算机关机\n\t\t\n\t\tD: 切换到其他浏览器标签页\t\n\t\t\n\t\t\n#### 36. 下面那个不属于正则表达式的元字符:___\n\n\t\tA: \\w\n\t\tB: \\a\n\t\tC: \\D\n\t\tD: \\s\n\t\t\n#### 37. 下面那个方法的参数不支持正则表达式：___\n\n\t\tA: replace()\n\t\t\n\t\tB: split()\n\t\t\n\t\tC: search()\n\t\t\n\t\tD: slice()\t\n\t\t\n#### 38. 关于Date() 对象的参数， 下面那个中写法有兼容问题：___\n\n\t\tA: new Date(2016,4,23)\n\t\t\n\t\tB: new Date(123453543565)\n\t\t\n\t\tC: new Date('jun 23,2016')\n\t\t\n\t\tD: new Date('6 23,2016')\n\t\t\n#### 39. 下面描述中，说法不正确的是：___\n\n\t\tA: 事件对象只有在触发时间的时候才会保存信息 \n\t\t\n\t\tB: 正则的g修饰符表示进行全局匹配\n\t\t\n\t\tC: 对象的实行名称可以为字符串类型的数字\n\t\t\n\t\tD: click 事件没有冒泡行为\n\t\t\n#### 40. 瀑布流没有使用下面的哪一个知识点：___\n\n\t\tA: 图片延迟加载\n\t\t\n\t\tB: Image() 对象\n\t\t\n\t\tC: scrollTop\n\t\t\n\t\tD: ev.clientX\n\n#### 41. 关于正则的量词，下面说法不正确的是：___\n\n\t\tA: *表示匹配到0到多少个值\n\t\t\n\t\tB: +表示匹配0到多少个值\n\t\t\n\t\tC: {m,}表示最少匹配m个，最多不限\n\t\t\n\t\tD: {m,n}表示匹配至少m个，最多n个\n\n#### 42. 下面那个不属于JQuery库中的方法：___\n\n\t\tA: CSS()\n\t\t\n\t\tB: animate()\n\t\t\n\t\tC: getComputedStyle()\n\t\t\n\t\tD: attr()\n\t\t\t\t\n#### 43. JQuery 中如何获取一个div元素的内容：___\n\t\n\t\tA: $('div').innerHTML\n\t\t\n\t\tB: $('div').val()\n\t\t\n\t\tC: $('div').html\n\t\t\n\t\tD: $('div').html()\n\n#### 44. 下面那个不是事件对象中的属性：___\n\n\t\tA: keyCode\n\t\t\n\t\tB: ClientX\n\t\t\n\t\tC: offsetLeft\n\t\t\n\t\tD: detail\n\t\t\n#### 45. 下面哪一个属性可以查看一个实例对象的构造函数：___\n\n\t\tA: prototype\n\t\t\n\t\tB: constructor\n\t\t \n\t\tC: instanceof\n\t\t\n\t\tD: typeof\n\t\t\n#### 46. 下面说法错误的是：___\n\n\t\tA: return 关键字只能放在函数内部使用\n\t\t\n\t\tB: 逻辑运算符返回的结果一定是一个布尔值\n\t\t\n\t\tC: 关系运算符返回的结果一定是一个布尔值\n\t\t\n\t\tD: 字符串使用字符编码来比较大小\n\t\t\n#### 47. 下面那个时间不属于一定设备上的手势事件：___\n\n\t\tA: touchstart\n\t\t\n\t\tB: touchmove\n\t\t\n\t\tC: tap\n\t\t\n\t\tD: touchend\n\t\t\t\t\n#### 48. 通过addEventListener()方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：___\n\n\t\tA: 正确\n\t\t\t\n\t\tB: 错误\n\n#### 49. localstorage 中的数据只要用户不主动清除，将会一直保存在本地：___\n\n\t\tA: 正确\n\t\t\n\t\tB: 错误\n\t\t\n#### 50. 下面描述中，说法正确的是：___\n\n\t\tA: getComputeStyle()发发获取到的时行间的样式\n\t\t\n\t\tB: FireFox浏览器通过 mousewheel 来表示鼠标滚轮事件\n\t\t\n\t\tC: 通过Math.random() 方法可以或得一个0~1之间的随机数字\n\t\t\n\t\tD: split() 是一个数组方法\n\t\t\n## 二、\t简答题\n\n\n1. 要在canvas上绘制内容需要获取什么才能对画布进行操作，并写出基本图形绘制可以能用到的几步(例如一条线的额绘制需要怎么来实现，都需要设置什么？)\t2. \n2. 请写出绘制矩形常用的2种方法，并说说他们的不同点。\n3. 写出绘制圆形的方法，并说明每个参数的意义，我需要顺时针画弧要设置第几个属性，值为什么？\n4. 平移、旋转、缩放他们的共同特点是什么？如果我希望在进行一个旋转操作后画壁回到初始状态该怎么办？用代码阐述，并说说你对此的看法和理解。\n5. 绘制图片的方法有三种形式请分别写出并介绍每个参数(在一个图片正常的操作流程的实现)。\n6. 我们要操作一张图片需要获取这张图片的像素点，使用getlmageData()这个方法得到的对象中哪个属性使我们需要进行操作的，要操作的属性他的数据类型是什么？\n\n\t如果有能帮到大家的地方，希望大家给予点亮收藏并喜欢❤️！！谢谢\n\n文／原创/Dimple（github作者）\n原文链接：https://cuidapao.github.io/\n著作权归作者所有，转载请联系作者获得授权，并标注“github作者”。\n\n\n\n\n\t\n\t\n\t\n\t\t\n\t\t\n\t\t\n\t\n\t\t\n\t\n\t\t\n\t\t\n\t\t\n\t\t\n\n\n\n\t\n\n\n\t\n\n\t\t\t\t\n","slug":"面试题","published":1,"updated":"2016-11-17T08:25:28.000Z","_id":"civm2xnx1000c1rsmrcyjq98c","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"1-下面的值中那个不属于JS的基本类型\"><a href=\"#1-下面的值中那个不属于JS的基本类型\" class=\"headerlink\" title=\"1. 下面的值中那个不属于JS的基本类型\"></a>1. 下面的值中那个不属于JS的基本类型</h4><pre><code>A: &apos;abcd&apos;\n\nB: 1234 \n\nC: [&apos;1234&apos;]\n\nD: null\n</code></pre><h4 id=\"2-下面对数组的描述中，说法不正确的是：\"><a href=\"#2-下面对数组的描述中，说法不正确的是：\" class=\"headerlink\" title=\"2. 下面对数组的描述中，说法不正确的是：\"></a>2. 下面对数组的描述中，说法不正确的是：</h4><pre><code>A： 素组是一组属性名和属性的有序集合\n\nB: 素组的length属性既可以获取，也可以被修改\n\nC: 使用push()方法给数组添加值 ，会直接修改原数组\n\nD: shift()的返回值是数组的长度\n</code></pre><h4 id=\"3-下面的等式不成立的是：\"><a href=\"#3-下面的等式不成立的是：\" class=\"headerlink\" title=\"3. 下面的等式不成立的是：\"></a>3. 下面的等式不成立的是：</h4><pre><code>A: 1 == true\n\nB: null == undefined\n\nC: &apos;0&apos; == false\n\nD: isNaN(true) == false\n</code></pre><h4 id=\"4-任何类型的值与字符串相加，都是在做字符串拼接。\"><a href=\"#4-任何类型的值与字符串相加，都是在做字符串拼接。\" class=\"headerlink\" title=\"4. 任何类型的值与字符串相加，都是在做字符串拼接。\"></a>4. 任何类型的值与字符串相加，都是在做字符串拼接。</h4><pre><code>A: 正确 \n\nB: 错误\n</code></pre><h4 id=\"5-下面哪个值为真值：\"><a href=\"#5-下面哪个值为真值：\" class=\"headerlink\" title=\"5. 下面哪个值为真值：\"></a>5. 下面哪个值为真值：</h4><pre><code>A: 0\n\nB: undefined\n\nC: []\n\nD: false\n</code></pre><h4 id=\"6-下面代码的执行结果是：\"><a href=\"#6-下面代码的执行结果是：\" class=\"headerlink\" title=\"6. 下面代码的执行结果是：\"></a>6. 下面代码的执行结果是：</h4><pre><code>for(var i = 0; i&lt;=5){\n\n++i;\n\n}\nalert(i);\n</code></pre><h4 id=\"7-下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：\"><a href=\"#7-下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：\" class=\"headerlink\" title=\"7. 下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：__\"></a>7. 下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：<em>__</em></h4><pre><code>&lt;ul&gt;\n    &lt;li&gt;1&lt;/Li&gt;    \n    &lt;li&gt;2&lt;/Li&gt;    \n    &lt;li&gt;3&lt;/Li&gt;    \n    &lt;li&gt;4&lt;/Li&gt;    \n    &lt;li&gt;5&lt;/Li&gt;    \n&lt;/ul&gt;\n\n&lt;script&gt;\n    var aLi = document.getElementsByTagName(&quot;li&quot;);\n    for(var i = 0;i &lt; aLi.lenght;i++){\n        aLi[i].onclick = function(){\n            alert(i);\n        }\n    }\n&lt;/script&gt;\n\nA: 正确\n\nB: 错误\n</code></pre><h4 id=\"8-执行下面的代码片段，会弹出div的内容”这是一个div”，\"><a href=\"#8-执行下面的代码片段，会弹出div的内容”这是一个div”，\" class=\"headerlink\" title=\"8. 执行下面的代码片段，会弹出div的内容”这是一个div”，__\"></a>8. 执行下面的代码片段，会弹出div的内容”这是一个div”，<em>__</em></h4><pre><code>&lt;div id=&quot;div&quot;&gt;这是一个div&lt;/div&gt;\n\n&lt;script&gt;\n\n    var oDiv = document.getElementsByTagName(&quot;div&quot;);\n\n        alert(oDiv.innerHTML);\n\n&lt;/script&gt; \n\nA: 正确\n\nB: 错误\n</code></pre><h4 id=\"9-通过arr-1-可以获取到下面数组中的1\"><a href=\"#9-通过arr-1-可以获取到下面数组中的1\" class=\"headerlink\" title=\"9. 通过arr[1]可以获取到下面数组中的1.__\"></a>9. 通过arr[1]可以获取到下面数组中的1.<em>__</em></h4><pre><code>var arr = [1,2,3,4];\n\nA: 正确\n\nB: 错误\n</code></pre><h4 id=\"10-下面的代码中编写中，正确的是：\"><a href=\"#10-下面的代码中编写中，正确的是：\" class=\"headerlink\" title=\"10. 下面的代码中编写中，正确的是：__\"></a>10. 下面的代码中编写中，正确的是：<em>__</em></h4><pre><code>A: var aLi = document.getElementsByTagName(&quot;li&quot;);\n\n    aLi.innerHTML = &apos;今天天气真好啊&apos;;\n\nB: var oDiv1 = document.getElementById(&quot;div1&quot;);\n\n    var oDiv2 = document.getElementById(&quot;div2&quot;);\n\nC: var oImg = document.getElementById(&apos;pic&apos;);\n\n    if(oImg.src == &quot;1.jpg&quot;){\n\n        oImg.src = &quot;2.jpg&quot;;\n\n    }\n\nD: var oUl = document.getElementById(&quot;ul1&quot;);\n\n    oUl.className = &quot;active&quot;;\n</code></pre><h4 id=\"11-下面代码的运行结果是：\"><a href=\"#11-下面代码的运行结果是：\" class=\"headerlink\" title=\"11. 下面代码的运行结果是：_\"></a>11. 下面代码的运行结果是：<strong>_</strong></h4><pre><code>var a = 20;\n\n    alert(!a);\n\nA: -20\n\nB: undefined\n\nC: true\n\nD: false\n</code></pre><h4 id=\"12-下面代码的运行结果是：\"><a href=\"#12-下面代码的运行结果是：\" class=\"headerlink\" title=\"12.    下面代码的运行结果是：___\"></a>12.    下面代码的运行结果是：___</h4><pre><code>function fn1(){\n\n    alert(1);\n\n    }    \n\n    alert(fn1);\n\n     A: 1\n\n    B: undefined\n\n    C: function fn1(){\n\n            alert(1);\n\n        }\n\n    D: alert(1)\n</code></pre><h4 id=\"13-以下代码的运行结果是：\"><a href=\"#13-以下代码的运行结果是：\" class=\"headerlink\" title=\"13. 以下代码的运行结果是：__\"></a>13. 以下代码的运行结果是：<em>__</em></h4><pre><code>var i = 0;\n\n    alert( ++i == i++ );\n\n\nA: true\n\nB: false\n\nC: undefined\n\nD: NaN\n</code></pre><h4 id=\"14-下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行\"><a href=\"#14-下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行\" class=\"headerlink\" title=\"14. 下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行:__\"></a>14. 下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行:<em>__</em></h4><pre><code>var timer = null;\n\nvar i = 0;\n\ntimer = setInertvar(function(){\n\n    i++;\n\n    alert(i);\n\n    if(i == 10){\n\n     alert(&quot;定时器被关闭了。&quot;);\n\n     clearInterval(timer);             \n\n    }            \n\n},1000)    \n\n(function(){\n\n    alert(&quot;我是一个函数。&quot;)\n\n})    \n\n（）;\n\nA: 正确\n\nB: 错误    \n</code></pre><h4 id=\"15-下面的等式成立的是：\"><a href=\"#15-下面的等式成立的是：\" class=\"headerlink\" title=\"15. 下面的等式成立的是：_\"></a>15. 下面的等式成立的是：<strong>_</strong></h4><pre><code>A: parseInt(12.5) == paeseFloat(12.5)\n\nB: Number(&quot;&quot;) == parseFloat(&quot;&quot;);\n\nC: isNaN(&quot;abc&quot;) == NaN\n\nD: typeof NaN === &quot;number&quot;    \n</code></pre><h4 id=\"16-下面描述中正确的是：\"><a href=\"#16-下面描述中正确的是：\" class=\"headerlink\" title=\"16. 下面描述中正确的是：___\"></a>16. 下面描述中正确的是：___</h4><pre><code>A: &apos;==&apos;在比较过程中，不但会比较两边的值，韩慧比较两边的数据类型\n\nB: &apos;===&apos;在比较过程中，如果有必要，会进行数据类型转换\n\nC: 任何类型的值，使用！进行转换后，结果一定是一个布尔值\n\nD: NaN == NaN 的结果是true;        \n</code></pre><h4 id=\"17-下面的描述中不正确的是\"><a href=\"#17-下面的描述中不正确的是\" class=\"headerlink\" title=\"17. 下面的描述中不正确的是:__\"></a>17. 下面的描述中不正确的是:<em>__</em></h4><pre><code>A: arguments 中保存了世纪传入函数内的所有参数\n\nB: return 只能在函数内部使用\n\nC: setInterval(fn1,1000)只会调用一次 fn1\n\nD: Date 对象的getMonth()获取到的值比实际月份小1；\n</code></pre><h4 id=\"18-以下代码中，会出现什么结果\"><a href=\"#18-以下代码中，会出现什么结果\" class=\"headerlink\" title=\"18. 以下代码中，会出现什么结果___\"></a>18. 以下代码中，会出现什么结果___</h4><pre><code>var i = 0;\n\nwhite(i &lt; 6){\n\n    if(i == 4){\n\n        continue;\n\n    }\n\n    i++;\n\n}\n\nalert(i);\n\n\nA: 6\n\nB: 4\n\nC: 5\n\nD: 死循环        \n</code></pre><h4 id=\"19-以下代码中，会出现什么结果：\"><a href=\"#19-以下代码中，会出现什么结果：\" class=\"headerlink\" title=\"19. 以下代码中，会出现什么结果：__\"></a>19. 以下代码中，会出现什么结果：<em>__</em></h4><pre><code>function fn1(){\n\n    var a = 0;\n\n    function fn2(){\n\n        a++;\n\n        alert(a);\n\n    }\n\n    return fn2;\n\n}\n\nfn1()();\nfn1()();    \n\nA: 第一次弹1,第二次弹2\n\nB: 第一次弹1,第二次弹1        \n</code></pre><h4 id=\"20-以下代码中，会出现什么结果：\"><a href=\"#20-以下代码中，会出现什么结果：\" class=\"headerlink\" title=\"20. 以下代码中，会出现什么结果：___\"></a>20. 以下代码中，会出现什么结果：___</h4><pre><code>fn1(10);\n\nfunction fn1(a){\n\n    alert(a === arguments[0]);\n\n}\n\nA: true\n\nB: false\n</code></pre><h4 id=\"21-alert-“12”-gt-”9”-的运行结果正确的是：\"><a href=\"#21-alert-“12”-gt-”9”-的运行结果正确的是：\" class=\"headerlink\" title=\"21. alert(“12”&gt;”9”)的运行结果正确的是：__\"></a>21. alert(“12”&gt;”9”)的运行结果正确的是：<em>__</em></h4><pre><code>A: true\n\nB: false\n</code></pre><h4 id=\"22-1-2-3-4-join-“0”-split-“”-的执行结果是\"><a href=\"#22-1-2-3-4-join-“0”-split-“”-的执行结果是\" class=\"headerlink\" title=\"22. [1,2,3,4].join(“0”).split(“”)的执行结果是:__\"></a>22. [1,2,3,4].join(“0”).split(“”)的执行结果是:<em>__</em></h4><pre><code>A: &apos;1,2,3,4&apos;\n\nB: [1,2,3,4]\n\nC: [1,0,2,0,3,0,4]\n\nD: &apos;1,0,2,0,3,0,4&apos;    \n</code></pre><h4 id=\"23-下面对substring-方法描述不正确的是：\"><a href=\"#23-下面对substring-方法描述不正确的是：\" class=\"headerlink\" title=\"23. 下面对substring()方法描述不正确的是：___\"></a>23. 下面对substring()方法描述不正确的是：___</h4><pre><code>A: 一共有两个参数，胜率第一个参数表示从开始位置提取到字符串结束。\n\nB: 提取之前会比较两个参数的大小，并根据大小调整位置。\n\nC: 可以接受负数参数，负数表示从欧往前数字符位置。\n\nD: 如果没有设置参数，直接返回整个字符串。\n</code></pre><h4 id=\"24-charCodeAt-方法可以把一个字符串编码转换成指定的字符\"><a href=\"#24-charCodeAt-方法可以把一个字符串编码转换成指定的字符\" class=\"headerlink\" title=\"24. charCodeAt() 方法可以把一个字符串编码转换成指定的字符___\"></a>24. charCodeAt() 方法可以把一个字符串编码转换成指定的字符___</h4><pre><code>A: 正确\n\nB: 错误\n</code></pre><h4 id=\"25-调用indexOf-方法会返回指定字符串在字符串中出现的所在位置：\"><a href=\"#25-调用indexOf-方法会返回指定字符串在字符串中出现的所在位置：\" class=\"headerlink\" title=\"25. 调用indexOf() 方法会返回指定字符串在字符串中出现的所在位置：___\"></a>25. 调用indexOf() 方法会返回指定字符串在字符串中出现的所在位置：___</h4><pre><code>A: 正确\n\nB: 错误\n</code></pre><h4 id=\"26-下面股阿奴数组的描述正确的是：\"><a href=\"#26-下面股阿奴数组的描述正确的是：\" class=\"headerlink\" title=\"26. 下面股阿奴数组的描述正确的是：___\"></a>26. 下面股阿奴数组的描述正确的是：___</h4><pre><code>A: 数组的length既可以获取，也可以修改。\n\nB: 调用pop()方法，不会修改原数组中的值。\n\nC: shift()方法的返回值是新数组的长度。    \n\nD: 调用concat() 方法，会修改原数组的值。\n</code></pre><h4 id=\"27-下面事件中，不会产生冒泡的是：\"><a href=\"#27-下面事件中，不会产生冒泡的是：\" class=\"headerlink\" title=\"27. 下面事件中，不会产生冒泡的是：___\"></a>27. 下面事件中，不会产生冒泡的是：___</h4><pre><code>A: mouseover\n\nB: keydown\n\nC: focus\n\nD: click\n</code></pre><h4 id=\"28-可以通过下面那种方式阻止事件的默认行为：\"><a href=\"#28-可以通过下面那种方式阻止事件的默认行为：\" class=\"headerlink\" title=\"28. 可以通过下面那种方式阻止事件的默认行为：___\"></a>28. 可以通过下面那种方式阻止事件的默认行为：___</h4><pre><code>A: ev.preventDefault()\n\nB: ev.cancelBubble = true\n\nC: ev.stopPropagation()\n\nD: return true;             \n</code></pre><h4 id=\"29-下面那个DOM-方法可以用来创建一个新的DOM-元素：\"><a href=\"#29-下面那个DOM-方法可以用来创建一个新的DOM-元素：\" class=\"headerlink\" title=\"29. 下面那个DOM 方法可以用来创建一个新的DOM 元素：___\"></a>29. 下面那个DOM 方法可以用来创建一个新的DOM 元素：___</h4><pre><code>A: appendChild()\n\nB: insertBefore()\n\nC: createElement()\n\nD: createTextNode()\n</code></pre><h4 id=\"30-当浏览器窗口发生尺寸变化时，会触发下面那个事件：\"><a href=\"#30-当浏览器窗口发生尺寸变化时，会触发下面那个事件：\" class=\"headerlink\" title=\"30. 当浏览器窗口发生尺寸变化时，会触发下面那个事件：___\"></a>30. 当浏览器窗口发生尺寸变化时，会触发下面那个事件：___</h4><pre><code>A: onscroll\n\nB: onresize\n\nC: onload\n\nD: onerror\n</code></pre><h4 id=\"31-如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：\"><a href=\"#31-如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：\" class=\"headerlink\" title=\"31. 如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：___\"></a>31. 如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：___</h4><pre><code>A: offsetWidth\n\nB: clientWidth\n\nC: scrollWidth\n\nD: innerWidth\n</code></pre><h4 id=\"32-下面JS的两个定时器描述正确的是：\"><a href=\"#32-下面JS的两个定时器描述正确的是：\" class=\"headerlink\" title=\"32. 下面JS的两个定时器描述正确的是：___\"></a>32. 下面JS的两个定时器描述正确的是：___</h4><pre><code>A: setInertval() 只会在延迟一段时间之后执行一次指定得代码\n\nB: setTimeout() 可以在每间隔一段时间之后就执行一次指定的代码\n\nC: 定时器内部的this ，在非严格模式下默认为window对象\n\nD: 定时器在执行过程中，会阻塞下面的执行\n</code></pre><h4 id=\"33-通过下面哪一个BOM-对象可以获取浏览器地址栏相关信息\"><a href=\"#33-通过下面哪一个BOM-对象可以获取浏览器地址栏相关信息\" class=\"headerlink\" title=\"33. 通过下面哪一个BOM 对象可以获取浏览器地址栏相关信息:___\"></a>33. 通过下面哪一个BOM 对象可以获取浏览器地址栏相关信息:___</h4><pre><code>A: location\n\nB: history\n\nC: window\n\nD: navigator\n</code></pre><h4 id=\"34-事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：\"><a href=\"#34-事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：\" class=\"headerlink\" title=\"34. 事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：___\"></a>34. 事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：___</h4><pre><code>A: clientX\n\nB: pageX\n\nC: offsetX\n\nD: screenX\n</code></pre><h4 id=\"35-cookie的默认什么时候失效：\"><a href=\"#35-cookie的默认什么时候失效：\" class=\"headerlink\" title=\"35. cookie的默认什么时候失效：___\"></a>35. cookie的默认什么时候失效：___</h4><pre><code>A: 浏览器窗口关闭\n\nB: 一个小时之后\n\nC: 计算机关机\n\nD: 切换到其他浏览器标签页    \n</code></pre><h4 id=\"36-下面那个不属于正则表达式的元字符\"><a href=\"#36-下面那个不属于正则表达式的元字符\" class=\"headerlink\" title=\"36. 下面那个不属于正则表达式的元字符:___\"></a>36. 下面那个不属于正则表达式的元字符:___</h4><pre><code>A: \\w\nB: \\a\nC: \\D\nD: \\s\n</code></pre><h4 id=\"37-下面那个方法的参数不支持正则表达式：\"><a href=\"#37-下面那个方法的参数不支持正则表达式：\" class=\"headerlink\" title=\"37. 下面那个方法的参数不支持正则表达式：___\"></a>37. 下面那个方法的参数不支持正则表达式：___</h4><pre><code>A: replace()\n\nB: split()\n\nC: search()\n\nD: slice()    \n</code></pre><h4 id=\"38-关于Date-对象的参数，-下面那个中写法有兼容问题：\"><a href=\"#38-关于Date-对象的参数，-下面那个中写法有兼容问题：\" class=\"headerlink\" title=\"38. 关于Date() 对象的参数， 下面那个中写法有兼容问题：___\"></a>38. 关于Date() 对象的参数， 下面那个中写法有兼容问题：___</h4><pre><code>A: new Date(2016,4,23)\n\nB: new Date(123453543565)\n\nC: new Date(&apos;jun 23,2016&apos;)\n\nD: new Date(&apos;6 23,2016&apos;)\n</code></pre><h4 id=\"39-下面描述中，说法不正确的是：\"><a href=\"#39-下面描述中，说法不正确的是：\" class=\"headerlink\" title=\"39. 下面描述中，说法不正确的是：___\"></a>39. 下面描述中，说法不正确的是：___</h4><pre><code>A: 事件对象只有在触发时间的时候才会保存信息 \n\nB: 正则的g修饰符表示进行全局匹配\n\nC: 对象的实行名称可以为字符串类型的数字\n\nD: click 事件没有冒泡行为\n</code></pre><h4 id=\"40-瀑布流没有使用下面的哪一个知识点：\"><a href=\"#40-瀑布流没有使用下面的哪一个知识点：\" class=\"headerlink\" title=\"40. 瀑布流没有使用下面的哪一个知识点：___\"></a>40. 瀑布流没有使用下面的哪一个知识点：___</h4><pre><code>A: 图片延迟加载\n\nB: Image() 对象\n\nC: scrollTop\n\nD: ev.clientX\n</code></pre><h4 id=\"41-关于正则的量词，下面说法不正确的是：\"><a href=\"#41-关于正则的量词，下面说法不正确的是：\" class=\"headerlink\" title=\"41. 关于正则的量词，下面说法不正确的是：___\"></a>41. 关于正则的量词，下面说法不正确的是：___</h4><pre><code>A: *表示匹配到0到多少个值\n\nB: +表示匹配0到多少个值\n\nC: {m,}表示最少匹配m个，最多不限\n\nD: {m,n}表示匹配至少m个，最多n个\n</code></pre><h4 id=\"42-下面那个不属于JQuery库中的方法：\"><a href=\"#42-下面那个不属于JQuery库中的方法：\" class=\"headerlink\" title=\"42. 下面那个不属于JQuery库中的方法：___\"></a>42. 下面那个不属于JQuery库中的方法：___</h4><pre><code>A: CSS()\n\nB: animate()\n\nC: getComputedStyle()\n\nD: attr()\n</code></pre><h4 id=\"43-JQuery-中如何获取一个div元素的内容：\"><a href=\"#43-JQuery-中如何获取一个div元素的内容：\" class=\"headerlink\" title=\"43. JQuery 中如何获取一个div元素的内容：___\"></a>43. JQuery 中如何获取一个div元素的内容：___</h4><pre><code>A: $(&apos;div&apos;).innerHTML\n\nB: $(&apos;div&apos;).val()\n\nC: $(&apos;div&apos;).html\n\nD: $(&apos;div&apos;).html()\n</code></pre><h4 id=\"44-下面那个不是事件对象中的属性：\"><a href=\"#44-下面那个不是事件对象中的属性：\" class=\"headerlink\" title=\"44. 下面那个不是事件对象中的属性：___\"></a>44. 下面那个不是事件对象中的属性：___</h4><pre><code>A: keyCode\n\nB: ClientX\n\nC: offsetLeft\n\nD: detail\n</code></pre><h4 id=\"45-下面哪一个属性可以查看一个实例对象的构造函数：\"><a href=\"#45-下面哪一个属性可以查看一个实例对象的构造函数：\" class=\"headerlink\" title=\"45. 下面哪一个属性可以查看一个实例对象的构造函数：___\"></a>45. 下面哪一个属性可以查看一个实例对象的构造函数：___</h4><pre><code>A: prototype\n\nB: constructor\n\nC: instanceof\n\nD: typeof\n</code></pre><h4 id=\"46-下面说法错误的是：\"><a href=\"#46-下面说法错误的是：\" class=\"headerlink\" title=\"46. 下面说法错误的是：___\"></a>46. 下面说法错误的是：___</h4><pre><code>A: return 关键字只能放在函数内部使用\n\nB: 逻辑运算符返回的结果一定是一个布尔值\n\nC: 关系运算符返回的结果一定是一个布尔值\n\nD: 字符串使用字符编码来比较大小\n</code></pre><h4 id=\"47-下面那个时间不属于一定设备上的手势事件：\"><a href=\"#47-下面那个时间不属于一定设备上的手势事件：\" class=\"headerlink\" title=\"47. 下面那个时间不属于一定设备上的手势事件：___\"></a>47. 下面那个时间不属于一定设备上的手势事件：___</h4><pre><code>A: touchstart\n\nB: touchmove\n\nC: tap\n\nD: touchend\n</code></pre><h4 id=\"48-通过addEventListener-方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：\"><a href=\"#48-通过addEventListener-方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：\" class=\"headerlink\" title=\"48. 通过addEventListener()方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：___\"></a>48. 通过addEventListener()方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：___</h4><pre><code>A: 正确\n\nB: 错误\n</code></pre><h4 id=\"49-localstorage-中的数据只要用户不主动清除，将会一直保存在本地：\"><a href=\"#49-localstorage-中的数据只要用户不主动清除，将会一直保存在本地：\" class=\"headerlink\" title=\"49. localstorage 中的数据只要用户不主动清除，将会一直保存在本地：___\"></a>49. localstorage 中的数据只要用户不主动清除，将会一直保存在本地：___</h4><pre><code>A: 正确\n\nB: 错误\n</code></pre><h4 id=\"50-下面描述中，说法正确的是：\"><a href=\"#50-下面描述中，说法正确的是：\" class=\"headerlink\" title=\"50. 下面描述中，说法正确的是：___\"></a>50. 下面描述中，说法正确的是：___</h4><pre><code>A: getComputeStyle()发发获取到的时行间的样式\n\nB: FireFox浏览器通过 mousewheel 来表示鼠标滚轮事件\n\nC: 通过Math.random() 方法可以或得一个0~1之间的随机数字\n\nD: split() 是一个数组方法\n</code></pre><h2 id=\"二、-简答题\"><a href=\"#二、-简答题\" class=\"headerlink\" title=\"二、    简答题\"></a>二、    简答题</h2><ol>\n<li>要在canvas上绘制内容需要获取什么才能对画布进行操作，并写出基本图形绘制可以能用到的几步(例如一条线的额绘制需要怎么来实现，都需要设置什么？)    2. </li>\n<li>请写出绘制矩形常用的2种方法，并说说他们的不同点。</li>\n<li>写出绘制圆形的方法，并说明每个参数的意义，我需要顺时针画弧要设置第几个属性，值为什么？</li>\n<li>平移、旋转、缩放他们的共同特点是什么？如果我希望在进行一个旋转操作后画壁回到初始状态该怎么办？用代码阐述，并说说你对此的看法和理解。</li>\n<li>绘制图片的方法有三种形式请分别写出并介绍每个参数(在一个图片正常的操作流程的实现)。</li>\n<li><p>我们要操作一张图片需要获取这张图片的像素点，使用getlmageData()这个方法得到的对象中哪个属性使我们需要进行操作的，要操作的属性他的数据类型是什么？</p>\n<p> 如果有能帮到大家的地方，希望大家给予点亮收藏并喜欢❤️！！谢谢</p>\n</li>\n</ol>\n<p>文／原创/Dimple（github作者）<br>原文链接：<a href=\"https://cuidapao.github.io/\" target=\"_blank\" rel=\"external\">https://cuidapao.github.io/</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“github作者”。</p>\n","excerpt":"","more":"<h4 id=\"1-下面的值中那个不属于JS的基本类型\"><a href=\"#1-下面的值中那个不属于JS的基本类型\" class=\"headerlink\" title=\"1. 下面的值中那个不属于JS的基本类型\"></a>1. 下面的值中那个不属于JS的基本类型</h4><pre><code>A: &apos;abcd&apos;\n\nB: 1234 \n\nC: [&apos;1234&apos;]\n\nD: null\n</code></pre><h4 id=\"2-下面对数组的描述中，说法不正确的是：\"><a href=\"#2-下面对数组的描述中，说法不正确的是：\" class=\"headerlink\" title=\"2. 下面对数组的描述中，说法不正确的是：\"></a>2. 下面对数组的描述中，说法不正确的是：</h4><pre><code>A： 素组是一组属性名和属性的有序集合\n\nB: 素组的length属性既可以获取，也可以被修改\n\nC: 使用push()方法给数组添加值 ，会直接修改原数组\n\nD: shift()的返回值是数组的长度\n</code></pre><h4 id=\"3-下面的等式不成立的是：\"><a href=\"#3-下面的等式不成立的是：\" class=\"headerlink\" title=\"3. 下面的等式不成立的是：\"></a>3. 下面的等式不成立的是：</h4><pre><code>A: 1 == true\n\nB: null == undefined\n\nC: &apos;0&apos; == false\n\nD: isNaN(true) == false\n</code></pre><h4 id=\"4-任何类型的值与字符串相加，都是在做字符串拼接。\"><a href=\"#4-任何类型的值与字符串相加，都是在做字符串拼接。\" class=\"headerlink\" title=\"4. 任何类型的值与字符串相加，都是在做字符串拼接。\"></a>4. 任何类型的值与字符串相加，都是在做字符串拼接。</h4><pre><code>A: 正确 \n\nB: 错误\n</code></pre><h4 id=\"5-下面哪个值为真值：\"><a href=\"#5-下面哪个值为真值：\" class=\"headerlink\" title=\"5. 下面哪个值为真值：\"></a>5. 下面哪个值为真值：</h4><pre><code>A: 0\n\nB: undefined\n\nC: []\n\nD: false\n</code></pre><h4 id=\"6-下面代码的执行结果是：\"><a href=\"#6-下面代码的执行结果是：\" class=\"headerlink\" title=\"6. 下面代码的执行结果是：\"></a>6. 下面代码的执行结果是：</h4><pre><code>for(var i = 0; i&lt;=5){\n\n++i;\n\n}\nalert(i);\n</code></pre><h4 id=\"7-下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：\"><a href=\"#7-下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：\" class=\"headerlink\" title=\"7. 下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：__\"></a>7. 下面代码片段中，一次点击1、2、3、4、5，会对应弹出0、1、2、3、4：<em>__</em></h4><pre><code>&lt;ul&gt;\n    &lt;li&gt;1&lt;/Li&gt;    \n    &lt;li&gt;2&lt;/Li&gt;    \n    &lt;li&gt;3&lt;/Li&gt;    \n    &lt;li&gt;4&lt;/Li&gt;    \n    &lt;li&gt;5&lt;/Li&gt;    \n&lt;/ul&gt;\n\n&lt;script&gt;\n    var aLi = document.getElementsByTagName(&quot;li&quot;);\n    for(var i = 0;i &lt; aLi.lenght;i++){\n        aLi[i].onclick = function(){\n            alert(i);\n        }\n    }\n&lt;/script&gt;\n\nA: 正确\n\nB: 错误\n</code></pre><h4 id=\"8-执行下面的代码片段，会弹出div的内容”这是一个div”，\"><a href=\"#8-执行下面的代码片段，会弹出div的内容”这是一个div”，\" class=\"headerlink\" title=\"8. 执行下面的代码片段，会弹出div的内容”这是一个div”，__\"></a>8. 执行下面的代码片段，会弹出div的内容”这是一个div”，<em>__</em></h4><pre><code>&lt;div id=&quot;div&quot;&gt;这是一个div&lt;/div&gt;\n\n&lt;script&gt;\n\n    var oDiv = document.getElementsByTagName(&quot;div&quot;);\n\n        alert(oDiv.innerHTML);\n\n&lt;/script&gt; \n\nA: 正确\n\nB: 错误\n</code></pre><h4 id=\"9-通过arr-1-可以获取到下面数组中的1\"><a href=\"#9-通过arr-1-可以获取到下面数组中的1\" class=\"headerlink\" title=\"9. 通过arr[1]可以获取到下面数组中的1.__\"></a>9. 通过arr[1]可以获取到下面数组中的1.<em>__</em></h4><pre><code>var arr = [1,2,3,4];\n\nA: 正确\n\nB: 错误\n</code></pre><h4 id=\"10-下面的代码中编写中，正确的是：\"><a href=\"#10-下面的代码中编写中，正确的是：\" class=\"headerlink\" title=\"10. 下面的代码中编写中，正确的是：__\"></a>10. 下面的代码中编写中，正确的是：<em>__</em></h4><pre><code>A: var aLi = document.getElementsByTagName(&quot;li&quot;);\n\n    aLi.innerHTML = &apos;今天天气真好啊&apos;;\n\nB: var oDiv1 = document.getElementById(&quot;div1&quot;);\n\n    var oDiv2 = document.getElementById(&quot;div2&quot;);\n\nC: var oImg = document.getElementById(&apos;pic&apos;);\n\n    if(oImg.src == &quot;1.jpg&quot;){\n\n        oImg.src = &quot;2.jpg&quot;;\n\n    }\n\nD: var oUl = document.getElementById(&quot;ul1&quot;);\n\n    oUl.className = &quot;active&quot;;\n</code></pre><h4 id=\"11-下面代码的运行结果是：\"><a href=\"#11-下面代码的运行结果是：\" class=\"headerlink\" title=\"11. 下面代码的运行结果是：_\"></a>11. 下面代码的运行结果是：<strong>_</strong></h4><pre><code>var a = 20;\n\n    alert(!a);\n\nA: -20\n\nB: undefined\n\nC: true\n\nD: false\n</code></pre><h4 id=\"12-下面代码的运行结果是：\"><a href=\"#12-下面代码的运行结果是：\" class=\"headerlink\" title=\"12.    下面代码的运行结果是：___\"></a>12.    下面代码的运行结果是：___</h4><pre><code>function fn1(){\n\n    alert(1);\n\n    }    \n\n    alert(fn1);\n\n     A: 1\n\n    B: undefined\n\n    C: function fn1(){\n\n            alert(1);\n\n        }\n\n    D: alert(1)\n</code></pre><h4 id=\"13-以下代码的运行结果是：\"><a href=\"#13-以下代码的运行结果是：\" class=\"headerlink\" title=\"13. 以下代码的运行结果是：__\"></a>13. 以下代码的运行结果是：<em>__</em></h4><pre><code>var i = 0;\n\n    alert( ++i == i++ );\n\n\nA: true\n\nB: false\n\nC: undefined\n\nD: NaN\n</code></pre><h4 id=\"14-下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行\"><a href=\"#14-下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行\" class=\"headerlink\" title=\"14. 下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行:__\"></a>14. 下面代码中，在定时器没有关闭之前，下面的匿名函数不会被执行:<em>__</em></h4><pre><code>var timer = null;\n\nvar i = 0;\n\ntimer = setInertvar(function(){\n\n    i++;\n\n    alert(i);\n\n    if(i == 10){\n\n     alert(&quot;定时器被关闭了。&quot;);\n\n     clearInterval(timer);             \n\n    }            \n\n},1000)    \n\n(function(){\n\n    alert(&quot;我是一个函数。&quot;)\n\n})    \n\n（）;\n\nA: 正确\n\nB: 错误    \n</code></pre><h4 id=\"15-下面的等式成立的是：\"><a href=\"#15-下面的等式成立的是：\" class=\"headerlink\" title=\"15. 下面的等式成立的是：_\"></a>15. 下面的等式成立的是：<strong>_</strong></h4><pre><code>A: parseInt(12.5) == paeseFloat(12.5)\n\nB: Number(&quot;&quot;) == parseFloat(&quot;&quot;);\n\nC: isNaN(&quot;abc&quot;) == NaN\n\nD: typeof NaN === &quot;number&quot;    \n</code></pre><h4 id=\"16-下面描述中正确的是：\"><a href=\"#16-下面描述中正确的是：\" class=\"headerlink\" title=\"16. 下面描述中正确的是：___\"></a>16. 下面描述中正确的是：___</h4><pre><code>A: &apos;==&apos;在比较过程中，不但会比较两边的值，韩慧比较两边的数据类型\n\nB: &apos;===&apos;在比较过程中，如果有必要，会进行数据类型转换\n\nC: 任何类型的值，使用！进行转换后，结果一定是一个布尔值\n\nD: NaN == NaN 的结果是true;        \n</code></pre><h4 id=\"17-下面的描述中不正确的是\"><a href=\"#17-下面的描述中不正确的是\" class=\"headerlink\" title=\"17. 下面的描述中不正确的是:__\"></a>17. 下面的描述中不正确的是:<em>__</em></h4><pre><code>A: arguments 中保存了世纪传入函数内的所有参数\n\nB: return 只能在函数内部使用\n\nC: setInterval(fn1,1000)只会调用一次 fn1\n\nD: Date 对象的getMonth()获取到的值比实际月份小1；\n</code></pre><h4 id=\"18-以下代码中，会出现什么结果\"><a href=\"#18-以下代码中，会出现什么结果\" class=\"headerlink\" title=\"18. 以下代码中，会出现什么结果___\"></a>18. 以下代码中，会出现什么结果___</h4><pre><code>var i = 0;\n\nwhite(i &lt; 6){\n\n    if(i == 4){\n\n        continue;\n\n    }\n\n    i++;\n\n}\n\nalert(i);\n\n\nA: 6\n\nB: 4\n\nC: 5\n\nD: 死循环        \n</code></pre><h4 id=\"19-以下代码中，会出现什么结果：\"><a href=\"#19-以下代码中，会出现什么结果：\" class=\"headerlink\" title=\"19. 以下代码中，会出现什么结果：__\"></a>19. 以下代码中，会出现什么结果：<em>__</em></h4><pre><code>function fn1(){\n\n    var a = 0;\n\n    function fn2(){\n\n        a++;\n\n        alert(a);\n\n    }\n\n    return fn2;\n\n}\n\nfn1()();\nfn1()();    \n\nA: 第一次弹1,第二次弹2\n\nB: 第一次弹1,第二次弹1        \n</code></pre><h4 id=\"20-以下代码中，会出现什么结果：\"><a href=\"#20-以下代码中，会出现什么结果：\" class=\"headerlink\" title=\"20. 以下代码中，会出现什么结果：___\"></a>20. 以下代码中，会出现什么结果：___</h4><pre><code>fn1(10);\n\nfunction fn1(a){\n\n    alert(a === arguments[0]);\n\n}\n\nA: true\n\nB: false\n</code></pre><h4 id=\"21-alert-“12”-gt-”9”-的运行结果正确的是：\"><a href=\"#21-alert-“12”-gt-”9”-的运行结果正确的是：\" class=\"headerlink\" title=\"21. alert(“12”&gt;”9”)的运行结果正确的是：__\"></a>21. alert(“12”&gt;”9”)的运行结果正确的是：<em>__</em></h4><pre><code>A: true\n\nB: false\n</code></pre><h4 id=\"22-1-2-3-4-join-“0”-split-“”-的执行结果是\"><a href=\"#22-1-2-3-4-join-“0”-split-“”-的执行结果是\" class=\"headerlink\" title=\"22. [1,2,3,4].join(“0”).split(“”)的执行结果是:__\"></a>22. [1,2,3,4].join(“0”).split(“”)的执行结果是:<em>__</em></h4><pre><code>A: &apos;1,2,3,4&apos;\n\nB: [1,2,3,4]\n\nC: [1,0,2,0,3,0,4]\n\nD: &apos;1,0,2,0,3,0,4&apos;    \n</code></pre><h4 id=\"23-下面对substring-方法描述不正确的是：\"><a href=\"#23-下面对substring-方法描述不正确的是：\" class=\"headerlink\" title=\"23. 下面对substring()方法描述不正确的是：___\"></a>23. 下面对substring()方法描述不正确的是：___</h4><pre><code>A: 一共有两个参数，胜率第一个参数表示从开始位置提取到字符串结束。\n\nB: 提取之前会比较两个参数的大小，并根据大小调整位置。\n\nC: 可以接受负数参数，负数表示从欧往前数字符位置。\n\nD: 如果没有设置参数，直接返回整个字符串。\n</code></pre><h4 id=\"24-charCodeAt-方法可以把一个字符串编码转换成指定的字符\"><a href=\"#24-charCodeAt-方法可以把一个字符串编码转换成指定的字符\" class=\"headerlink\" title=\"24. charCodeAt() 方法可以把一个字符串编码转换成指定的字符___\"></a>24. charCodeAt() 方法可以把一个字符串编码转换成指定的字符___</h4><pre><code>A: 正确\n\nB: 错误\n</code></pre><h4 id=\"25-调用indexOf-方法会返回指定字符串在字符串中出现的所在位置：\"><a href=\"#25-调用indexOf-方法会返回指定字符串在字符串中出现的所在位置：\" class=\"headerlink\" title=\"25. 调用indexOf() 方法会返回指定字符串在字符串中出现的所在位置：___\"></a>25. 调用indexOf() 方法会返回指定字符串在字符串中出现的所在位置：___</h4><pre><code>A: 正确\n\nB: 错误\n</code></pre><h4 id=\"26-下面股阿奴数组的描述正确的是：\"><a href=\"#26-下面股阿奴数组的描述正确的是：\" class=\"headerlink\" title=\"26. 下面股阿奴数组的描述正确的是：___\"></a>26. 下面股阿奴数组的描述正确的是：___</h4><pre><code>A: 数组的length既可以获取，也可以修改。\n\nB: 调用pop()方法，不会修改原数组中的值。\n\nC: shift()方法的返回值是新数组的长度。    \n\nD: 调用concat() 方法，会修改原数组的值。\n</code></pre><h4 id=\"27-下面事件中，不会产生冒泡的是：\"><a href=\"#27-下面事件中，不会产生冒泡的是：\" class=\"headerlink\" title=\"27. 下面事件中，不会产生冒泡的是：___\"></a>27. 下面事件中，不会产生冒泡的是：___</h4><pre><code>A: mouseover\n\nB: keydown\n\nC: focus\n\nD: click\n</code></pre><h4 id=\"28-可以通过下面那种方式阻止事件的默认行为：\"><a href=\"#28-可以通过下面那种方式阻止事件的默认行为：\" class=\"headerlink\" title=\"28. 可以通过下面那种方式阻止事件的默认行为：___\"></a>28. 可以通过下面那种方式阻止事件的默认行为：___</h4><pre><code>A: ev.preventDefault()\n\nB: ev.cancelBubble = true\n\nC: ev.stopPropagation()\n\nD: return true;             \n</code></pre><h4 id=\"29-下面那个DOM-方法可以用来创建一个新的DOM-元素：\"><a href=\"#29-下面那个DOM-方法可以用来创建一个新的DOM-元素：\" class=\"headerlink\" title=\"29. 下面那个DOM 方法可以用来创建一个新的DOM 元素：___\"></a>29. 下面那个DOM 方法可以用来创建一个新的DOM 元素：___</h4><pre><code>A: appendChild()\n\nB: insertBefore()\n\nC: createElement()\n\nD: createTextNode()\n</code></pre><h4 id=\"30-当浏览器窗口发生尺寸变化时，会触发下面那个事件：\"><a href=\"#30-当浏览器窗口发生尺寸变化时，会触发下面那个事件：\" class=\"headerlink\" title=\"30. 当浏览器窗口发生尺寸变化时，会触发下面那个事件：___\"></a>30. 当浏览器窗口发生尺寸变化时，会触发下面那个事件：___</h4><pre><code>A: onscroll\n\nB: onresize\n\nC: onload\n\nD: onerror\n</code></pre><h4 id=\"31-如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：\"><a href=\"#31-如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：\" class=\"headerlink\" title=\"31. 如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：___\"></a>31. 如果要获取一个元素包含边框和内填充的宽度值，应该使用下面的哪一个属性：___</h4><pre><code>A: offsetWidth\n\nB: clientWidth\n\nC: scrollWidth\n\nD: innerWidth\n</code></pre><h4 id=\"32-下面JS的两个定时器描述正确的是：\"><a href=\"#32-下面JS的两个定时器描述正确的是：\" class=\"headerlink\" title=\"32. 下面JS的两个定时器描述正确的是：___\"></a>32. 下面JS的两个定时器描述正确的是：___</h4><pre><code>A: setInertval() 只会在延迟一段时间之后执行一次指定得代码\n\nB: setTimeout() 可以在每间隔一段时间之后就执行一次指定的代码\n\nC: 定时器内部的this ，在非严格模式下默认为window对象\n\nD: 定时器在执行过程中，会阻塞下面的执行\n</code></pre><h4 id=\"33-通过下面哪一个BOM-对象可以获取浏览器地址栏相关信息\"><a href=\"#33-通过下面哪一个BOM-对象可以获取浏览器地址栏相关信息\" class=\"headerlink\" title=\"33. 通过下面哪一个BOM 对象可以获取浏览器地址栏相关信息:___\"></a>33. 通过下面哪一个BOM 对象可以获取浏览器地址栏相关信息:___</h4><pre><code>A: location\n\nB: history\n\nC: window\n\nD: navigator\n</code></pre><h4 id=\"34-事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：\"><a href=\"#34-事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：\" class=\"headerlink\" title=\"34. 事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：___\"></a>34. 事件对象中的哪一个属性可以获取鼠标距离浏览器窗口左边的距离：___</h4><pre><code>A: clientX\n\nB: pageX\n\nC: offsetX\n\nD: screenX\n</code></pre><h4 id=\"35-cookie的默认什么时候失效：\"><a href=\"#35-cookie的默认什么时候失效：\" class=\"headerlink\" title=\"35. cookie的默认什么时候失效：___\"></a>35. cookie的默认什么时候失效：___</h4><pre><code>A: 浏览器窗口关闭\n\nB: 一个小时之后\n\nC: 计算机关机\n\nD: 切换到其他浏览器标签页    \n</code></pre><h4 id=\"36-下面那个不属于正则表达式的元字符\"><a href=\"#36-下面那个不属于正则表达式的元字符\" class=\"headerlink\" title=\"36. 下面那个不属于正则表达式的元字符:___\"></a>36. 下面那个不属于正则表达式的元字符:___</h4><pre><code>A: \\w\nB: \\a\nC: \\D\nD: \\s\n</code></pre><h4 id=\"37-下面那个方法的参数不支持正则表达式：\"><a href=\"#37-下面那个方法的参数不支持正则表达式：\" class=\"headerlink\" title=\"37. 下面那个方法的参数不支持正则表达式：___\"></a>37. 下面那个方法的参数不支持正则表达式：___</h4><pre><code>A: replace()\n\nB: split()\n\nC: search()\n\nD: slice()    \n</code></pre><h4 id=\"38-关于Date-对象的参数，-下面那个中写法有兼容问题：\"><a href=\"#38-关于Date-对象的参数，-下面那个中写法有兼容问题：\" class=\"headerlink\" title=\"38. 关于Date() 对象的参数， 下面那个中写法有兼容问题：___\"></a>38. 关于Date() 对象的参数， 下面那个中写法有兼容问题：___</h4><pre><code>A: new Date(2016,4,23)\n\nB: new Date(123453543565)\n\nC: new Date(&apos;jun 23,2016&apos;)\n\nD: new Date(&apos;6 23,2016&apos;)\n</code></pre><h4 id=\"39-下面描述中，说法不正确的是：\"><a href=\"#39-下面描述中，说法不正确的是：\" class=\"headerlink\" title=\"39. 下面描述中，说法不正确的是：___\"></a>39. 下面描述中，说法不正确的是：___</h4><pre><code>A: 事件对象只有在触发时间的时候才会保存信息 \n\nB: 正则的g修饰符表示进行全局匹配\n\nC: 对象的实行名称可以为字符串类型的数字\n\nD: click 事件没有冒泡行为\n</code></pre><h4 id=\"40-瀑布流没有使用下面的哪一个知识点：\"><a href=\"#40-瀑布流没有使用下面的哪一个知识点：\" class=\"headerlink\" title=\"40. 瀑布流没有使用下面的哪一个知识点：___\"></a>40. 瀑布流没有使用下面的哪一个知识点：___</h4><pre><code>A: 图片延迟加载\n\nB: Image() 对象\n\nC: scrollTop\n\nD: ev.clientX\n</code></pre><h4 id=\"41-关于正则的量词，下面说法不正确的是：\"><a href=\"#41-关于正则的量词，下面说法不正确的是：\" class=\"headerlink\" title=\"41. 关于正则的量词，下面说法不正确的是：___\"></a>41. 关于正则的量词，下面说法不正确的是：___</h4><pre><code>A: *表示匹配到0到多少个值\n\nB: +表示匹配0到多少个值\n\nC: {m,}表示最少匹配m个，最多不限\n\nD: {m,n}表示匹配至少m个，最多n个\n</code></pre><h4 id=\"42-下面那个不属于JQuery库中的方法：\"><a href=\"#42-下面那个不属于JQuery库中的方法：\" class=\"headerlink\" title=\"42. 下面那个不属于JQuery库中的方法：___\"></a>42. 下面那个不属于JQuery库中的方法：___</h4><pre><code>A: CSS()\n\nB: animate()\n\nC: getComputedStyle()\n\nD: attr()\n</code></pre><h4 id=\"43-JQuery-中如何获取一个div元素的内容：\"><a href=\"#43-JQuery-中如何获取一个div元素的内容：\" class=\"headerlink\" title=\"43. JQuery 中如何获取一个div元素的内容：___\"></a>43. JQuery 中如何获取一个div元素的内容：___</h4><pre><code>A: $(&apos;div&apos;).innerHTML\n\nB: $(&apos;div&apos;).val()\n\nC: $(&apos;div&apos;).html\n\nD: $(&apos;div&apos;).html()\n</code></pre><h4 id=\"44-下面那个不是事件对象中的属性：\"><a href=\"#44-下面那个不是事件对象中的属性：\" class=\"headerlink\" title=\"44. 下面那个不是事件对象中的属性：___\"></a>44. 下面那个不是事件对象中的属性：___</h4><pre><code>A: keyCode\n\nB: ClientX\n\nC: offsetLeft\n\nD: detail\n</code></pre><h4 id=\"45-下面哪一个属性可以查看一个实例对象的构造函数：\"><a href=\"#45-下面哪一个属性可以查看一个实例对象的构造函数：\" class=\"headerlink\" title=\"45. 下面哪一个属性可以查看一个实例对象的构造函数：___\"></a>45. 下面哪一个属性可以查看一个实例对象的构造函数：___</h4><pre><code>A: prototype\n\nB: constructor\n\nC: instanceof\n\nD: typeof\n</code></pre><h4 id=\"46-下面说法错误的是：\"><a href=\"#46-下面说法错误的是：\" class=\"headerlink\" title=\"46. 下面说法错误的是：___\"></a>46. 下面说法错误的是：___</h4><pre><code>A: return 关键字只能放在函数内部使用\n\nB: 逻辑运算符返回的结果一定是一个布尔值\n\nC: 关系运算符返回的结果一定是一个布尔值\n\nD: 字符串使用字符编码来比较大小\n</code></pre><h4 id=\"47-下面那个时间不属于一定设备上的手势事件：\"><a href=\"#47-下面那个时间不属于一定设备上的手势事件：\" class=\"headerlink\" title=\"47. 下面那个时间不属于一定设备上的手势事件：___\"></a>47. 下面那个时间不属于一定设备上的手势事件：___</h4><pre><code>A: touchstart\n\nB: touchmove\n\nC: tap\n\nD: touchend\n</code></pre><h4 id=\"48-通过addEventListener-方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：\"><a href=\"#48-通过addEventListener-方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：\" class=\"headerlink\" title=\"48. 通过addEventListener()方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：___\"></a>48. 通过addEventListener()方法给一个元素的某个事件绑定一个匿名函数作为事件处理函数，这个匿名函数没有办法被注销：___</h4><pre><code>A: 正确\n\nB: 错误\n</code></pre><h4 id=\"49-localstorage-中的数据只要用户不主动清除，将会一直保存在本地：\"><a href=\"#49-localstorage-中的数据只要用户不主动清除，将会一直保存在本地：\" class=\"headerlink\" title=\"49. localstorage 中的数据只要用户不主动清除，将会一直保存在本地：___\"></a>49. localstorage 中的数据只要用户不主动清除，将会一直保存在本地：___</h4><pre><code>A: 正确\n\nB: 错误\n</code></pre><h4 id=\"50-下面描述中，说法正确的是：\"><a href=\"#50-下面描述中，说法正确的是：\" class=\"headerlink\" title=\"50. 下面描述中，说法正确的是：___\"></a>50. 下面描述中，说法正确的是：___</h4><pre><code>A: getComputeStyle()发发获取到的时行间的样式\n\nB: FireFox浏览器通过 mousewheel 来表示鼠标滚轮事件\n\nC: 通过Math.random() 方法可以或得一个0~1之间的随机数字\n\nD: split() 是一个数组方法\n</code></pre><h2 id=\"二、-简答题\"><a href=\"#二、-简答题\" class=\"headerlink\" title=\"二、    简答题\"></a>二、    简答题</h2><ol>\n<li>要在canvas上绘制内容需要获取什么才能对画布进行操作，并写出基本图形绘制可以能用到的几步(例如一条线的额绘制需要怎么来实现，都需要设置什么？)    2. </li>\n<li>请写出绘制矩形常用的2种方法，并说说他们的不同点。</li>\n<li>写出绘制圆形的方法，并说明每个参数的意义，我需要顺时针画弧要设置第几个属性，值为什么？</li>\n<li>平移、旋转、缩放他们的共同特点是什么？如果我希望在进行一个旋转操作后画壁回到初始状态该怎么办？用代码阐述，并说说你对此的看法和理解。</li>\n<li>绘制图片的方法有三种形式请分别写出并介绍每个参数(在一个图片正常的操作流程的实现)。</li>\n<li><p>我们要操作一张图片需要获取这张图片的像素点，使用getlmageData()这个方法得到的对象中哪个属性使我们需要进行操作的，要操作的属性他的数据类型是什么？</p>\n<p> 如果有能帮到大家的地方，希望大家给予点亮收藏并喜欢❤️！！谢谢</p>\n</li>\n</ol>\n<p>文／原创/Dimple（github作者）<br>原文链接：<a href=\"https://cuidapao.github.io/\">https://cuidapao.github.io/</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“github作者”。</p>\n"},{"title":"基于vue直播播放器实战","date":"2016-07-20T02:42:11.000Z","_content":"\n#\t基于 Vue 的直播播放器实战\n\n![Mou icon](http://7xr2s7.com1.z0.glb.clouddn.com/%E5%9F%BA%E4%BA%8E%20Vue%20%E7%9A%84%E7%9B%B4%E6%92%AD%E6%92%AD%E6%94%BE%E5%99%A8%E5%AE%9E%E6%88%98.jpeg)\n## <font style=\"color:red\"> --前言-- </font>\n\n#### 时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple 本人也不例外，本文借着实战的目的完成一个 demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！\n\n#### 直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话 Dimple 只用过七牛云直播，没办法拿数据给大家建议\n\n#### 七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上[ <font style=\"color:blue\">《JavaScript闯关记》</font> ](http://developer.qiniu.com/article/index.html#pili/),其次看 [<font style=\"color:blue\">github 上的库</font>](https://github.com/pili-engineering)\n\n#### 整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个[<font style=\"color:blue\">斗鱼的 OBS 教程</font>](https://www.douyu.com/cms/zhibo/201311/13/250.shtml)\n\n\n\n\t注：以上的直播空间的搭建没有完成也可以看本文，更希望大家可以做成一个完整的 demo，我们的重点还是在于播放器的实现。\n\t\n## <font style=\"color:red\"> --直播协议-- </font>\n\n#### 首先，需要知道直播的常用协议，RTMP 和 HLS，经过测试在七牛云直播平台不采用加速的情况下 RTMP 的延时在 10s 内，HLS 在 10-20s。经过优化后的还没测试过。\n\n#### 至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接[<font style=\"blue\">直播协议的选择：RTMP vs. HLS</font>](http://www.samirchen.com/ios-rtmp-vs-hls/)\n\n## <font style=\"color:red\"> --Vue 结合-- </font>\n\n#### 做过 H5 播放器的对与 video.js 并不陌生，实现的出发点也是在 video.js 上，默认大家都有 Vue 搭建和简单运用能力了，没有经验的可以看 orange 之前写的入门文章。\n\n首先我们要新建一个组件，这个组件就是播放器的组件，组件名随意，最初的想法是直接使用 video.js，但是踩的坑比较深所以不推荐直接使用。\n\n\t坑：首次载入不会有问题，路由跳转后再回来如果不刷新页面，import 进来的 videojs 并不会执行，所以需要在 mounted 里执行 videojs() 函数，然后传对应的参数进去，最后需要加入下面代码防止监听函数在切换路由后继续执行。\n#### 坑也踩完了，于是逛了一圈 github，发现了一个项目叫 vue-video-player\n\n#### 先安装依赖\n\n\tnpm install vue-video-player --save\n\t\n#### 引用依赖\n\n\n\t// import with ES6\n\timport Vue from 'vue'\n\t...\n\timport VideoPlayer from 'vue-video-player'\n\n\n\t// require with Node.js/Webpack\n\tvar Vue = require('vue')\n\t...\n\tvar VideoPlayer = require('vue-video-player')\n\n\t// The default is to turn off some of the features, you can choose according to their use of certain \tfeatures enabled, do not enable the introduction will not require the corresponding file. 默认有些功能\t是不开启的，比如youtube国内不能用，则默认是关闭的，如果不启用对应的功能，则不会引入对应的包，减少项目代码体积，当然也有\t可能意味着对应的功能可能会出错，true 是开启，false是关闭，正常情况使用者不需要care就可以。\n\n\t// Example(Only applies to the current global mode). 用配置项的话仅支持全局模式来配置，否则不会生效\n\tVideoPlayer.config({\n \t youtube: true, // default false\n\t  switcher: false, // default true\n\t  hls: false // default true\n\t})\n\n\t// use\n\tVue.use(VideoPlayer)\n\n\t// --------------------------------------\n\n\t// or use with component(ES6)\n\timport Vue from 'vue'\n\t// ...\n\timport { videoPlayer } from 'vue-video-player'\n\n\t// use\n\texport default {\n  \tcomponents: {\n    \tvideoPlayer\n  \t}\n\t}\n\t\n#### HLS\n\n\n#### 这里默认给出了 HLS 的方案，我们先去全局引入，到 main.js\t\t\n\n\timport VideoPlayer from 'vue-video-player';\n\n\tVideoPlayer.config({\n \t youtube: true,\n \t switcher: true,\n \t hls: true\n\t})\n\n\tVue.use(VideoPlayer)\n\n#### 下面看下我的 component\n\n\n\t<template>\n  \t\t<video-player :options=\"videoOptions\"></video-player>\n\t</template>\n\n\t<script>\n\texport default {\n  \tname: 'Play',\n \t data () {\n \t   return {\n  \t    videoOptions: {\n     \t   source: {\n      \t    type: \"application/x-mpegURL\",\n       \t   src: 'https://logos-channel.scaleengine.net/logos-channel/live/biblescreen-ad-free/\tplaylist.m3u8',\n      \t    withCredentials: false\n    \t    },\n    \t    language: 'zh-CN',\n    \t    live: true,\n    \t    autoplay: true,\n    \t    height: 540\n      \t\t}\n   \t\t  }\n  \t\t}\n\t }\n\t</script>\n\t\n#### 到这里你的播放器就可以播放 HLS 链接了\t\n\n\n#### RTMP \n\n\n#### 上面说到库底层还是依赖 video.js， 所以呢我们不妨直接这样使用\n\n\n\texport default {\n \t\t name: 'Play',\n  \t\t data () {\n    \t\treturn {\n      \t\t videoOptions: {\n        \t   source: {\n         \t\t type: \"rtmp/mp4\",\n          \t\t src: 'rtmp://your.streaming.provider.net/cfx/st/&mp4:path/to/video.mp4',\n            \t withCredentials: false\n       \t\t },\n        \t\tlanguage: 'zh-CN',\n        \t\tlive: true,\n        \t\tautoplay: true,\n        \t\theight: 540\n      \t\t}\n    \t }\n  \t  }\n\t}\n## <font style=\"color:red\"> --总结-- </font>\n\n#### 两种方法均可尝试，上面给出的 src 换成自己的链接就实现拉流播放啦，当然你如果不用 vue 的话也没关系，直接参照 video.js 的官网，单是 RTMP 的话不需要第三方库，如果是 HLS 的话需要引入[<font style=\"color:blue\">videojs-contrib-hls</font>](https://github.com/videojs/videojs-contrib-hls)，看具体情况而定。\n\n🔗原文链接: [http://orangexc.xyz/2016/11/14/Live-video-player/](http://orangexc.xyz/2016/11/14/Live-video-player/) by @Orange","source":"_posts/基于 Vue 的直播播放器实战.md","raw":"---\ntitle: 基于vue直播播放器实战\ndate: 2016-7-20 10:42:11\ntags: [vue,基于vue直播播放器实战]\n---\n\n#\t基于 Vue 的直播播放器实战\n\n![Mou icon](http://7xr2s7.com1.z0.glb.clouddn.com/%E5%9F%BA%E4%BA%8E%20Vue%20%E7%9A%84%E7%9B%B4%E6%92%AD%E6%92%AD%E6%94%BE%E5%99%A8%E5%AE%9E%E6%88%98.jpeg)\n## <font style=\"color:red\"> --前言-- </font>\n\n#### 时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple 本人也不例外，本文借着实战的目的完成一个 demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！\n\n#### 直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话 Dimple 只用过七牛云直播，没办法拿数据给大家建议\n\n#### 七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上[ <font style=\"color:blue\">《JavaScript闯关记》</font> ](http://developer.qiniu.com/article/index.html#pili/),其次看 [<font style=\"color:blue\">github 上的库</font>](https://github.com/pili-engineering)\n\n#### 整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个[<font style=\"color:blue\">斗鱼的 OBS 教程</font>](https://www.douyu.com/cms/zhibo/201311/13/250.shtml)\n\n\n\n\t注：以上的直播空间的搭建没有完成也可以看本文，更希望大家可以做成一个完整的 demo，我们的重点还是在于播放器的实现。\n\t\n## <font style=\"color:red\"> --直播协议-- </font>\n\n#### 首先，需要知道直播的常用协议，RTMP 和 HLS，经过测试在七牛云直播平台不采用加速的情况下 RTMP 的延时在 10s 内，HLS 在 10-20s。经过优化后的还没测试过。\n\n#### 至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接[<font style=\"blue\">直播协议的选择：RTMP vs. HLS</font>](http://www.samirchen.com/ios-rtmp-vs-hls/)\n\n## <font style=\"color:red\"> --Vue 结合-- </font>\n\n#### 做过 H5 播放器的对与 video.js 并不陌生，实现的出发点也是在 video.js 上，默认大家都有 Vue 搭建和简单运用能力了，没有经验的可以看 orange 之前写的入门文章。\n\n首先我们要新建一个组件，这个组件就是播放器的组件，组件名随意，最初的想法是直接使用 video.js，但是踩的坑比较深所以不推荐直接使用。\n\n\t坑：首次载入不会有问题，路由跳转后再回来如果不刷新页面，import 进来的 videojs 并不会执行，所以需要在 mounted 里执行 videojs() 函数，然后传对应的参数进去，最后需要加入下面代码防止监听函数在切换路由后继续执行。\n#### 坑也踩完了，于是逛了一圈 github，发现了一个项目叫 vue-video-player\n\n#### 先安装依赖\n\n\tnpm install vue-video-player --save\n\t\n#### 引用依赖\n\n\n\t// import with ES6\n\timport Vue from 'vue'\n\t...\n\timport VideoPlayer from 'vue-video-player'\n\n\n\t// require with Node.js/Webpack\n\tvar Vue = require('vue')\n\t...\n\tvar VideoPlayer = require('vue-video-player')\n\n\t// The default is to turn off some of the features, you can choose according to their use of certain \tfeatures enabled, do not enable the introduction will not require the corresponding file. 默认有些功能\t是不开启的，比如youtube国内不能用，则默认是关闭的，如果不启用对应的功能，则不会引入对应的包，减少项目代码体积，当然也有\t可能意味着对应的功能可能会出错，true 是开启，false是关闭，正常情况使用者不需要care就可以。\n\n\t// Example(Only applies to the current global mode). 用配置项的话仅支持全局模式来配置，否则不会生效\n\tVideoPlayer.config({\n \t youtube: true, // default false\n\t  switcher: false, // default true\n\t  hls: false // default true\n\t})\n\n\t// use\n\tVue.use(VideoPlayer)\n\n\t// --------------------------------------\n\n\t// or use with component(ES6)\n\timport Vue from 'vue'\n\t// ...\n\timport { videoPlayer } from 'vue-video-player'\n\n\t// use\n\texport default {\n  \tcomponents: {\n    \tvideoPlayer\n  \t}\n\t}\n\t\n#### HLS\n\n\n#### 这里默认给出了 HLS 的方案，我们先去全局引入，到 main.js\t\t\n\n\timport VideoPlayer from 'vue-video-player';\n\n\tVideoPlayer.config({\n \t youtube: true,\n \t switcher: true,\n \t hls: true\n\t})\n\n\tVue.use(VideoPlayer)\n\n#### 下面看下我的 component\n\n\n\t<template>\n  \t\t<video-player :options=\"videoOptions\"></video-player>\n\t</template>\n\n\t<script>\n\texport default {\n  \tname: 'Play',\n \t data () {\n \t   return {\n  \t    videoOptions: {\n     \t   source: {\n      \t    type: \"application/x-mpegURL\",\n       \t   src: 'https://logos-channel.scaleengine.net/logos-channel/live/biblescreen-ad-free/\tplaylist.m3u8',\n      \t    withCredentials: false\n    \t    },\n    \t    language: 'zh-CN',\n    \t    live: true,\n    \t    autoplay: true,\n    \t    height: 540\n      \t\t}\n   \t\t  }\n  \t\t}\n\t }\n\t</script>\n\t\n#### 到这里你的播放器就可以播放 HLS 链接了\t\n\n\n#### RTMP \n\n\n#### 上面说到库底层还是依赖 video.js， 所以呢我们不妨直接这样使用\n\n\n\texport default {\n \t\t name: 'Play',\n  \t\t data () {\n    \t\treturn {\n      \t\t videoOptions: {\n        \t   source: {\n         \t\t type: \"rtmp/mp4\",\n          \t\t src: 'rtmp://your.streaming.provider.net/cfx/st/&mp4:path/to/video.mp4',\n            \t withCredentials: false\n       \t\t },\n        \t\tlanguage: 'zh-CN',\n        \t\tlive: true,\n        \t\tautoplay: true,\n        \t\theight: 540\n      \t\t}\n    \t }\n  \t  }\n\t}\n## <font style=\"color:red\"> --总结-- </font>\n\n#### 两种方法均可尝试，上面给出的 src 换成自己的链接就实现拉流播放啦，当然你如果不用 vue 的话也没关系，直接参照 video.js 的官网，单是 RTMP 的话不需要第三方库，如果是 HLS 的话需要引入[<font style=\"color:blue\">videojs-contrib-hls</font>](https://github.com/videojs/videojs-contrib-hls)，看具体情况而定。\n\n🔗原文链接: [http://orangexc.xyz/2016/11/14/Live-video-player/](http://orangexc.xyz/2016/11/14/Live-video-player/) by @Orange","slug":"基于 Vue 的直播播放器实战","published":1,"updated":"2016-11-16T12:50:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civm2xnxt000n1rsmad829ubk","content":"<h1 id=\"基于-Vue-的直播播放器实战\"><a href=\"#基于-Vue-的直播播放器实战\" class=\"headerlink\" title=\"基于 Vue 的直播播放器实战\"></a>基于 Vue 的直播播放器实战</h1><p><img src=\"http://7xr2s7.com1.z0.glb.clouddn.com/%E5%9F%BA%E4%BA%8E%20Vue%20%E7%9A%84%E7%9B%B4%E6%92%AD%E6%92%AD%E6%94%BE%E5%99%A8%E5%AE%9E%E6%88%98.jpeg\" alt=\"Mou icon\"></p>\n<h2 id=\"–前言–\"><a href=\"#–前言–\" class=\"headerlink\" title=\" –前言– \"></a><font style=\"color:red\"> –前言– </font></h2><h4 id=\"时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple-本人也不例外，本文借着实战的目的完成一个-demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！\"><a href=\"#时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple-本人也不例外，本文借着实战的目的完成一个-demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！\" class=\"headerlink\" title=\"时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple 本人也不例外，本文借着实战的目的完成一个 demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！\"></a>时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple 本人也不例外，本文借着实战的目的完成一个 demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！</h4><h4 id=\"直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话-Dimple-只用过七牛云直播，没办法拿数据给大家建议\"><a href=\"#直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话-Dimple-只用过七牛云直播，没办法拿数据给大家建议\" class=\"headerlink\" title=\"直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话 Dimple 只用过七牛云直播，没办法拿数据给大家建议\"></a>直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话 Dimple 只用过七牛云直播，没办法拿数据给大家建议</h4><h4 id=\"七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上-《JavaScript闯关记》-其次看-github-上的库\"><a href=\"#七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上-《JavaScript闯关记》-其次看-github-上的库\" class=\"headerlink\" title=\"七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上 《JavaScript闯关记》 ,其次看 github 上的库\"></a>七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上<a href=\"http://developer.qiniu.com/article/index.html#pili/\" target=\"_blank\" rel=\"external\"> <font style=\"color:blue\">《JavaScript闯关记》</font> </a>,其次看 <a href=\"https://github.com/pili-engineering\" target=\"_blank\" rel=\"external\"><font style=\"color:blue\">github 上的库</font></a></h4><h4 id=\"整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个斗鱼的-OBS-教程\"><a href=\"#整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个斗鱼的-OBS-教程\" class=\"headerlink\" title=\"整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个斗鱼的 OBS 教程\"></a>整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个<a href=\"https://www.douyu.com/cms/zhibo/201311/13/250.shtml\" target=\"_blank\" rel=\"external\"><font style=\"color:blue\">斗鱼的 OBS 教程</font></a></h4><pre><code>注：以上的直播空间的搭建没有完成也可以看本文，更希望大家可以做成一个完整的 demo，我们的重点还是在于播放器的实现。\n</code></pre><h2 id=\"–直播协议–\"><a href=\"#–直播协议–\" class=\"headerlink\" title=\" –直播协议– \"></a><font style=\"color:red\"> –直播协议– </font></h2><h4 id=\"首先，需要知道直播的常用协议，RTMP-和-HLS，经过测试在七牛云直播平台不采用加速的情况下-RTMP-的延时在-10s-内，HLS-在-10-20s。经过优化后的还没测试过。\"><a href=\"#首先，需要知道直播的常用协议，RTMP-和-HLS，经过测试在七牛云直播平台不采用加速的情况下-RTMP-的延时在-10s-内，HLS-在-10-20s。经过优化后的还没测试过。\" class=\"headerlink\" title=\"首先，需要知道直播的常用协议，RTMP 和 HLS，经过测试在七牛云直播平台不采用加速的情况下 RTMP 的延时在 10s 内，HLS 在 10-20s。经过优化后的还没测试过。\"></a>首先，需要知道直播的常用协议，RTMP 和 HLS，经过测试在七牛云直播平台不采用加速的情况下 RTMP 的延时在 10s 内，HLS 在 10-20s。经过优化后的还没测试过。</h4><h4 id=\"至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接直播协议的选择：RTMP-vs-HLS\"><a href=\"#至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接直播协议的选择：RTMP-vs-HLS\" class=\"headerlink\" title=\"至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接直播协议的选择：RTMP vs. HLS\"></a>至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接<a href=\"http://www.samirchen.com/ios-rtmp-vs-hls/\" target=\"_blank\" rel=\"external\"><font style=\"blue\">直播协议的选择：RTMP vs. HLS</font></a></h4><h2 id=\"–Vue-结合–\"><a href=\"#–Vue-结合–\" class=\"headerlink\" title=\" –Vue 结合– \"></a><font style=\"color:red\"> –Vue 结合– </font></h2><h4 id=\"做过-H5-播放器的对与-video-js-并不陌生，实现的出发点也是在-video-js-上，默认大家都有-Vue-搭建和简单运用能力了，没有经验的可以看-orange-之前写的入门文章。\"><a href=\"#做过-H5-播放器的对与-video-js-并不陌生，实现的出发点也是在-video-js-上，默认大家都有-Vue-搭建和简单运用能力了，没有经验的可以看-orange-之前写的入门文章。\" class=\"headerlink\" title=\"做过 H5 播放器的对与 video.js 并不陌生，实现的出发点也是在 video.js 上，默认大家都有 Vue 搭建和简单运用能力了，没有经验的可以看 orange 之前写的入门文章。\"></a>做过 H5 播放器的对与 video.js 并不陌生，实现的出发点也是在 video.js 上，默认大家都有 Vue 搭建和简单运用能力了，没有经验的可以看 orange 之前写的入门文章。</h4><p>首先我们要新建一个组件，这个组件就是播放器的组件，组件名随意，最初的想法是直接使用 video.js，但是踩的坑比较深所以不推荐直接使用。</p>\n<pre><code>坑：首次载入不会有问题，路由跳转后再回来如果不刷新页面，import 进来的 videojs 并不会执行，所以需要在 mounted 里执行 videojs() 函数，然后传对应的参数进去，最后需要加入下面代码防止监听函数在切换路由后继续执行。\n</code></pre><h4 id=\"坑也踩完了，于是逛了一圈-github，发现了一个项目叫-vue-video-player\"><a href=\"#坑也踩完了，于是逛了一圈-github，发现了一个项目叫-vue-video-player\" class=\"headerlink\" title=\"坑也踩完了，于是逛了一圈 github，发现了一个项目叫 vue-video-player\"></a>坑也踩完了，于是逛了一圈 github，发现了一个项目叫 vue-video-player</h4><h4 id=\"先安装依赖\"><a href=\"#先安装依赖\" class=\"headerlink\" title=\"先安装依赖\"></a>先安装依赖</h4><pre><code>npm install vue-video-player --save\n</code></pre><h4 id=\"引用依赖\"><a href=\"#引用依赖\" class=\"headerlink\" title=\"引用依赖\"></a>引用依赖</h4><pre><code>// import with ES6\nimport Vue from &apos;vue&apos;\n...\nimport VideoPlayer from &apos;vue-video-player&apos;\n\n\n// require with Node.js/Webpack\nvar Vue = require(&apos;vue&apos;)\n...\nvar VideoPlayer = require(&apos;vue-video-player&apos;)\n\n// The default is to turn off some of the features, you can choose according to their use of certain     features enabled, do not enable the introduction will not require the corresponding file. 默认有些功能    是不开启的，比如youtube国内不能用，则默认是关闭的，如果不启用对应的功能，则不会引入对应的包，减少项目代码体积，当然也有    可能意味着对应的功能可能会出错，true 是开启，false是关闭，正常情况使用者不需要care就可以。\n\n// Example(Only applies to the current global mode). 用配置项的话仅支持全局模式来配置，否则不会生效\nVideoPlayer.config({\n  youtube: true, // default false\n  switcher: false, // default true\n  hls: false // default true\n})\n\n// use\nVue.use(VideoPlayer)\n\n// --------------------------------------\n\n// or use with component(ES6)\nimport Vue from &apos;vue&apos;\n// ...\nimport { videoPlayer } from &apos;vue-video-player&apos;\n\n// use\nexport default {\n  components: {\n    videoPlayer\n  }\n}\n</code></pre><h4 id=\"HLS\"><a href=\"#HLS\" class=\"headerlink\" title=\"HLS\"></a>HLS</h4><h4 id=\"这里默认给出了-HLS-的方案，我们先去全局引入，到-main-js\"><a href=\"#这里默认给出了-HLS-的方案，我们先去全局引入，到-main-js\" class=\"headerlink\" title=\"这里默认给出了 HLS 的方案，我们先去全局引入，到 main.js\"></a>这里默认给出了 HLS 的方案，我们先去全局引入，到 main.js</h4><pre><code>import VideoPlayer from &apos;vue-video-player&apos;;\n\nVideoPlayer.config({\n  youtube: true,\n  switcher: true,\n  hls: true\n})\n\nVue.use(VideoPlayer)\n</code></pre><h4 id=\"下面看下我的-component\"><a href=\"#下面看下我的-component\" class=\"headerlink\" title=\"下面看下我的 component\"></a>下面看下我的 component</h4><pre><code>&lt;template&gt;\n      &lt;video-player :options=&quot;videoOptions&quot;&gt;&lt;/video-player&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &apos;Play&apos;,\n  data () {\n    return {\n      videoOptions: {\n        source: {\n          type: &quot;application/x-mpegURL&quot;,\n          src: &apos;https://logos-channel.scaleengine.net/logos-channel/live/biblescreen-ad-free/    playlist.m3u8&apos;,\n          withCredentials: false\n        },\n        language: &apos;zh-CN&apos;,\n        live: true,\n        autoplay: true,\n        height: 540\n          }\n         }\n      }\n }\n&lt;/script&gt;\n</code></pre><h4 id=\"到这里你的播放器就可以播放-HLS-链接了\"><a href=\"#到这里你的播放器就可以播放-HLS-链接了\" class=\"headerlink\" title=\"到这里你的播放器就可以播放 HLS 链接了\"></a>到这里你的播放器就可以播放 HLS 链接了</h4><h4 id=\"RTMP\"><a href=\"#RTMP\" class=\"headerlink\" title=\"RTMP\"></a>RTMP</h4><h4 id=\"上面说到库底层还是依赖-video-js，-所以呢我们不妨直接这样使用\"><a href=\"#上面说到库底层还是依赖-video-js，-所以呢我们不妨直接这样使用\" class=\"headerlink\" title=\"上面说到库底层还是依赖 video.js， 所以呢我们不妨直接这样使用\"></a>上面说到库底层还是依赖 video.js， 所以呢我们不妨直接这样使用</h4><pre><code>export default {\n      name: &apos;Play&apos;,\n       data () {\n        return {\n           videoOptions: {\n           source: {\n              type: &quot;rtmp/mp4&quot;,\n               src: &apos;rtmp://your.streaming.provider.net/cfx/st/&amp;mp4:path/to/video.mp4&apos;,\n             withCredentials: false\n            },\n            language: &apos;zh-CN&apos;,\n            live: true,\n            autoplay: true,\n            height: 540\n          }\n     }\n    }\n}\n</code></pre><h2 id=\"–总结–\"><a href=\"#–总结–\" class=\"headerlink\" title=\" –总结– \"></a><font style=\"color:red\"> –总结– </font></h2><h4 id=\"两种方法均可尝试，上面给出的-src-换成自己的链接就实现拉流播放啦，当然你如果不用-vue-的话也没关系，直接参照-video-js-的官网，单是-RTMP-的话不需要第三方库，如果是-HLS-的话需要引入videojs-contrib-hls，看具体情况而定。\"><a href=\"#两种方法均可尝试，上面给出的-src-换成自己的链接就实现拉流播放啦，当然你如果不用-vue-的话也没关系，直接参照-video-js-的官网，单是-RTMP-的话不需要第三方库，如果是-HLS-的话需要引入videojs-contrib-hls，看具体情况而定。\" class=\"headerlink\" title=\"两种方法均可尝试，上面给出的 src 换成自己的链接就实现拉流播放啦，当然你如果不用 vue 的话也没关系，直接参照 video.js 的官网，单是 RTMP 的话不需要第三方库，如果是 HLS 的话需要引入videojs-contrib-hls，看具体情况而定。\"></a>两种方法均可尝试，上面给出的 src 换成自己的链接就实现拉流播放啦，当然你如果不用 vue 的话也没关系，直接参照 video.js 的官网，单是 RTMP 的话不需要第三方库，如果是 HLS 的话需要引入<a href=\"https://github.com/videojs/videojs-contrib-hls\" target=\"_blank\" rel=\"external\"><font style=\"color:blue\">videojs-contrib-hls</font></a>，看具体情况而定。</h4><p>🔗原文链接: <a href=\"http://orangexc.xyz/2016/11/14/Live-video-player/\" target=\"_blank\" rel=\"external\">http://orangexc.xyz/2016/11/14/Live-video-player/</a> by @Orange</p>\n","excerpt":"","more":"<h1 id=\"基于-Vue-的直播播放器实战\"><a href=\"#基于-Vue-的直播播放器实战\" class=\"headerlink\" title=\"基于 Vue 的直播播放器实战\"></a>基于 Vue 的直播播放器实战</h1><p><img src=\"http://7xr2s7.com1.z0.glb.clouddn.com/%E5%9F%BA%E4%BA%8E%20Vue%20%E7%9A%84%E7%9B%B4%E6%92%AD%E6%92%AD%E6%94%BE%E5%99%A8%E5%AE%9E%E6%88%98.jpeg\" alt=\"Mou icon\"></p>\n<h2 id=\"–前言–\"><a href=\"#–前言–\" class=\"headerlink\" title=\" –前言– \"></a><font style=\"color:red\"> –前言– </font></h2><h4 id=\"时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple-本人也不例外，本文借着实战的目的完成一个-demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！\"><a href=\"#时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple-本人也不例外，本文借着实战的目的完成一个-demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！\" class=\"headerlink\" title=\"时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple 本人也不例外，本文借着实战的目的完成一个 demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！\"></a>时下直播的盛行让很多人对直播技术产生浓厚的兴趣，Dimple 本人也不例外，本文借着实战的目的完成一个 demo，并没有深入的讲解直播技术的实现原理以及推流和拉流的实现，为什么不深入讲解直播的底层技术，原因很简单大公司没必要看我的文章去了解如何搭建直播服务器，小企业又没有不要去搭建自己的直播服务器，因为涉及到的技术繁杂又琐碎，感兴趣的直接谷歌，各位大神有不同深度的讲解怎么去搭建自己的直播服务器，那么小企业人员、资金和技术有限怎么办，没错！买服务！！！</h4><h4 id=\"直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话-Dimple-只用过七牛云直播，没办法拿数据给大家建议\"><a href=\"#直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话-Dimple-只用过七牛云直播，没办法拿数据给大家建议\" class=\"headerlink\" title=\"直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话 Dimple 只用过七牛云直播，没办法拿数据给大家建议\"></a>直播云服务也是今年的一个亮点，各大云平台都在做直播的服务，至于快慢选择的话 Dimple 只用过七牛云直播，没办法拿数据给大家建议</h4><h4 id=\"七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上-《JavaScript闯关记》-其次看-github-上的库\"><a href=\"#七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上-《JavaScript闯关记》-其次看-github-上的库\" class=\"headerlink\" title=\"七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上 《JavaScript闯关记》 ,其次看 github 上的库\"></a>七牛的文档给的比较详细，如何获得自己的直播空间，如何绑定备案域名，如何解析域名，如何创建直播间以及整个的工作流程先上<a href=\"http://developer.qiniu.com/article/index.html#pili/\"> <font style=\"color:blue\">《JavaScript闯关记》</font> </a>,其次看 <a href=\"https://github.com/pili-engineering\"><font style=\"color:blue\">github 上的库</font></a></h4><h4 id=\"整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个斗鱼的-OBS-教程\"><a href=\"#整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个斗鱼的-OBS-教程\" class=\"headerlink\" title=\"整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个斗鱼的 OBS 教程\"></a>整个过程相信大家都能顺利完成，说到我们的播放器拉流，那么播放的来源怎么获取呢？有安卓和ios开发经验的可以用移动端推流，没有经验的也不要紧推荐一个<a href=\"https://www.douyu.com/cms/zhibo/201311/13/250.shtml\"><font style=\"color:blue\">斗鱼的 OBS 教程</font></a></h4><pre><code>注：以上的直播空间的搭建没有完成也可以看本文，更希望大家可以做成一个完整的 demo，我们的重点还是在于播放器的实现。\n</code></pre><h2 id=\"–直播协议–\"><a href=\"#–直播协议–\" class=\"headerlink\" title=\" –直播协议– \"></a><font style=\"color:red\"> –直播协议– </font></h2><h4 id=\"首先，需要知道直播的常用协议，RTMP-和-HLS，经过测试在七牛云直播平台不采用加速的情况下-RTMP-的延时在-10s-内，HLS-在-10-20s。经过优化后的还没测试过。\"><a href=\"#首先，需要知道直播的常用协议，RTMP-和-HLS，经过测试在七牛云直播平台不采用加速的情况下-RTMP-的延时在-10s-内，HLS-在-10-20s。经过优化后的还没测试过。\" class=\"headerlink\" title=\"首先，需要知道直播的常用协议，RTMP 和 HLS，经过测试在七牛云直播平台不采用加速的情况下 RTMP 的延时在 10s 内，HLS 在 10-20s。经过优化后的还没测试过。\"></a>首先，需要知道直播的常用协议，RTMP 和 HLS，经过测试在七牛云直播平台不采用加速的情况下 RTMP 的延时在 10s 内，HLS 在 10-20s。经过优化后的还没测试过。</h4><h4 id=\"至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接直播协议的选择：RTMP-vs-HLS\"><a href=\"#至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接直播协议的选择：RTMP-vs-HLS\" class=\"headerlink\" title=\"至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接直播协议的选择：RTMP vs. HLS\"></a>至于这两个协议的选择还需要根据实际情况而定（只看延时大小是不对滴），还是给链接<a href=\"http://www.samirchen.com/ios-rtmp-vs-hls/\"><font style=\"blue\">直播协议的选择：RTMP vs. HLS</font></a></h4><h2 id=\"–Vue-结合–\"><a href=\"#–Vue-结合–\" class=\"headerlink\" title=\" –Vue 结合– \"></a><font style=\"color:red\"> –Vue 结合– </font></h2><h4 id=\"做过-H5-播放器的对与-video-js-并不陌生，实现的出发点也是在-video-js-上，默认大家都有-Vue-搭建和简单运用能力了，没有经验的可以看-orange-之前写的入门文章。\"><a href=\"#做过-H5-播放器的对与-video-js-并不陌生，实现的出发点也是在-video-js-上，默认大家都有-Vue-搭建和简单运用能力了，没有经验的可以看-orange-之前写的入门文章。\" class=\"headerlink\" title=\"做过 H5 播放器的对与 video.js 并不陌生，实现的出发点也是在 video.js 上，默认大家都有 Vue 搭建和简单运用能力了，没有经验的可以看 orange 之前写的入门文章。\"></a>做过 H5 播放器的对与 video.js 并不陌生，实现的出发点也是在 video.js 上，默认大家都有 Vue 搭建和简单运用能力了，没有经验的可以看 orange 之前写的入门文章。</h4><p>首先我们要新建一个组件，这个组件就是播放器的组件，组件名随意，最初的想法是直接使用 video.js，但是踩的坑比较深所以不推荐直接使用。</p>\n<pre><code>坑：首次载入不会有问题，路由跳转后再回来如果不刷新页面，import 进来的 videojs 并不会执行，所以需要在 mounted 里执行 videojs() 函数，然后传对应的参数进去，最后需要加入下面代码防止监听函数在切换路由后继续执行。\n</code></pre><h4 id=\"坑也踩完了，于是逛了一圈-github，发现了一个项目叫-vue-video-player\"><a href=\"#坑也踩完了，于是逛了一圈-github，发现了一个项目叫-vue-video-player\" class=\"headerlink\" title=\"坑也踩完了，于是逛了一圈 github，发现了一个项目叫 vue-video-player\"></a>坑也踩完了，于是逛了一圈 github，发现了一个项目叫 vue-video-player</h4><h4 id=\"先安装依赖\"><a href=\"#先安装依赖\" class=\"headerlink\" title=\"先安装依赖\"></a>先安装依赖</h4><pre><code>npm install vue-video-player --save\n</code></pre><h4 id=\"引用依赖\"><a href=\"#引用依赖\" class=\"headerlink\" title=\"引用依赖\"></a>引用依赖</h4><pre><code>// import with ES6\nimport Vue from &apos;vue&apos;\n...\nimport VideoPlayer from &apos;vue-video-player&apos;\n\n\n// require with Node.js/Webpack\nvar Vue = require(&apos;vue&apos;)\n...\nvar VideoPlayer = require(&apos;vue-video-player&apos;)\n\n// The default is to turn off some of the features, you can choose according to their use of certain     features enabled, do not enable the introduction will not require the corresponding file. 默认有些功能    是不开启的，比如youtube国内不能用，则默认是关闭的，如果不启用对应的功能，则不会引入对应的包，减少项目代码体积，当然也有    可能意味着对应的功能可能会出错，true 是开启，false是关闭，正常情况使用者不需要care就可以。\n\n// Example(Only applies to the current global mode). 用配置项的话仅支持全局模式来配置，否则不会生效\nVideoPlayer.config({\n  youtube: true, // default false\n  switcher: false, // default true\n  hls: false // default true\n})\n\n// use\nVue.use(VideoPlayer)\n\n// --------------------------------------\n\n// or use with component(ES6)\nimport Vue from &apos;vue&apos;\n// ...\nimport { videoPlayer } from &apos;vue-video-player&apos;\n\n// use\nexport default {\n  components: {\n    videoPlayer\n  }\n}\n</code></pre><h4 id=\"HLS\"><a href=\"#HLS\" class=\"headerlink\" title=\"HLS\"></a>HLS</h4><h4 id=\"这里默认给出了-HLS-的方案，我们先去全局引入，到-main-js\"><a href=\"#这里默认给出了-HLS-的方案，我们先去全局引入，到-main-js\" class=\"headerlink\" title=\"这里默认给出了 HLS 的方案，我们先去全局引入，到 main.js\"></a>这里默认给出了 HLS 的方案，我们先去全局引入，到 main.js</h4><pre><code>import VideoPlayer from &apos;vue-video-player&apos;;\n\nVideoPlayer.config({\n  youtube: true,\n  switcher: true,\n  hls: true\n})\n\nVue.use(VideoPlayer)\n</code></pre><h4 id=\"下面看下我的-component\"><a href=\"#下面看下我的-component\" class=\"headerlink\" title=\"下面看下我的 component\"></a>下面看下我的 component</h4><pre><code>&lt;template&gt;\n      &lt;video-player :options=&quot;videoOptions&quot;&gt;&lt;/video-player&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &apos;Play&apos;,\n  data () {\n    return {\n      videoOptions: {\n        source: {\n          type: &quot;application/x-mpegURL&quot;,\n          src: &apos;https://logos-channel.scaleengine.net/logos-channel/live/biblescreen-ad-free/    playlist.m3u8&apos;,\n          withCredentials: false\n        },\n        language: &apos;zh-CN&apos;,\n        live: true,\n        autoplay: true,\n        height: 540\n          }\n         }\n      }\n }\n&lt;/script&gt;\n</code></pre><h4 id=\"到这里你的播放器就可以播放-HLS-链接了\"><a href=\"#到这里你的播放器就可以播放-HLS-链接了\" class=\"headerlink\" title=\"到这里你的播放器就可以播放 HLS 链接了\"></a>到这里你的播放器就可以播放 HLS 链接了</h4><h4 id=\"RTMP\"><a href=\"#RTMP\" class=\"headerlink\" title=\"RTMP\"></a>RTMP</h4><h4 id=\"上面说到库底层还是依赖-video-js，-所以呢我们不妨直接这样使用\"><a href=\"#上面说到库底层还是依赖-video-js，-所以呢我们不妨直接这样使用\" class=\"headerlink\" title=\"上面说到库底层还是依赖 video.js， 所以呢我们不妨直接这样使用\"></a>上面说到库底层还是依赖 video.js， 所以呢我们不妨直接这样使用</h4><pre><code>export default {\n      name: &apos;Play&apos;,\n       data () {\n        return {\n           videoOptions: {\n           source: {\n              type: &quot;rtmp/mp4&quot;,\n               src: &apos;rtmp://your.streaming.provider.net/cfx/st/&amp;mp4:path/to/video.mp4&apos;,\n             withCredentials: false\n            },\n            language: &apos;zh-CN&apos;,\n            live: true,\n            autoplay: true,\n            height: 540\n          }\n     }\n    }\n}\n</code></pre><h2 id=\"–总结–\"><a href=\"#–总结–\" class=\"headerlink\" title=\" –总结– \"></a><font style=\"color:red\"> –总结– </font></h2><h4 id=\"两种方法均可尝试，上面给出的-src-换成自己的链接就实现拉流播放啦，当然你如果不用-vue-的话也没关系，直接参照-video-js-的官网，单是-RTMP-的话不需要第三方库，如果是-HLS-的话需要引入videojs-contrib-hls，看具体情况而定。\"><a href=\"#两种方法均可尝试，上面给出的-src-换成自己的链接就实现拉流播放啦，当然你如果不用-vue-的话也没关系，直接参照-video-js-的官网，单是-RTMP-的话不需要第三方库，如果是-HLS-的话需要引入videojs-contrib-hls，看具体情况而定。\" class=\"headerlink\" title=\"两种方法均可尝试，上面给出的 src 换成自己的链接就实现拉流播放啦，当然你如果不用 vue 的话也没关系，直接参照 video.js 的官网，单是 RTMP 的话不需要第三方库，如果是 HLS 的话需要引入videojs-contrib-hls，看具体情况而定。\"></a>两种方法均可尝试，上面给出的 src 换成自己的链接就实现拉流播放啦，当然你如果不用 vue 的话也没关系，直接参照 video.js 的官网，单是 RTMP 的话不需要第三方库，如果是 HLS 的话需要引入<a href=\"https://github.com/videojs/videojs-contrib-hls\"><font style=\"color:blue\">videojs-contrib-hls</font></a>，看具体情况而定。</h4><p>🔗原文链接: <a href=\"http://orangexc.xyz/2016/11/14/Live-video-player/\">http://orangexc.xyz/2016/11/14/Live-video-player/</a> by @Orange</p>\n"},{"title":"实现图片的拖放","date":"2016-07-15T12:13:07.000Z","_content":"\n\n## 拖放\n##### 拖放是一种常见的特性，即抓取对象以后拖到另一个位置\n\n## Examples\n\n## dragenter\n\n\n\t开始拖动\n\t\n## dragover\t\n\n\t拖动中\n\n## dragleave\t\n\n\t拖动放开\n\t\n## drop\t\n\n\t拖动完成\n\n## Basis\n\n\t把图片拖到这里试试\t\t（这里就不做演示了）\n\n\t\n## css代码\n\n\t#target_box{\n  \t\t\tmax-width : 100%;\n  \t\t\twidth: 300px;\n  \t\t\theight: 100px;\n  \t\t\tborder: 1px solid red;\n  \t\t\tdisplay: flex;\n  \t\t\tjustify-content: center;\n  \t\t\talign-items: center;\n  \t\t\tfont-size: 18px; transition: all 0.5s;\n\t\t}\n\t#target_box.droping{\n  \t\t\tcolor: red;\n  \t\t\tfont-weight: blod;\n  \t\t\tfont-size: 30px;\n\t\t}\n\n\t#show-drop img{\n \t\t\t max-width : 100%;\n \t\t\t display: block;\n\t\t}\n\t\t\n## html代码\n\n\t\n\t<div id=\"target_box\">把图片拖到这里试试</div>\n\t<div id=\"show-drop\" title=\"将拖动的图片在这里显示出来\"></div>\n\t\n\t\n## js代码\n\n\tfunction addEventListener(dom,event,callback){\n    if(typeof dom == \"string\"){\n      document.querySelector(dom).addEventListener(event,callback);\n    }else{\n      dom.addEventListener(event,callback);\n    \t}\n\t}\n\t//开始拖动\n\taddEventListener(document,\"dragenter\",function(e){\n \t\t e.preventDefault();\n\t\t document.querySelector(\"#target_box\").setAttribute(\"class\",\"droping\");\n\t});\n\n\t//拖动中\n\taddEventListener(document,\"dragover\",function(e){\n \t\t e.preventDefault();\n\t});\n\n\t//拖放完成\n\taddEventListener(document,\"drop\",function(e){\n \t\t e.preventDefault();\n\t});\n\t//拖放离开\n\taddEventListener(document,\"dragleave\",function(e){\n \t\t e.preventDefault();\n \t document.querySelector(\"#target_box\").setAttribute(\"class\",\"\");\n\t});\n\t//监听是否拖放当元素上后离开的\n\t\taddEventListener(\"#target_box\",'drop',function(e){\n \t\t e.preventDefault();//移除原有浏览器监听效果\n \t\t var dataTransfer = e.dataTransfer;//获取文件对象\n  \t\t var files = dataTransfer.files[0];\n  \t//获取文件后缀\n \t var match = files.name ? files.name.match(/\\.([a-zA-Z]+)$/) || [] : false;\n  \t var suffix = match ? match[1] : \"\";\n \t//如果后缀不是图片\n  \tif(!suffix || [\"jpg\",\"jpeg\",\"png\",\"gif\"].indexOf(suffix.toLocaleLowerCase()) < 0){\n    \treturn alert(\"你拖动的不是图片\");\n  \t}\n  \t//读取文件的 base64 值\n  \t\tvar filereader = new FileReader();\n  \t\taddEventListener(filereader,'load',function(ee){\n    //获取 base64 编码\n    var base64 = ee.target.result;\n    var img = document.createElement(\"img\");\n    img.src = base64;\n    //将图片添加到页面中\n    document.querySelector(\"#show-drop\").appendChild(img);\n  \t});\n  \tfilereader.readAsDataURL(files);\n\t});\t\n\n## base64图片\n\n\t如果需要实现图片上传，可以将转行后的 base64 上传到服务器，服务器将 base64 生成为图片\n\t\n\t\n#### 希望大家能帮到大家的地方\t\n\t\n\t","source":"_posts/实现图片拖放.md","raw":"---\ntitle: 实现图片的拖放\ndate: 2016-7-15 20:13:07\ntags: [javascript,CSS]\n---\n\n\n## 拖放\n##### 拖放是一种常见的特性，即抓取对象以后拖到另一个位置\n\n## Examples\n\n## dragenter\n\n\n\t开始拖动\n\t\n## dragover\t\n\n\t拖动中\n\n## dragleave\t\n\n\t拖动放开\n\t\n## drop\t\n\n\t拖动完成\n\n## Basis\n\n\t把图片拖到这里试试\t\t（这里就不做演示了）\n\n\t\n## css代码\n\n\t#target_box{\n  \t\t\tmax-width : 100%;\n  \t\t\twidth: 300px;\n  \t\t\theight: 100px;\n  \t\t\tborder: 1px solid red;\n  \t\t\tdisplay: flex;\n  \t\t\tjustify-content: center;\n  \t\t\talign-items: center;\n  \t\t\tfont-size: 18px; transition: all 0.5s;\n\t\t}\n\t#target_box.droping{\n  \t\t\tcolor: red;\n  \t\t\tfont-weight: blod;\n  \t\t\tfont-size: 30px;\n\t\t}\n\n\t#show-drop img{\n \t\t\t max-width : 100%;\n \t\t\t display: block;\n\t\t}\n\t\t\n## html代码\n\n\t\n\t<div id=\"target_box\">把图片拖到这里试试</div>\n\t<div id=\"show-drop\" title=\"将拖动的图片在这里显示出来\"></div>\n\t\n\t\n## js代码\n\n\tfunction addEventListener(dom,event,callback){\n    if(typeof dom == \"string\"){\n      document.querySelector(dom).addEventListener(event,callback);\n    }else{\n      dom.addEventListener(event,callback);\n    \t}\n\t}\n\t//开始拖动\n\taddEventListener(document,\"dragenter\",function(e){\n \t\t e.preventDefault();\n\t\t document.querySelector(\"#target_box\").setAttribute(\"class\",\"droping\");\n\t});\n\n\t//拖动中\n\taddEventListener(document,\"dragover\",function(e){\n \t\t e.preventDefault();\n\t});\n\n\t//拖放完成\n\taddEventListener(document,\"drop\",function(e){\n \t\t e.preventDefault();\n\t});\n\t//拖放离开\n\taddEventListener(document,\"dragleave\",function(e){\n \t\t e.preventDefault();\n \t document.querySelector(\"#target_box\").setAttribute(\"class\",\"\");\n\t});\n\t//监听是否拖放当元素上后离开的\n\t\taddEventListener(\"#target_box\",'drop',function(e){\n \t\t e.preventDefault();//移除原有浏览器监听效果\n \t\t var dataTransfer = e.dataTransfer;//获取文件对象\n  \t\t var files = dataTransfer.files[0];\n  \t//获取文件后缀\n \t var match = files.name ? files.name.match(/\\.([a-zA-Z]+)$/) || [] : false;\n  \t var suffix = match ? match[1] : \"\";\n \t//如果后缀不是图片\n  \tif(!suffix || [\"jpg\",\"jpeg\",\"png\",\"gif\"].indexOf(suffix.toLocaleLowerCase()) < 0){\n    \treturn alert(\"你拖动的不是图片\");\n  \t}\n  \t//读取文件的 base64 值\n  \t\tvar filereader = new FileReader();\n  \t\taddEventListener(filereader,'load',function(ee){\n    //获取 base64 编码\n    var base64 = ee.target.result;\n    var img = document.createElement(\"img\");\n    img.src = base64;\n    //将图片添加到页面中\n    document.querySelector(\"#show-drop\").appendChild(img);\n  \t});\n  \tfilereader.readAsDataURL(files);\n\t});\t\n\n## base64图片\n\n\t如果需要实现图片上传，可以将转行后的 base64 上传到服务器，服务器将 base64 生成为图片\n\t\n\t\n#### 希望大家能帮到大家的地方\t\n\t\n\t","slug":"实现图片拖放","published":1,"updated":"2016-11-16T09:40:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civm2xnxw000o1rsmby9w1qrd","content":"<h2 id=\"拖放\"><a href=\"#拖放\" class=\"headerlink\" title=\"拖放\"></a>拖放</h2><h5 id=\"拖放是一种常见的特性，即抓取对象以后拖到另一个位置\"><a href=\"#拖放是一种常见的特性，即抓取对象以后拖到另一个位置\" class=\"headerlink\" title=\"拖放是一种常见的特性，即抓取对象以后拖到另一个位置\"></a>拖放是一种常见的特性，即抓取对象以后拖到另一个位置</h5><h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><h2 id=\"dragenter\"><a href=\"#dragenter\" class=\"headerlink\" title=\"dragenter\"></a>dragenter</h2><pre><code>开始拖动\n</code></pre><h2 id=\"dragover\"><a href=\"#dragover\" class=\"headerlink\" title=\"dragover\"></a>dragover</h2><pre><code>拖动中\n</code></pre><h2 id=\"dragleave\"><a href=\"#dragleave\" class=\"headerlink\" title=\"dragleave\"></a>dragleave</h2><pre><code>拖动放开\n</code></pre><h2 id=\"drop\"><a href=\"#drop\" class=\"headerlink\" title=\"drop\"></a>drop</h2><pre><code>拖动完成\n</code></pre><h2 id=\"Basis\"><a href=\"#Basis\" class=\"headerlink\" title=\"Basis\"></a>Basis</h2><pre><code>把图片拖到这里试试        （这里就不做演示了）\n</code></pre><h2 id=\"css代码\"><a href=\"#css代码\" class=\"headerlink\" title=\"css代码\"></a>css代码</h2><pre><code>#target_box{\n          max-width : 100%;\n          width: 300px;\n          height: 100px;\n          border: 1px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          font-size: 18px; transition: all 0.5s;\n    }\n#target_box.droping{\n          color: red;\n          font-weight: blod;\n          font-size: 30px;\n    }\n\n#show-drop img{\n          max-width : 100%;\n          display: block;\n    }\n</code></pre><h2 id=\"html代码\"><a href=\"#html代码\" class=\"headerlink\" title=\"html代码\"></a>html代码</h2><pre><code>&lt;div id=&quot;target_box&quot;&gt;把图片拖到这里试试&lt;/div&gt;\n&lt;div id=&quot;show-drop&quot; title=&quot;将拖动的图片在这里显示出来&quot;&gt;&lt;/div&gt;\n</code></pre><h2 id=\"js代码\"><a href=\"#js代码\" class=\"headerlink\" title=\"js代码\"></a>js代码</h2><pre><code>function addEventListener(dom,event,callback){\nif(typeof dom == &quot;string&quot;){\n  document.querySelector(dom).addEventListener(event,callback);\n}else{\n  dom.addEventListener(event,callback);\n    }\n}\n//开始拖动\naddEventListener(document,&quot;dragenter&quot;,function(e){\n      e.preventDefault();\n     document.querySelector(&quot;#target_box&quot;).setAttribute(&quot;class&quot;,&quot;droping&quot;);\n});\n\n//拖动中\naddEventListener(document,&quot;dragover&quot;,function(e){\n      e.preventDefault();\n});\n\n//拖放完成\naddEventListener(document,&quot;drop&quot;,function(e){\n      e.preventDefault();\n});\n//拖放离开\naddEventListener(document,&quot;dragleave&quot;,function(e){\n      e.preventDefault();\n  document.querySelector(&quot;#target_box&quot;).setAttribute(&quot;class&quot;,&quot;&quot;);\n});\n//监听是否拖放当元素上后离开的\n    addEventListener(&quot;#target_box&quot;,&apos;drop&apos;,function(e){\n      e.preventDefault();//移除原有浏览器监听效果\n      var dataTransfer = e.dataTransfer;//获取文件对象\n       var files = dataTransfer.files[0];\n  //获取文件后缀\n  var match = files.name ? files.name.match(/\\.([a-zA-Z]+)$/) || [] : false;\n   var suffix = match ? match[1] : &quot;&quot;;\n //如果后缀不是图片\n  if(!suffix || [&quot;jpg&quot;,&quot;jpeg&quot;,&quot;png&quot;,&quot;gif&quot;].indexOf(suffix.toLocaleLowerCase()) &lt; 0){\n    return alert(&quot;你拖动的不是图片&quot;);\n  }\n  //读取文件的 base64 值\n      var filereader = new FileReader();\n      addEventListener(filereader,&apos;load&apos;,function(ee){\n//获取 base64 编码\nvar base64 = ee.target.result;\nvar img = document.createElement(&quot;img&quot;);\nimg.src = base64;\n//将图片添加到页面中\ndocument.querySelector(&quot;#show-drop&quot;).appendChild(img);\n  });\n  filereader.readAsDataURL(files);\n});    \n</code></pre><h2 id=\"base64图片\"><a href=\"#base64图片\" class=\"headerlink\" title=\"base64图片\"></a>base64图片</h2><pre><code>如果需要实现图片上传，可以将转行后的 base64 上传到服务器，服务器将 base64 生成为图片\n</code></pre><h4 id=\"希望大家能帮到大家的地方\"><a href=\"#希望大家能帮到大家的地方\" class=\"headerlink\" title=\"希望大家能帮到大家的地方\"></a>希望大家能帮到大家的地方</h4>","excerpt":"","more":"<h2 id=\"拖放\"><a href=\"#拖放\" class=\"headerlink\" title=\"拖放\"></a>拖放</h2><h5 id=\"拖放是一种常见的特性，即抓取对象以后拖到另一个位置\"><a href=\"#拖放是一种常见的特性，即抓取对象以后拖到另一个位置\" class=\"headerlink\" title=\"拖放是一种常见的特性，即抓取对象以后拖到另一个位置\"></a>拖放是一种常见的特性，即抓取对象以后拖到另一个位置</h5><h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><h2 id=\"dragenter\"><a href=\"#dragenter\" class=\"headerlink\" title=\"dragenter\"></a>dragenter</h2><pre><code>开始拖动\n</code></pre><h2 id=\"dragover\"><a href=\"#dragover\" class=\"headerlink\" title=\"dragover\"></a>dragover</h2><pre><code>拖动中\n</code></pre><h2 id=\"dragleave\"><a href=\"#dragleave\" class=\"headerlink\" title=\"dragleave\"></a>dragleave</h2><pre><code>拖动放开\n</code></pre><h2 id=\"drop\"><a href=\"#drop\" class=\"headerlink\" title=\"drop\"></a>drop</h2><pre><code>拖动完成\n</code></pre><h2 id=\"Basis\"><a href=\"#Basis\" class=\"headerlink\" title=\"Basis\"></a>Basis</h2><pre><code>把图片拖到这里试试        （这里就不做演示了）\n</code></pre><h2 id=\"css代码\"><a href=\"#css代码\" class=\"headerlink\" title=\"css代码\"></a>css代码</h2><pre><code>#target_box{\n          max-width : 100%;\n          width: 300px;\n          height: 100px;\n          border: 1px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          font-size: 18px; transition: all 0.5s;\n    }\n#target_box.droping{\n          color: red;\n          font-weight: blod;\n          font-size: 30px;\n    }\n\n#show-drop img{\n          max-width : 100%;\n          display: block;\n    }\n</code></pre><h2 id=\"html代码\"><a href=\"#html代码\" class=\"headerlink\" title=\"html代码\"></a>html代码</h2><pre><code>&lt;div id=&quot;target_box&quot;&gt;把图片拖到这里试试&lt;/div&gt;\n&lt;div id=&quot;show-drop&quot; title=&quot;将拖动的图片在这里显示出来&quot;&gt;&lt;/div&gt;\n</code></pre><h2 id=\"js代码\"><a href=\"#js代码\" class=\"headerlink\" title=\"js代码\"></a>js代码</h2><pre><code>function addEventListener(dom,event,callback){\nif(typeof dom == &quot;string&quot;){\n  document.querySelector(dom).addEventListener(event,callback);\n}else{\n  dom.addEventListener(event,callback);\n    }\n}\n//开始拖动\naddEventListener(document,&quot;dragenter&quot;,function(e){\n      e.preventDefault();\n     document.querySelector(&quot;#target_box&quot;).setAttribute(&quot;class&quot;,&quot;droping&quot;);\n});\n\n//拖动中\naddEventListener(document,&quot;dragover&quot;,function(e){\n      e.preventDefault();\n});\n\n//拖放完成\naddEventListener(document,&quot;drop&quot;,function(e){\n      e.preventDefault();\n});\n//拖放离开\naddEventListener(document,&quot;dragleave&quot;,function(e){\n      e.preventDefault();\n  document.querySelector(&quot;#target_box&quot;).setAttribute(&quot;class&quot;,&quot;&quot;);\n});\n//监听是否拖放当元素上后离开的\n    addEventListener(&quot;#target_box&quot;,&apos;drop&apos;,function(e){\n      e.preventDefault();//移除原有浏览器监听效果\n      var dataTransfer = e.dataTransfer;//获取文件对象\n       var files = dataTransfer.files[0];\n  //获取文件后缀\n  var match = files.name ? files.name.match(/\\.([a-zA-Z]+)$/) || [] : false;\n   var suffix = match ? match[1] : &quot;&quot;;\n //如果后缀不是图片\n  if(!suffix || [&quot;jpg&quot;,&quot;jpeg&quot;,&quot;png&quot;,&quot;gif&quot;].indexOf(suffix.toLocaleLowerCase()) &lt; 0){\n    return alert(&quot;你拖动的不是图片&quot;);\n  }\n  //读取文件的 base64 值\n      var filereader = new FileReader();\n      addEventListener(filereader,&apos;load&apos;,function(ee){\n//获取 base64 编码\nvar base64 = ee.target.result;\nvar img = document.createElement(&quot;img&quot;);\nimg.src = base64;\n//将图片添加到页面中\ndocument.querySelector(&quot;#show-drop&quot;).appendChild(img);\n  });\n  filereader.readAsDataURL(files);\n});    \n</code></pre><h2 id=\"base64图片\"><a href=\"#base64图片\" class=\"headerlink\" title=\"base64图片\"></a>base64图片</h2><pre><code>如果需要实现图片上传，可以将转行后的 base64 上传到服务器，服务器将 base64 生成为图片\n</code></pre><h4 id=\"希望大家能帮到大家的地方\"><a href=\"#希望大家能帮到大家的地方\" class=\"headerlink\" title=\"希望大家能帮到大家的地方\"></a>希望大家能帮到大家的地方</h4>"},{"title":"函数详解","date":"2016-08-10T11:54:21.000Z","_content":"\n# javaScript之函数详解\n\n本文档内容参考[<font style=\"color:blue\">《JavaScript闯关记》</font>](http://gold.xitu.io/post/582087522e958a0054f8ed36)之函数\n\n函数是一段代码，他只定义一次，但可以被执行或调用任意次。在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。如果函数嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。\n\n\n#### 函数定义\n\n在 JavaScript 中，函数实际上是对象，每个函数都是Function构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常有以下3中定义方式。例如：\n \t\n\t// 写法一：函数声明（推荐写法）\n\n\tfunction   sum(num1, num2){\n\t\n\t\treturn   num1 + num2;\n\t\t\n\t}\n\n\t// 写法二：函数表达式（推荐写法）\n\t\n\tvar    sum =function(num1, num2){\n\t\n\t\treturn    num1 + num2;\n\t\t\n\t};\n\n\t// 写法三：Function 构造函数（不推荐写法）\n\n\tvar   sum =new   Function(\"num1\",\"num2\",\"return num1 + \tnum2\");\n\t\n由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。例如：\n\n\tfunction   sum(num1, num2){\n\t\n\treturnnum1 + num2;\n\n\t}\n\n\tconsole.log(sum(10,10));   // 20\n\n\tvar   anotherSum = sum;\n\n\tconsole.log(anotherSum(10,10));   // 20\n\n\tsum = null;\n\n\tconsole.log(anotherSum(10,10));  // 20\n\n### 没有重载\n\n将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。\n\n\tfunction   addSomeNumber(num){\n\t\n\treturn   num +100;\n\n\t}\n\n\tfunction   addSomeNumber(num){\n\t\n\treturn   num +200;\n\n\t}\n\n\tvar   result = addSomeNumber(100);  // 300\n\n\n显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。\n\n\tvar   addSomeNumber = function(num){\n\t\n\t\treturn   num +100;\n\n\t};\n\n\taddSomeNumber = function(num){\n\t\n\t\treturn   num +200;\n\n\t};\n\n\tvar   result = addSomeNumber(100);   // 300\n\t\n\n通过重写代码之后可以很容易明白，在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。\n\n函数声明与函数表达式（函数是js中的一等公民，JavaScript 引擎在渲染js时会把通过函数声明声明的函数放在js的顶部优先解析）\n\n解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。例如：\n\n\tconsole.log(sum(10,10));   // 20\n\n\tfunction   sum(num1, num2){\n\n  \treturn   num1 + num2;\n\n\t}\n\n以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。把上面的「函数声明」改为等价的「函数表达式」，就会在执行期间导致错误。例如：\n\n\tconsole.log(sum(10,10));   // Uncaught TypeError: sum \tis not a function\n\n\tvar   sum =function(num1, num2){\n\t\n\treturn   num1 + num2;\n\n\t};\n\n除了上述区别之外，「函数声明」与「函数表达式」的语法是等价的。\n\n### 作为值的函数\n\n因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。\n\n\tfunction   callSomeFunction(someFunction,someArgument){\n\n  \treturn   someFunction(someArgument);\n\n\t}\n\t\n这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。\n\n\n\tfunction   add10(num){ \t\t        \n\t\n\t\n\t\treturn   num +10;\n\n\t}\n\n\tvar   result1 = callSomeFunction(add10,10);\n\n\tconsole.log(result1);   // 20\n\n\tfunction   getGreeting(name){\n\t\n\t\treturn   \"Hello, \"+ name;\n\n\t}\n\n\tvar  result2 = callSomeFunction(getGreeting,\"Nicholas\");\n\n\tconsole.log(result2);   // \"Hello, Nicholas\"\n\n\t\n这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。因此上面例子中传递给callSomeFunction()的是add10和getGreeting，而不是执行它们之后的结果。\n\n当然，还可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。\n\n\tfunction   createComparisonFunction(propertyName){\n\t\n\t\treturn   function(object1, object2){\n\t\t\n\t\t\t var   value1 = object1[propertyName];\n\t\t\t \n\t\t\t var   value2 = object2[propertyName];\n\t\t\t \n\t\t\t if(value1 < value2){\n\t\t\t \n\t\t\t \t\treturn -1;        \n\t\t\t \t\t\n\t\t\t \t}else  if(value1 > value2){\n\t\t\t \t\n\t\t\t \treturn 1;      \n\t\t\t \t\n\t\t\t \t}else{\n\t\t\t \t\n\t\t\t \t\treturn 0;        \n\t\t\t \t\t\n\t\t\t \t}    \n\t\t\t }\n\t\t  }\n\n这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。\n\n\tvar   data = [{name:\"Zachary\",age:28}, {name:\"Nicholas\",age:29}];\n\n\tdata.sort(createComparisonFunction(\"name\"));\n\n\tconsole.log(data[0].name);   //Nicholas\n\n\tdata.sort(createComparisonFunction(\"age\"));\n\n\tconsole.log(data[0].name);   // Zachary\n\n这里，我们创建了一个包含两个对象的数组data。其中，每个对象都包含一个name属性和一个age属性。在默认情况下，sort()方法会调用每个对象的toString()方法以确定它们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用createComparisonFunction(\"name\")方法创建了一个比较函数，以便按照每个对象的name属性值进行排序。而结果排在前面的第一项是name为\"Nicholas\"，age是29的对象。然后，我们又使用了createComparisonFunction(\"age\")返回的比较函数，这次是按照对象的age属性排序。得到的结果是name值为\"Zachary\"，age值是28的对象排在了第一位。\n\n### 函数的形参和实参\n\n在函数内部，有两个特殊的对象：arguments和this。其中，arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。\n\n\tfunction   factorial(num){\n\t\n\t\tif(num <=1) {\n\t\t\n\t\t\treturn 1;  \n\t\t\t\n\t\t}else{\n\t\t\n\t\t\treturn  num * factorial(num-1)    \n\t\t\t\n\t\t}\n\t\t\n\t}\n\n定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。\n\n\tfunction   factorial(num){\n\t\t\n\t\t\tif(num <=1) {\n\t\t\t\n\t\t\t\treturn  1;  \n\t\t\t\t\t\n\t\t\t}else{\n\t\t\t\n\t\t\t\treturn  num *arguments.callee(num-1)  \n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t}\n\n在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：\n\n\tvar   trueFactorial = factorial;\n\n\tfactorial =function(){\n\t\n\t\treturn  0;\n\t\t\n\t};\n\n\tconsole.log(trueFactorial(5));   // 120\n\n\tconsole.log(factorial(5));   // 0\n\n在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的factorial()那样不使用arguments.callee，调用trueFactorial()就会返回0。可是，在解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘；至于factorial()，它现在只是一个返回0的函数。\n\n函数内部的另一个特殊对象是this，其行为与 Java 和 C# 中的this大致类似。换句话说，this引用的是函数据以执行的环境对象（当在网页的全局作用域中调用函数时，this对象引用的就是window）。来看下面的例子。\n\n\twindow.color =\"red\";\n\n\tvar o = {color:\"blue\"};\n\n\tfunction sayColor(){\n\t\n\t\tconsole.log(this.color);\n\t\t\n\t}\n\n\tsayColor();   // \"red\"\n\n\to.sayColor = sayColor;\n\n\to.sayColor();   // \"blue\"\n\n上面这个函数sayColor()是在全局作用域中定义的，它引用了this对象。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引用的是全局对象window；换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了\"red\"。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了\"blue\"。\n\n请大家一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。\n\nECMAScript 5也规范化了另一个函数对象的属性caller。这个属性中保存着「调用当前函数的函数的引用」，如果是在全局作用域中调用当前函数，它的值为null。例如：\n\n\tfunction  outer(){  \n\n        inner();\n\n\t}\n\n\tfunction  inner(){\n\n      console.log(arguments.callee.caller);\n\n\t}\n\n\touter();\n\n以上代码会导致警告框中显示outer()函数的源代码。因为outer()调用了inter()，所以arguments.callee.caller就指向outer()。\n\n在严格模式下，访问arguments.callee属性，或为函数的caller属性赋值，都会导致错误。\n\n### 函数的属性和方法\n\nJavaScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数，如下面的例子所示。\n\n\tfunction   sayName(name){\n\t\n\t\tconsole.log(name);\n\n\t}\n\n\tfunction   sum(num1, num2){\n\t\n\t\treturn    num1 + num2;\n\n\t}\n\n\tfunction   sayHi(){\n\t\n\t\t console.log(\"hi\");\n\n\t}\n\n\tconsole.log(sayName.length);     // 1\n\n\tconsole.log(sum.length);   // 2\n\n\tconsole.log(sayHi.length);   // 0\n对于 JavaScript 中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。在 ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。\n\n每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如：\n\n\tfunction   sum(num1, num2){\n\t\treturn   num1 + num2;\n\n\t}\n\n\tfunction    callSum1(num1, num2){\n\t\n\t\treturn   sum.apply(this,arguments);  // 传入 arguments 对象\n\n\t}\n\n\tfunction   callSum2(num1, num2){\n\t\treturn   sum.apply(this, [num1, num2]);   // 传入数组\n\n\t}\n\n\tconsole.log(callSum1(10,10));   // 20\n\n\tconsole.log(callSum2(10,10));   // 20\n在上面这个例子中，callSum1()在执行sum()函数时传入了this（因为是在全局作用域中调用的，所以传入的就是window对象）和arguments对象。而callSum2同样也调用了sum()函数，但它传入的则是this和一个参数数组。这两个函数都会正常执行并返回正确的结果。\n\ncall()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。\n\n\tfunction   sum(num1, num2){\n\t\n\t\treturnnum1 + num2;\n\n\t}\n\n\tfunction   callSum(num1, num2){\n\t\n\t\treturnsum.call(this, num1, num2);\n\n\t}\n\n\tconsole.log(callSum(10,10));   // 20\n\n在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）\n\n事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。\n\n\twindow.color =\"red\";\n\n\tvar o = {color:\"blue\"};\n\n\tfunction   sayColor(){\n\t\n\t\tconsole.log(this.color);\n\n\t}\n\n\tsayColor();   // red\n\n\tsayColor.call(this);   // red\n\n\tsayColor.call(window);   // red\n\n\tsayColor.call(o);   // blue\n\n这个例子是在前面说明this对象的示例基础上修改而成的。这一次，sayColor()也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示\"red\"，因为对this.color的求值会转换成对window.color的求值。而sayColor.call(this)和sayColor.call(window)，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示\"red\"。但是，当运行sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的this对象指向了o，于是结果显示的是\"blue\"。\n\n使用call()或apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将sayColor()函数放到了对象o中，然后再通过o来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。\n\n2、全局安装gulp\n        2.1、说明：全局安装gulp目的是为了通过她执行gulp任务；\n\n        2.2、安装：命令提示符执行npm install gulp -g；\n\n        2.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。\n\n3、新建package.json文件\n       3.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；\n\n       3.2、执行命令提示符执行npm init进行手动安装\n\n      3.3、安装完成后会在当前文件夹下看到如下package.json文件\n\n\n\n文/原创／Dimple（github作者）\n原文链接：https://cuidapao.github.io/\n著作权归作者所有，转载请联系作者获得授权，并标注\"github作者\"。\n\n\n","source":"_posts/函数详解.md","raw":"---\ntitle: 函数详解\ndate: 2016-8-10 19:54:21\ntags: [javascript,函数详解]\n---\n\n# javaScript之函数详解\n\n本文档内容参考[<font style=\"color:blue\">《JavaScript闯关记》</font>](http://gold.xitu.io/post/582087522e958a0054f8ed36)之函数\n\n函数是一段代码，他只定义一次，但可以被执行或调用任意次。在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。如果函数嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。\n\n\n#### 函数定义\n\n在 JavaScript 中，函数实际上是对象，每个函数都是Function构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常有以下3中定义方式。例如：\n \t\n\t// 写法一：函数声明（推荐写法）\n\n\tfunction   sum(num1, num2){\n\t\n\t\treturn   num1 + num2;\n\t\t\n\t}\n\n\t// 写法二：函数表达式（推荐写法）\n\t\n\tvar    sum =function(num1, num2){\n\t\n\t\treturn    num1 + num2;\n\t\t\n\t};\n\n\t// 写法三：Function 构造函数（不推荐写法）\n\n\tvar   sum =new   Function(\"num1\",\"num2\",\"return num1 + \tnum2\");\n\t\n由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。例如：\n\n\tfunction   sum(num1, num2){\n\t\n\treturnnum1 + num2;\n\n\t}\n\n\tconsole.log(sum(10,10));   // 20\n\n\tvar   anotherSum = sum;\n\n\tconsole.log(anotherSum(10,10));   // 20\n\n\tsum = null;\n\n\tconsole.log(anotherSum(10,10));  // 20\n\n### 没有重载\n\n将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。\n\n\tfunction   addSomeNumber(num){\n\t\n\treturn   num +100;\n\n\t}\n\n\tfunction   addSomeNumber(num){\n\t\n\treturn   num +200;\n\n\t}\n\n\tvar   result = addSomeNumber(100);  // 300\n\n\n显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。\n\n\tvar   addSomeNumber = function(num){\n\t\n\t\treturn   num +100;\n\n\t};\n\n\taddSomeNumber = function(num){\n\t\n\t\treturn   num +200;\n\n\t};\n\n\tvar   result = addSomeNumber(100);   // 300\n\t\n\n通过重写代码之后可以很容易明白，在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。\n\n函数声明与函数表达式（函数是js中的一等公民，JavaScript 引擎在渲染js时会把通过函数声明声明的函数放在js的顶部优先解析）\n\n解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。例如：\n\n\tconsole.log(sum(10,10));   // 20\n\n\tfunction   sum(num1, num2){\n\n  \treturn   num1 + num2;\n\n\t}\n\n以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。把上面的「函数声明」改为等价的「函数表达式」，就会在执行期间导致错误。例如：\n\n\tconsole.log(sum(10,10));   // Uncaught TypeError: sum \tis not a function\n\n\tvar   sum =function(num1, num2){\n\t\n\treturn   num1 + num2;\n\n\t};\n\n除了上述区别之外，「函数声明」与「函数表达式」的语法是等价的。\n\n### 作为值的函数\n\n因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。\n\n\tfunction   callSomeFunction(someFunction,someArgument){\n\n  \treturn   someFunction(someArgument);\n\n\t}\n\t\n这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。\n\n\n\tfunction   add10(num){ \t\t        \n\t\n\t\n\t\treturn   num +10;\n\n\t}\n\n\tvar   result1 = callSomeFunction(add10,10);\n\n\tconsole.log(result1);   // 20\n\n\tfunction   getGreeting(name){\n\t\n\t\treturn   \"Hello, \"+ name;\n\n\t}\n\n\tvar  result2 = callSomeFunction(getGreeting,\"Nicholas\");\n\n\tconsole.log(result2);   // \"Hello, Nicholas\"\n\n\t\n这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。因此上面例子中传递给callSomeFunction()的是add10和getGreeting，而不是执行它们之后的结果。\n\n当然，还可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。\n\n\tfunction   createComparisonFunction(propertyName){\n\t\n\t\treturn   function(object1, object2){\n\t\t\n\t\t\t var   value1 = object1[propertyName];\n\t\t\t \n\t\t\t var   value2 = object2[propertyName];\n\t\t\t \n\t\t\t if(value1 < value2){\n\t\t\t \n\t\t\t \t\treturn -1;        \n\t\t\t \t\t\n\t\t\t \t}else  if(value1 > value2){\n\t\t\t \t\n\t\t\t \treturn 1;      \n\t\t\t \t\n\t\t\t \t}else{\n\t\t\t \t\n\t\t\t \t\treturn 0;        \n\t\t\t \t\t\n\t\t\t \t}    \n\t\t\t }\n\t\t  }\n\n这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。\n\n\tvar   data = [{name:\"Zachary\",age:28}, {name:\"Nicholas\",age:29}];\n\n\tdata.sort(createComparisonFunction(\"name\"));\n\n\tconsole.log(data[0].name);   //Nicholas\n\n\tdata.sort(createComparisonFunction(\"age\"));\n\n\tconsole.log(data[0].name);   // Zachary\n\n这里，我们创建了一个包含两个对象的数组data。其中，每个对象都包含一个name属性和一个age属性。在默认情况下，sort()方法会调用每个对象的toString()方法以确定它们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用createComparisonFunction(\"name\")方法创建了一个比较函数，以便按照每个对象的name属性值进行排序。而结果排在前面的第一项是name为\"Nicholas\"，age是29的对象。然后，我们又使用了createComparisonFunction(\"age\")返回的比较函数，这次是按照对象的age属性排序。得到的结果是name值为\"Zachary\"，age值是28的对象排在了第一位。\n\n### 函数的形参和实参\n\n在函数内部，有两个特殊的对象：arguments和this。其中，arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。\n\n\tfunction   factorial(num){\n\t\n\t\tif(num <=1) {\n\t\t\n\t\t\treturn 1;  \n\t\t\t\n\t\t}else{\n\t\t\n\t\t\treturn  num * factorial(num-1)    \n\t\t\t\n\t\t}\n\t\t\n\t}\n\n定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。\n\n\tfunction   factorial(num){\n\t\t\n\t\t\tif(num <=1) {\n\t\t\t\n\t\t\t\treturn  1;  \n\t\t\t\t\t\n\t\t\t}else{\n\t\t\t\n\t\t\t\treturn  num *arguments.callee(num-1)  \n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t}\n\n在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：\n\n\tvar   trueFactorial = factorial;\n\n\tfactorial =function(){\n\t\n\t\treturn  0;\n\t\t\n\t};\n\n\tconsole.log(trueFactorial(5));   // 120\n\n\tconsole.log(factorial(5));   // 0\n\n在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的factorial()那样不使用arguments.callee，调用trueFactorial()就会返回0。可是，在解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘；至于factorial()，它现在只是一个返回0的函数。\n\n函数内部的另一个特殊对象是this，其行为与 Java 和 C# 中的this大致类似。换句话说，this引用的是函数据以执行的环境对象（当在网页的全局作用域中调用函数时，this对象引用的就是window）。来看下面的例子。\n\n\twindow.color =\"red\";\n\n\tvar o = {color:\"blue\"};\n\n\tfunction sayColor(){\n\t\n\t\tconsole.log(this.color);\n\t\t\n\t}\n\n\tsayColor();   // \"red\"\n\n\to.sayColor = sayColor;\n\n\to.sayColor();   // \"blue\"\n\n上面这个函数sayColor()是在全局作用域中定义的，它引用了this对象。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引用的是全局对象window；换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了\"red\"。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了\"blue\"。\n\n请大家一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。\n\nECMAScript 5也规范化了另一个函数对象的属性caller。这个属性中保存着「调用当前函数的函数的引用」，如果是在全局作用域中调用当前函数，它的值为null。例如：\n\n\tfunction  outer(){  \n\n        inner();\n\n\t}\n\n\tfunction  inner(){\n\n      console.log(arguments.callee.caller);\n\n\t}\n\n\touter();\n\n以上代码会导致警告框中显示outer()函数的源代码。因为outer()调用了inter()，所以arguments.callee.caller就指向outer()。\n\n在严格模式下，访问arguments.callee属性，或为函数的caller属性赋值，都会导致错误。\n\n### 函数的属性和方法\n\nJavaScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数，如下面的例子所示。\n\n\tfunction   sayName(name){\n\t\n\t\tconsole.log(name);\n\n\t}\n\n\tfunction   sum(num1, num2){\n\t\n\t\treturn    num1 + num2;\n\n\t}\n\n\tfunction   sayHi(){\n\t\n\t\t console.log(\"hi\");\n\n\t}\n\n\tconsole.log(sayName.length);     // 1\n\n\tconsole.log(sum.length);   // 2\n\n\tconsole.log(sayHi.length);   // 0\n对于 JavaScript 中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。在 ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。\n\n每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如：\n\n\tfunction   sum(num1, num2){\n\t\treturn   num1 + num2;\n\n\t}\n\n\tfunction    callSum1(num1, num2){\n\t\n\t\treturn   sum.apply(this,arguments);  // 传入 arguments 对象\n\n\t}\n\n\tfunction   callSum2(num1, num2){\n\t\treturn   sum.apply(this, [num1, num2]);   // 传入数组\n\n\t}\n\n\tconsole.log(callSum1(10,10));   // 20\n\n\tconsole.log(callSum2(10,10));   // 20\n在上面这个例子中，callSum1()在执行sum()函数时传入了this（因为是在全局作用域中调用的，所以传入的就是window对象）和arguments对象。而callSum2同样也调用了sum()函数，但它传入的则是this和一个参数数组。这两个函数都会正常执行并返回正确的结果。\n\ncall()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。\n\n\tfunction   sum(num1, num2){\n\t\n\t\treturnnum1 + num2;\n\n\t}\n\n\tfunction   callSum(num1, num2){\n\t\n\t\treturnsum.call(this, num1, num2);\n\n\t}\n\n\tconsole.log(callSum(10,10));   // 20\n\n在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）\n\n事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。\n\n\twindow.color =\"red\";\n\n\tvar o = {color:\"blue\"};\n\n\tfunction   sayColor(){\n\t\n\t\tconsole.log(this.color);\n\n\t}\n\n\tsayColor();   // red\n\n\tsayColor.call(this);   // red\n\n\tsayColor.call(window);   // red\n\n\tsayColor.call(o);   // blue\n\n这个例子是在前面说明this对象的示例基础上修改而成的。这一次，sayColor()也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示\"red\"，因为对this.color的求值会转换成对window.color的求值。而sayColor.call(this)和sayColor.call(window)，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示\"red\"。但是，当运行sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的this对象指向了o，于是结果显示的是\"blue\"。\n\n使用call()或apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将sayColor()函数放到了对象o中，然后再通过o来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。\n\n2、全局安装gulp\n        2.1、说明：全局安装gulp目的是为了通过她执行gulp任务；\n\n        2.2、安装：命令提示符执行npm install gulp -g；\n\n        2.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。\n\n3、新建package.json文件\n       3.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；\n\n       3.2、执行命令提示符执行npm init进行手动安装\n\n      3.3、安装完成后会在当前文件夹下看到如下package.json文件\n\n\n\n文/原创／Dimple（github作者）\n原文链接：https://cuidapao.github.io/\n著作权归作者所有，转载请联系作者获得授权，并标注\"github作者\"。\n\n\n","slug":"函数详解","published":1,"updated":"2016-11-16T13:01:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civm2xnyt000v1rsmv769k7vl","content":"<h1 id=\"javaScript之函数详解\"><a href=\"#javaScript之函数详解\" class=\"headerlink\" title=\"javaScript之函数详解\"></a>javaScript之函数详解</h1><p>本文档内容参考<a href=\"http://gold.xitu.io/post/582087522e958a0054f8ed36\" target=\"_blank\" rel=\"external\"><font style=\"color:blue\">《JavaScript闯关记》</font></a>之函数</p>\n<p>函数是一段代码，他只定义一次，但可以被执行或调用任意次。在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。如果函数嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。</p>\n<h4 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h4><p>在 JavaScript 中，函数实际上是对象，每个函数都是Function构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常有以下3中定义方式。例如：</p>\n<pre><code>// 写法一：函数声明（推荐写法）\n\nfunction   sum(num1, num2){\n\n    return   num1 + num2;\n\n}\n\n// 写法二：函数表达式（推荐写法）\n\nvar    sum =function(num1, num2){\n\n    return    num1 + num2;\n\n};\n\n// 写法三：Function 构造函数（不推荐写法）\n\nvar   sum =new   Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1 +     num2&quot;);\n</code></pre><p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。例如：</p>\n<pre><code>function   sum(num1, num2){\n\nreturnnum1 + num2;\n\n}\n\nconsole.log(sum(10,10));   // 20\n\nvar   anotherSum = sum;\n\nconsole.log(anotherSum(10,10));   // 20\n\nsum = null;\n\nconsole.log(anotherSum(10,10));  // 20\n</code></pre><h3 id=\"没有重载\"><a href=\"#没有重载\" class=\"headerlink\" title=\"没有重载\"></a>没有重载</h3><p>将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。</p>\n<pre><code>function   addSomeNumber(num){\n\nreturn   num +100;\n\n}\n\nfunction   addSomeNumber(num){\n\nreturn   num +200;\n\n}\n\nvar   result = addSomeNumber(100);  // 300\n</code></pre><p>显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。</p>\n<pre><code>var   addSomeNumber = function(num){\n\n    return   num +100;\n\n};\n\naddSomeNumber = function(num){\n\n    return   num +200;\n\n};\n\nvar   result = addSomeNumber(100);   // 300\n</code></pre><p>通过重写代码之后可以很容易明白，在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。</p>\n<p>函数声明与函数表达式（函数是js中的一等公民，JavaScript 引擎在渲染js时会把通过函数声明声明的函数放在js的顶部优先解析）</p>\n<p>解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。例如：</p>\n<pre><code>console.log(sum(10,10));   // 20\n\nfunction   sum(num1, num2){\n\n  return   num1 + num2;\n\n}\n</code></pre><p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。把上面的「函数声明」改为等价的「函数表达式」，就会在执行期间导致错误。例如：</p>\n<pre><code>console.log(sum(10,10));   // Uncaught TypeError: sum     is not a function\n\nvar   sum =function(num1, num2){\n\nreturn   num1 + num2;\n\n};\n</code></pre><p>除了上述区别之外，「函数声明」与「函数表达式」的语法是等价的。</p>\n<h3 id=\"作为值的函数\"><a href=\"#作为值的函数\" class=\"headerlink\" title=\"作为值的函数\"></a>作为值的函数</h3><p>因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。</p>\n<pre><code>function   callSomeFunction(someFunction,someArgument){\n\n  return   someFunction(someArgument);\n\n}\n</code></pre><p>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。</p>\n<pre><code>function   add10(num){                 \n\n\n    return   num +10;\n\n}\n\nvar   result1 = callSomeFunction(add10,10);\n\nconsole.log(result1);   // 20\n\nfunction   getGreeting(name){\n\n    return   &quot;Hello, &quot;+ name;\n\n}\n\nvar  result2 = callSomeFunction(getGreeting,&quot;Nicholas&quot;);\n\nconsole.log(result2);   // &quot;Hello, Nicholas&quot;\n</code></pre><p>这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。因此上面例子中传递给callSomeFunction()的是add10和getGreeting，而不是执行它们之后的结果。</p>\n<p>当然，还可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。</p>\n<pre><code>function   createComparisonFunction(propertyName){\n\n    return   function(object1, object2){\n\n         var   value1 = object1[propertyName];\n\n         var   value2 = object2[propertyName];\n\n         if(value1 &lt; value2){\n\n                 return -1;        \n\n             }else  if(value1 &gt; value2){\n\n             return 1;      \n\n             }else{\n\n                 return 0;        \n\n             }    \n         }\n      }\n</code></pre><p>这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。</p>\n<pre><code>var   data = [{name:&quot;Zachary&quot;,age:28}, {name:&quot;Nicholas&quot;,age:29}];\n\ndata.sort(createComparisonFunction(&quot;name&quot;));\n\nconsole.log(data[0].name);   //Nicholas\n\ndata.sort(createComparisonFunction(&quot;age&quot;));\n\nconsole.log(data[0].name);   // Zachary\n</code></pre><p>这里，我们创建了一个包含两个对象的数组data。其中，每个对象都包含一个name属性和一个age属性。在默认情况下，sort()方法会调用每个对象的toString()方法以确定它们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用createComparisonFunction(“name”)方法创建了一个比较函数，以便按照每个对象的name属性值进行排序。而结果排在前面的第一项是name为”Nicholas”，age是29的对象。然后，我们又使用了createComparisonFunction(“age”)返回的比较函数，这次是按照对象的age属性排序。得到的结果是name值为”Zachary”，age值是28的对象排在了第一位。</p>\n<h3 id=\"函数的形参和实参\"><a href=\"#函数的形参和实参\" class=\"headerlink\" title=\"函数的形参和实参\"></a>函数的形参和实参</h3><p>在函数内部，有两个特殊的对象：arguments和this。其中，arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。</p>\n<pre><code>function   factorial(num){\n\n    if(num &lt;=1) {\n\n        return 1;  \n\n    }else{\n\n        return  num * factorial(num-1)    \n\n    }\n\n}\n</code></pre><p>定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。</p>\n<pre><code>function   factorial(num){\n\n        if(num &lt;=1) {\n\n            return  1;  \n\n        }else{\n\n            return  num *arguments.callee(num-1)  \n\n        }\n\n}\n</code></pre><p>在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</p>\n<pre><code>var   trueFactorial = factorial;\n\nfactorial =function(){\n\n    return  0;\n\n};\n\nconsole.log(trueFactorial(5));   // 120\n\nconsole.log(factorial(5));   // 0\n</code></pre><p>在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的factorial()那样不使用arguments.callee，调用trueFactorial()就会返回0。可是，在解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘；至于factorial()，它现在只是一个返回0的函数。</p>\n<p>函数内部的另一个特殊对象是this，其行为与 Java 和 C# 中的this大致类似。换句话说，this引用的是函数据以执行的环境对象（当在网页的全局作用域中调用函数时，this对象引用的就是window）。来看下面的例子。</p>\n<pre><code>window.color =&quot;red&quot;;\n\nvar o = {color:&quot;blue&quot;};\n\nfunction sayColor(){\n\n    console.log(this.color);\n\n}\n\nsayColor();   // &quot;red&quot;\n\no.sayColor = sayColor;\n\no.sayColor();   // &quot;blue&quot;\n</code></pre><p>上面这个函数sayColor()是在全局作用域中定义的，它引用了this对象。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引用的是全局对象window；换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了”red”。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了”blue”。</p>\n<p>请大家一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。</p>\n<p>ECMAScript 5也规范化了另一个函数对象的属性caller。这个属性中保存着「调用当前函数的函数的引用」，如果是在全局作用域中调用当前函数，它的值为null。例如：</p>\n<pre><code>function  outer(){  \n\n    inner();\n\n}\n\nfunction  inner(){\n\n  console.log(arguments.callee.caller);\n\n}\n\nouter();\n</code></pre><p>以上代码会导致警告框中显示outer()函数的源代码。因为outer()调用了inter()，所以arguments.callee.caller就指向outer()。</p>\n<p>在严格模式下，访问arguments.callee属性，或为函数的caller属性赋值，都会导致错误。</p>\n<h3 id=\"函数的属性和方法\"><a href=\"#函数的属性和方法\" class=\"headerlink\" title=\"函数的属性和方法\"></a>函数的属性和方法</h3><p>JavaScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数，如下面的例子所示。</p>\n<pre><code>function   sayName(name){\n\n    console.log(name);\n\n}\n\nfunction   sum(num1, num2){\n\n    return    num1 + num2;\n\n}\n\nfunction   sayHi(){\n\n     console.log(&quot;hi&quot;);\n\n}\n\nconsole.log(sayName.length);     // 1\n\nconsole.log(sum.length);   // 2\n\nconsole.log(sayHi.length);   // 0\n</code></pre><p>对于 JavaScript 中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。在 ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。</p>\n<p>每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如：</p>\n<pre><code>function   sum(num1, num2){\n    return   num1 + num2;\n\n}\n\nfunction    callSum1(num1, num2){\n\n    return   sum.apply(this,arguments);  // 传入 arguments 对象\n\n}\n\nfunction   callSum2(num1, num2){\n    return   sum.apply(this, [num1, num2]);   // 传入数组\n\n}\n\nconsole.log(callSum1(10,10));   // 20\n\nconsole.log(callSum2(10,10));   // 20\n</code></pre><p>在上面这个例子中，callSum1()在执行sum()函数时传入了this（因为是在全局作用域中调用的，所以传入的就是window对象）和arguments对象。而callSum2同样也调用了sum()函数，但它传入的则是this和一个参数数组。这两个函数都会正常执行并返回正确的结果。</p>\n<p>call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。</p>\n<pre><code>function   sum(num1, num2){\n\n    returnnum1 + num2;\n\n}\n\nfunction   callSum(num1, num2){\n\n    returnsum.call(this, num1, num2);\n\n}\n\nconsole.log(callSum(10,10));   // 20\n</code></pre><p>在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）</p>\n<p>事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。</p>\n<pre><code>window.color =&quot;red&quot;;\n\nvar o = {color:&quot;blue&quot;};\n\nfunction   sayColor(){\n\n    console.log(this.color);\n\n}\n\nsayColor();   // red\n\nsayColor.call(this);   // red\n\nsayColor.call(window);   // red\n\nsayColor.call(o);   // blue\n</code></pre><p>这个例子是在前面说明this对象的示例基础上修改而成的。这一次，sayColor()也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示”red”，因为对this.color的求值会转换成对window.color的求值。而sayColor.call(this)和sayColor.call(window)，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示”red”。但是，当运行sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的this对象指向了o，于是结果显示的是”blue”。</p>\n<p>使用call()或apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将sayColor()函数放到了对象o中，然后再通过o来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。</p>\n<p>2、全局安装gulp<br>        2.1、说明：全局安装gulp目的是为了通过她执行gulp任务；</p>\n<pre><code>2.2、安装：命令提示符执行npm install gulp -g；\n\n2.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。\n</code></pre><p>3、新建package.json文件<br>       3.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；</p>\n<pre><code> 3.2、执行命令提示符执行npm init进行手动安装\n\n3.3、安装完成后会在当前文件夹下看到如下package.json文件\n</code></pre><p>文/原创／Dimple（github作者）<br>原文链接：<a href=\"https://cuidapao.github.io/\" target=\"_blank\" rel=\"external\">https://cuidapao.github.io/</a><br>著作权归作者所有，转载请联系作者获得授权，并标注”github作者”。</p>\n","excerpt":"","more":"<h1 id=\"javaScript之函数详解\"><a href=\"#javaScript之函数详解\" class=\"headerlink\" title=\"javaScript之函数详解\"></a>javaScript之函数详解</h1><p>本文档内容参考<a href=\"http://gold.xitu.io/post/582087522e958a0054f8ed36\"><font style=\"color:blue\">《JavaScript闯关记》</font></a>之函数</p>\n<p>函数是一段代码，他只定义一次，但可以被执行或调用任意次。在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。如果函数嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。</p>\n<h4 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h4><p>在 JavaScript 中，函数实际上是对象，每个函数都是Function构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常有以下3中定义方式。例如：</p>\n<pre><code>// 写法一：函数声明（推荐写法）\n\nfunction   sum(num1, num2){\n\n    return   num1 + num2;\n\n}\n\n// 写法二：函数表达式（推荐写法）\n\nvar    sum =function(num1, num2){\n\n    return    num1 + num2;\n\n};\n\n// 写法三：Function 构造函数（不推荐写法）\n\nvar   sum =new   Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1 +     num2&quot;);\n</code></pre><p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。例如：</p>\n<pre><code>function   sum(num1, num2){\n\nreturnnum1 + num2;\n\n}\n\nconsole.log(sum(10,10));   // 20\n\nvar   anotherSum = sum;\n\nconsole.log(anotherSum(10,10));   // 20\n\nsum = null;\n\nconsole.log(anotherSum(10,10));  // 20\n</code></pre><h3 id=\"没有重载\"><a href=\"#没有重载\" class=\"headerlink\" title=\"没有重载\"></a>没有重载</h3><p>将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。</p>\n<pre><code>function   addSomeNumber(num){\n\nreturn   num +100;\n\n}\n\nfunction   addSomeNumber(num){\n\nreturn   num +200;\n\n}\n\nvar   result = addSomeNumber(100);  // 300\n</code></pre><p>显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。</p>\n<pre><code>var   addSomeNumber = function(num){\n\n    return   num +100;\n\n};\n\naddSomeNumber = function(num){\n\n    return   num +200;\n\n};\n\nvar   result = addSomeNumber(100);   // 300\n</code></pre><p>通过重写代码之后可以很容易明白，在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。</p>\n<p>函数声明与函数表达式（函数是js中的一等公民，JavaScript 引擎在渲染js时会把通过函数声明声明的函数放在js的顶部优先解析）</p>\n<p>解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。例如：</p>\n<pre><code>console.log(sum(10,10));   // 20\n\nfunction   sum(num1, num2){\n\n  return   num1 + num2;\n\n}\n</code></pre><p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。把上面的「函数声明」改为等价的「函数表达式」，就会在执行期间导致错误。例如：</p>\n<pre><code>console.log(sum(10,10));   // Uncaught TypeError: sum     is not a function\n\nvar   sum =function(num1, num2){\n\nreturn   num1 + num2;\n\n};\n</code></pre><p>除了上述区别之外，「函数声明」与「函数表达式」的语法是等价的。</p>\n<h3 id=\"作为值的函数\"><a href=\"#作为值的函数\" class=\"headerlink\" title=\"作为值的函数\"></a>作为值的函数</h3><p>因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。</p>\n<pre><code>function   callSomeFunction(someFunction,someArgument){\n\n  return   someFunction(someArgument);\n\n}\n</code></pre><p>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。</p>\n<pre><code>function   add10(num){                 \n\n\n    return   num +10;\n\n}\n\nvar   result1 = callSomeFunction(add10,10);\n\nconsole.log(result1);   // 20\n\nfunction   getGreeting(name){\n\n    return   &quot;Hello, &quot;+ name;\n\n}\n\nvar  result2 = callSomeFunction(getGreeting,&quot;Nicholas&quot;);\n\nconsole.log(result2);   // &quot;Hello, Nicholas&quot;\n</code></pre><p>这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。因此上面例子中传递给callSomeFunction()的是add10和getGreeting，而不是执行它们之后的结果。</p>\n<p>当然，还可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。</p>\n<pre><code>function   createComparisonFunction(propertyName){\n\n    return   function(object1, object2){\n\n         var   value1 = object1[propertyName];\n\n         var   value2 = object2[propertyName];\n\n         if(value1 &lt; value2){\n\n                 return -1;        \n\n             }else  if(value1 &gt; value2){\n\n             return 1;      \n\n             }else{\n\n                 return 0;        \n\n             }    \n         }\n      }\n</code></pre><p>这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。</p>\n<pre><code>var   data = [{name:&quot;Zachary&quot;,age:28}, {name:&quot;Nicholas&quot;,age:29}];\n\ndata.sort(createComparisonFunction(&quot;name&quot;));\n\nconsole.log(data[0].name);   //Nicholas\n\ndata.sort(createComparisonFunction(&quot;age&quot;));\n\nconsole.log(data[0].name);   // Zachary\n</code></pre><p>这里，我们创建了一个包含两个对象的数组data。其中，每个对象都包含一个name属性和一个age属性。在默认情况下，sort()方法会调用每个对象的toString()方法以确定它们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用createComparisonFunction(“name”)方法创建了一个比较函数，以便按照每个对象的name属性值进行排序。而结果排在前面的第一项是name为”Nicholas”，age是29的对象。然后，我们又使用了createComparisonFunction(“age”)返回的比较函数，这次是按照对象的age属性排序。得到的结果是name值为”Zachary”，age值是28的对象排在了第一位。</p>\n<h3 id=\"函数的形参和实参\"><a href=\"#函数的形参和实参\" class=\"headerlink\" title=\"函数的形参和实参\"></a>函数的形参和实参</h3><p>在函数内部，有两个特殊的对象：arguments和this。其中，arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。</p>\n<pre><code>function   factorial(num){\n\n    if(num &lt;=1) {\n\n        return 1;  \n\n    }else{\n\n        return  num * factorial(num-1)    \n\n    }\n\n}\n</code></pre><p>定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。</p>\n<pre><code>function   factorial(num){\n\n        if(num &lt;=1) {\n\n            return  1;  \n\n        }else{\n\n            return  num *arguments.callee(num-1)  \n\n        }\n\n}\n</code></pre><p>在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</p>\n<pre><code>var   trueFactorial = factorial;\n\nfactorial =function(){\n\n    return  0;\n\n};\n\nconsole.log(trueFactorial(5));   // 120\n\nconsole.log(factorial(5));   // 0\n</code></pre><p>在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的factorial()那样不使用arguments.callee，调用trueFactorial()就会返回0。可是，在解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘；至于factorial()，它现在只是一个返回0的函数。</p>\n<p>函数内部的另一个特殊对象是this，其行为与 Java 和 C# 中的this大致类似。换句话说，this引用的是函数据以执行的环境对象（当在网页的全局作用域中调用函数时，this对象引用的就是window）。来看下面的例子。</p>\n<pre><code>window.color =&quot;red&quot;;\n\nvar o = {color:&quot;blue&quot;};\n\nfunction sayColor(){\n\n    console.log(this.color);\n\n}\n\nsayColor();   // &quot;red&quot;\n\no.sayColor = sayColor;\n\no.sayColor();   // &quot;blue&quot;\n</code></pre><p>上面这个函数sayColor()是在全局作用域中定义的，它引用了this对象。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引用的是全局对象window；换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了”red”。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了”blue”。</p>\n<p>请大家一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。</p>\n<p>ECMAScript 5也规范化了另一个函数对象的属性caller。这个属性中保存着「调用当前函数的函数的引用」，如果是在全局作用域中调用当前函数，它的值为null。例如：</p>\n<pre><code>function  outer(){  \n\n    inner();\n\n}\n\nfunction  inner(){\n\n  console.log(arguments.callee.caller);\n\n}\n\nouter();\n</code></pre><p>以上代码会导致警告框中显示outer()函数的源代码。因为outer()调用了inter()，所以arguments.callee.caller就指向outer()。</p>\n<p>在严格模式下，访问arguments.callee属性，或为函数的caller属性赋值，都会导致错误。</p>\n<h3 id=\"函数的属性和方法\"><a href=\"#函数的属性和方法\" class=\"headerlink\" title=\"函数的属性和方法\"></a>函数的属性和方法</h3><p>JavaScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数，如下面的例子所示。</p>\n<pre><code>function   sayName(name){\n\n    console.log(name);\n\n}\n\nfunction   sum(num1, num2){\n\n    return    num1 + num2;\n\n}\n\nfunction   sayHi(){\n\n     console.log(&quot;hi&quot;);\n\n}\n\nconsole.log(sayName.length);     // 1\n\nconsole.log(sum.length);   // 2\n\nconsole.log(sayHi.length);   // 0\n</code></pre><p>对于 JavaScript 中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。在 ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。</p>\n<p>每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如：</p>\n<pre><code>function   sum(num1, num2){\n    return   num1 + num2;\n\n}\n\nfunction    callSum1(num1, num2){\n\n    return   sum.apply(this,arguments);  // 传入 arguments 对象\n\n}\n\nfunction   callSum2(num1, num2){\n    return   sum.apply(this, [num1, num2]);   // 传入数组\n\n}\n\nconsole.log(callSum1(10,10));   // 20\n\nconsole.log(callSum2(10,10));   // 20\n</code></pre><p>在上面这个例子中，callSum1()在执行sum()函数时传入了this（因为是在全局作用域中调用的，所以传入的就是window对象）和arguments对象。而callSum2同样也调用了sum()函数，但它传入的则是this和一个参数数组。这两个函数都会正常执行并返回正确的结果。</p>\n<p>call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。</p>\n<pre><code>function   sum(num1, num2){\n\n    returnnum1 + num2;\n\n}\n\nfunction   callSum(num1, num2){\n\n    returnsum.call(this, num1, num2);\n\n}\n\nconsole.log(callSum(10,10));   // 20\n</code></pre><p>在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）</p>\n<p>事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。</p>\n<pre><code>window.color =&quot;red&quot;;\n\nvar o = {color:&quot;blue&quot;};\n\nfunction   sayColor(){\n\n    console.log(this.color);\n\n}\n\nsayColor();   // red\n\nsayColor.call(this);   // red\n\nsayColor.call(window);   // red\n\nsayColor.call(o);   // blue\n</code></pre><p>这个例子是在前面说明this对象的示例基础上修改而成的。这一次，sayColor()也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示”red”，因为对this.color的求值会转换成对window.color的求值。而sayColor.call(this)和sayColor.call(window)，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示”red”。但是，当运行sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的this对象指向了o，于是结果显示的是”blue”。</p>\n<p>使用call()或apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将sayColor()函数放到了对象o中，然后再通过o来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。</p>\n<p>2、全局安装gulp<br>        2.1、说明：全局安装gulp目的是为了通过她执行gulp任务；</p>\n<pre><code>2.2、安装：命令提示符执行npm install gulp -g；\n\n2.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。\n</code></pre><p>3、新建package.json文件<br>       3.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；</p>\n<pre><code> 3.2、执行命令提示符执行npm init进行手动安装\n\n3.3、安装完成后会在当前文件夹下看到如下package.json文件\n</code></pre><p>文/原创／Dimple（github作者）<br>原文链接：<a href=\"https://cuidapao.github.io/\">https://cuidapao.github.io/</a><br>著作权归作者所有，转载请联系作者获得授权，并标注”github作者”。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"civm2xnvu00001rsm9f6su45f","tag_id":"civm2xnw200021rsm4udw2mrj","_id":"civm2xnw700061rsmcs1v6k3y"},{"post_id":"civm2xnvu00001rsm9f6su45f","tag_id":"civm2xnw700041rsmbc8wr8pt","_id":"civm2xnw700071rsmpgj2kotj"},{"post_id":"civm2xnw500031rsme4zaydi6","tag_id":"civm2xnw700051rsmmyg9kv3m","_id":"civm2xnw800091rsm3bbya4m9"},{"post_id":"civm2xnw500031rsme4zaydi6","tag_id":"civm2xnw700081rsm5ue1uaxh","_id":"civm2xnw8000a1rsmc6ldlkpn"},{"post_id":"civm2xnwy000b1rsmjpz13pqx","tag_id":"civm2xnx4000d1rsm79viab1f","_id":"civm2xnx7000g1rsmmgougabf"},{"post_id":"civm2xnwy000b1rsmjpz13pqx","tag_id":"civm2xnx5000e1rsms4njxwxf","_id":"civm2xnx7000h1rsmt5komnjx"},{"post_id":"civm2xnx1000c1rsmrcyjq98c","tag_id":"civm2xnx7000f1rsmll4chorc","_id":"civm2xnxb000k1rsmfomguzu1"},{"post_id":"civm2xnx1000c1rsmrcyjq98c","tag_id":"civm2xnx8000i1rsm06ts368i","_id":"civm2xnxb000l1rsmjdm4873z"},{"post_id":"civm2xnx1000c1rsmrcyjq98c","tag_id":"civm2xnxa000j1rsm2kdr39up","_id":"civm2xnxb000m1rsmpbyg19yg"},{"post_id":"civm2xnxw000o1rsmby9w1qrd","tag_id":"civm2xnw700051rsmmyg9kv3m","_id":"civm2xny1000q1rsmhj2tmpyt"},{"post_id":"civm2xnxw000o1rsmby9w1qrd","tag_id":"civm2xnx4000d1rsm79viab1f","_id":"civm2xny2000r1rsmhauby8in"},{"post_id":"civm2xnxt000n1rsmad829ubk","tag_id":"civm2xny0000p1rsm18h3h2c0","_id":"civm2xny3000t1rsmi5t4ouws"},{"post_id":"civm2xnxt000n1rsmad829ubk","tag_id":"civm2xny2000s1rsmqgcmao2z","_id":"civm2xny4000u1rsmym9r9u76"},{"post_id":"civm2xnyt000v1rsmv769k7vl","tag_id":"civm2xnw700051rsmmyg9kv3m","_id":"civm2xnyv000x1rsmjlgle6de"},{"post_id":"civm2xnyt000v1rsmv769k7vl","tag_id":"civm2xnyv000w1rsmfjmvnszu","_id":"civm2xnyv000y1rsmcc1nk8pa"}],"Tag":[{"name":"gulp","_id":"civm2xnw200021rsm4udw2mrj"},{"name":"gulp入门教程详解","_id":"civm2xnw700041rsmbc8wr8pt"},{"name":"javascript","_id":"civm2xnw700051rsmmyg9kv3m"},{"name":"7种创建对象的方法","_id":"civm2xnw700081rsm5ue1uaxh"},{"name":"CSS","_id":"civm2xnx4000d1rsm79viab1f"},{"name":"实现简单的轮播图","_id":"civm2xnx5000e1rsms4njxwxf"},{"name":"js","_id":"civm2xnx7000f1rsmll4chorc"},{"name":"canvas","_id":"civm2xnx8000i1rsm06ts368i"},{"name":"面试题","_id":"civm2xnxa000j1rsm2kdr39up"},{"name":"vue","_id":"civm2xny0000p1rsm18h3h2c0"},{"name":"基于vue直播播放器实战","_id":"civm2xny2000s1rsmqgcmao2z"},{"name":"函数详解","_id":"civm2xnyv000w1rsmfjmvnszu"}]}}